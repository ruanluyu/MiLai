{"./":{"url":"./","title":"Be the Creator of your World","keywords":"","body":"Become the Creator God PixelsWorld documentation version: v3.7.0 Author ZzStarSound History v2.3.1 v1.0 中文版 日本語 Slack Forum Download docs(English) Download docs(中文) Download docs(日本語) Welcome to PixelsWorld! In this section, we've distilled the essence of using PixelsWorld. If you comprehend this part, you'll become a new creator in PixelsWorld! Simply Put PixelsWorld renders graphics based on your code Here are some key points you must know: PixelsWorld functions like a simple game engine. All the code you provide runs within a Lua engine. Writing code in PixelsWorld is like crafting a powerful expression. PixelsWorld supports: Mathematical Operations Texture Manipulation Custom Filters GLSL Code from shadertoy.com PixelsWorld can render simple 2D/3D geometries. Details >>> Video Tutorials We highly recommend starting with our foundational tutorials. Basic Tutorials >>> 2D Transformations >>> Lua Example: Drawing a House Here, we provide a code example for drawing a house in Lua mode. DrawHouse1.lua version3() -- Use version 3, always call this function on the first line. move(width/2, height/2) -- Move the brush to the center of the screen rotateX(PI) -- Rotate the brush coordinates 180 degrees around the X-axis fill(1,1,0) -- Use yellow paint (red=1, green=1, blue=0) rect(100) -- Draw a 100x100 pixel square fill(1,0,0) -- Use red paint (red=1, green=0, blue=0) move(0,50) -- Move the brush coordinates up 50 pixels tri(150,100) -- Draw an isosceles triangle with a base of 150 pixels and height of 100 pixels Here, we aim to add some extra controls to the scene, like a color combination controller for the house. DrawHouse2.lua version3() -- Use version 3, always call this function on the first line. move(width/2, height/2) -- Move the brush coordinates to the center rotateX(PI) -- Rotate the brush coordinates 180 degrees around the X-axis fill(color(0)) -- Use color #0 rect(100) -- Draw a 100x100 pixel square fill(color(1)) -- Use color #1 move(0,50) -- Move the brush coordinates up 50 pixels tri(150,100) -- Draw an isosceles triangle with a base of 150 pixels and height of 100 pixels Then click confirm, and the house will... disappear! In fact, our house is still being rendered on the layer, but as the default colors of the color controller are black, the house seems to disappear. To resolve this, open the parameter list, find the first two color controllers, and change them to your preferred colors. I'm the Mayor! Draw More Houses The great advantage of code is handling repetitive operations. Needless to say, the Lua language allows you to write loop code. DrawHouse3.lua version3() -- Use version 3, always call this function on the first line. move(width/2, height/2) -- Move the brush coordinates to the center rotateX(PI) -- Rotate the brush coordinates 180 degrees around the X-axis for i=1,3 do -- Start repeating (3 times) fill(color(0)) -- Use color #0 rect(100) -- Draw a 100x100 pixel square fill(color(1)) -- Use color #1 move(0,50) -- Move the brush coordinates up 50 pixels tri(150,100) -- Draw an isosceles triangle with a base of 150 pixels and height of 100 pixels move(0,-50) -- Move the brush coordinates back move(175,0) -- Move the brush coordinates 175 pixels to the right end -- End repeating The above code includes the operation of \"moving the brush coordinates back,\" which can be cumbersome each time. Use beginGroup() and endGroup() to simplify: DrawHouse4.lua version3() -- Use version 3, always call this function on the first line. move(width/2, height/2) -- Move the brush coordinates to the center rotateX(PI) -- Rotate the brush coordinates 180 degrees around the X-axis for i=1,3 do -- Start loop (3 times) fill(color(0)) -- Use color #0 rect(100) -- Draw a 100x100 pixel square fill(color(1)) -- Use color #1 beginGroup() -- New line! Start recording brush coordinate transformations move(0,50) -- Move the brush coordinates up 50 pixels tri(150,100) -- Draw an isosceles triangle with a base of 150 pixels and height of 100 pixels endGroup() -- New line! This line will automatically call 'move(0,-50)' move(175,0) -- Move the brush coordinates 175 pixels to the right end -- End loop Finally, we want to name the controllers: Saving Code as Presets Note: If you installed Ae on the system disk (e.g., C:\\), this step requires admin mode. First, create your own preset category: Then save your preset under your own preset category: Applying Presets Select the preset you want, and click the Replace button on the right. Congratulations! You've mastered the general usage process of PixelsWorld! >>>Next Step (Beginner): Enter the Lua chapter to understand the core capabilities of PixelsWorld >>>Next Step (Intermediate): Learn how to call the GPU to help you render and process images >>>Next Step (Professional): I am already familiar with Lua and just want to know what functions and variables are defined in PixelsWorld's Lua environment >>>Next Step (Professional): I am already familiar with GPU shaders and just want to know what variables are defined in PixelsWorld's GLSL environment PixelsWorld Structure PixelsWorld Capabilities "},"contents/HowTo.html":{"url":"contents/HowTo.html","title":"Get/Try/Purchase","keywords":"","body":"Obtain and Use Download Purchase/Download PixelsWorld Please Note: Some test presets are under a non-commercial license, please check the license in the source code before usage. Place the \"MiLai\" folder in: (Your AE root folder)/Support Files/Plug-ins/ The plugin should be located at: AE installation directory/Support Files/Plug-ins/MiLai/PixelsWorld.aex Usage Open Adobe After Effects. Use \"Ctrl + N\" (or \"Command + N\") to create a new composition. Create a new solid layer. Select the newly added layer. Right-click => Effects => MiLai => PixelsWorld Click \"Edit\" to change the \"World Rules\". A menu will pop up. In the upper-right corner of \"Preset list\", choose a desired effect category and select a preset from the list below. Click the Replace button. Click \"Ok\". "},"contents/Editor/ScriptWindow.html":{"url":"contents/Editor/ScriptWindow.html","title":"World formula editor","keywords":"","body":"World Formula Editor How to Open Click the \"Edit\" button next to \"World formula\" to open the World Formula Editor. Below is how it looks when opened. Note: The actual appearance may slightly differ with version updates. For clarification, we have outlined different functional areas in different colors, as shown below: ◆ Code Area You can write your creative rendering code in this area. The option at Language will automatically change the language type on the plugin panel after you finish editing. This setting will be recorded in the preset file when saving a preset. The (default) option will not modify your language. ◆ Reference Table This section provides some convenient code for you to copy and use. This document is currently in read-only mode and cannot be modified. ◆ Parameter Settings This area will display the parameter panel's name and default value, as well as language settings. If you want to modify the parameter name or default value, you can click Parameter manager below to enter the Parameter Manager. Parameter settings will be recorded in the preset file when saving a preset. ◆ Preset List The dropdown list above will show all preset categories. We define presets as follows: A JSON format file with the .pwp suffix, placed next to the plugin, will be regarded as a preset category. The category name is the file name. A preset category contains several preset data. All preset data within a category will be listed below the dropdown menu. ◆ Preset Formula Preview The code data of the preset data selected by the user in the list will be displayed here. If you are sure this preset is what you want, click the Replace button to replace the code in the Code Area. If you only want to replace the text part, you can deselect Apply when replace in the Preset Parameter Setting Preview area. If you want to add the preset code before the currently edited code, you can click the button; to add it after, click the Bottom>> button. ◆ Preset Parameter Setting Preview The parameter setting data of the preset data selected by the user in the list will be displayed here. If you are sure to use the current parameters, click the Apply button. The Apply when replace option box will determine whether to automatically apply the parameter settings on the current preset when you click the Replace button above. "},"contents/Editor/ParameterWindow.html":{"url":"contents/Editor/ParameterWindow.html","title":"Parameter manager","keywords":"","body":"Parameter Editor Launch the parameter editor by clicking the Parameter manager button on the World Rule Editor. Once opened, it appears as shown below: Rules Enter the name in the long box and the default value (decimal) in the short box. The Clear names button clears the names in each area. The Clear all names button at the bottom clears the names in all areas. The Reset names button resets each area's name to its default name, while the Reset all names button at the bottom resets the names in all areas to their default. The Reset value button resets each area's values, and the Reset all names button at the bottom also resets all areas' values. Note: The range for point and 3dpoint should be 0~1. For example, on a 1280x720 layer, when using 0.5, 0.5 as the default value for point, PixelsWorld will automatically convert it to 640x360 on the plugin panel UI's point control. Parameter Name Encoding Language PixelsWorld supports UTF-8 and local encoding, meaning parameter names theoretically support most Unicode characters. However, due to encoding support issues in After Effects, the name data in presets might display unsupported characters as ? (question marks) on different system regions (this is not a glitch). If you are an individual artist, you can name parameters in any language. If you are part of a team, especially one involved in international art exchanges, we recommend using parameter names composed of visible characters from ASCII (generally consisting of English letters, numbers, and underscores). "},"contents/Editor/SavePresets.html":{"url":"contents/Editor/SavePresets.html","title":"Preset management","keywords":"","body":"Preset Management Saving Presets In the World Law Editor, you can save a preset by clicking the Save as preset button and entering a name. Note: If you use a preset name that already exists in the list, it will be overwritten. Overwriting Presets In the World Law Editor, you can overwrite an existing preset by clicking the Save as preset button and entering the name of a preset that already exists in the list. Note: This action is irreversible, please make sure to back up. Preset names in different preset categories do not interfere with each other. Renaming Presets Double-click on the preset in the list that you want to rename, and enter a name other than REMOVE or SORT in the input field. Sorting the Preset List Double-click on any preset in the list and enter SORT in the input field. Deleting Presets Double-click the preset you wish to delete in the list and enter REMOVE in the input field. Adding Preset Categories Click the Add button next to the drop-down list in the Preset list panel to add a new preset category. Note: You cannot use an existing category name for a new category. Adding a category is equivalent to creating a preset file alongside the plugin. If creation fails or the preset file disappears the second time you open After Effects, please enable administrator mode for After Effects to allow Pixel World to read/write on your disk. Preset Format/Preset File Presets are stored in JSON format with UTF-8 (little-endian) encoding. Preset files are stored in plain text; we do not encrypt presets in any way. Preset files can be modified using third-party JSON editing tools, but there is a risk of damaging the preset structure, which is not recommended. Preset Submission If you are willing to publicly share your presets through official channels, you are welcome to submit your presets to the email: ZzStarSound@gmail.com. We will periodically compile received presets and publicly list submitters' names in the plugin's About section. "},"contents/Lua/LuaCode.html":{"url":"contents/Lua/LuaCode.html","title":"World Center Lua","keywords":"","body":"The Center of the World: Lua In Chapter 1, we introduced a language called Lua * Lua is a lightweight, high-level, multi-paradigm programming language, mainly used for embedded applications. ——Wiki) Version: Lua5.3 (Click to view the complete technical documentation in Chinese) Note: From PixelsWorld v3.2.0, Lua5.4 is used. Lua is a language very similar to expressions and Ae scripts, and it is the center of PixelsWorld, connecting all modules. Basically, you just have to remember a few English words for operations, and PixelsWorld will systematically render graphics for you. All rendering commands in PixelsWorld can be issued through this central hub, Lua. For example, if you want to draw a cube that can interact with Ae's camera, you just need to input: DrawCube.lua version3() move(width/2,height/2) dim3() cube(300) dim3() is a function used for drawing in 3D mode. If you want to render GLSL code, you only need to input: RunGlsl.lua version3() glsl([==[ void main(){ vec3 col = 0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4)); outColor = vec4(col,1.0); } ]==]) And input the GLSL code in between; If you want to execute shadertoy code, you just need to input: RunShadertoy.lua version3() shadertoy([==[ void mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec2 uv = fragCoord/iResolution.xy; vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)); fragColor = vec4(col,1.0); } ]==]) And input the code from shadertoy in between. Here we list the capabilities of Lua: Access pixel data Write pixel data Execute JavaScript Execute GLSL Access parameter data Execute external C language libraries Load Lua modules Additionally, Lua is very similar to JavaScript. Since JavaScript is an easy-to-learn language, you will be able to master it quickly even if you have no programming background. PixelsWorld Structure "},"contents/Lua/RunLua.html":{"url":"contents/Lua/RunLua.html","title":"Run Lua","keywords":"","body":"Running Lua Code Switch the language to Lua (CPU & GPU) Import the code: hello.lua version3() a = 5+6 b = \"PixelsWorld\" c = \"is cool!\" d = time e = slider(0) f = \"5 + 6 = \" .. a .. \"\\nMessage : \" .. b .. \" \" .. c .. \"\\nCurrent time is : \" .. d .. \" (s)\\nValue of slider0 is : \" .. e print(f) a..b concatenates variables a and b into a string. print() renders the information on the screen. slider() retrieves the value of the specified parameter. You can add ; at the end of each line, although it's not necessary. Lua considers \\n (newline character) as the end marker of a block of code. Eventually, you will see the output information displayed at the top left corner of the screen. "},"contents/Lua/WriteLocalCode.html":{"url":"contents/Lua/WriteLocalCode.html","title":"Load local code","keywords":"","body":"Writing Code Locally If you prefer not to use the built-in editor of Pixel World, you can create a txt document locally and import it into Pixel World using the following code. Do not place the code file on the system drive (C:\\ drive). loadTxt.lua version3() runFile([[d:\\mycode.txt]]) -- Replace with your path The reason for using [[d:\\mycode.txt]] instead of \"d:\\mycode.txt\" is that the latter will cause the \\ to be escaped. You can use any file extension (*.lua, *.code, *.magic) as long as the file content is text. If you want to place the code next to the project files, you can use the following code. loadTxt.lua version3() runFile(projectFolder .. [[mycode.txt]]) -- Replace with your file name Note that using projectFolder requires your project to be saved locally. It's Not Over! Don't Forget to Refresh the Code After typing and saving your code locally, Pixel World will not immediately respond in the scene. You need to press Ctrl + Alt and click on the LOGO image on the plugin panel with your mouse. Pixel World will then read the new code you've written. The LOGO image here rotates randomly according to a certain probability distribution. To cater to artists who enjoy collecting, we have designed many exquisite LOGOs to display here. "},"contents/Lua/LinkParameters.html":{"url":"contents/Lua/LinkParameters.html","title":"Link parameters","keywords":"","body":"Link Parameters Use the following functions to call parameters on the plugin panel. parameters.lua slider(id) -- Returns 1 double angle(id) -- Returns 1 double point(id) -- Returns 2 doubles point3d(id) -- Returns 3 doubles checkbox(id) -- Returns 1 boolean color(id) -- Returns 3 doubles layer(id, x, y) -- Returns 4 doubles When multiple variables are returned, you need to declare multiple variables to catch the return values, for example with the point() function. point.lua version3() x, y = point(0) println('x is ' .. x) println('y is ' .. y) "},"contents/Lua/globals.html":{"url":"contents/Lua/globals.html","title":"Globals","keywords":"","body":"Global Variables Global Constants PixelsWorld provides the following global constants for users to utilize: const.lua PI -- The value of pi TPI -- Two times pi HPI -- Half of pi QPI -- Quarter of pi E -- The natural number e PHI -- The golden ratio phi R2 -- Square root of 2 R3 -- Square root of 3 R5 -- Square root of 5 R7 -- Square root of 7 INPUT -- Input texture index -1 TEMP -- Cache texture index -2 OUTPUT -- Output texture index -3 PARAM0 -- Texture of layer 0 PARAM1 -- Texture of layer 1 PARAM2 -- Texture of layer 2 PARAM3 -- Texture of layer 3 PARAM4 -- Texture of layer 4 PARAM5 -- Texture of layer 5 PARAM6 -- Texture of layer 6 PARAM7 -- Texture of layer 7 PARAM8 -- Texture of layer 8 PARAM9 -- Texture of layer 9 platform -- Platform: Windows10: 0, no other platforms currently supported host -- Host application: Ae: 0, no other hosts currently supported Global Variables PixelsWorld provides the following variables derived from Ae for users to utilize: [cached] indicates a global variable that does not trigger a re-render unless memory is cleared. globalvars.lua depth -- Color depth, can be 8, 16, 32 width -- Width of the input layer height -- Height of the input layer time -- Current time (in seconds) duration -- Duration of the current layer (in seconds) [cached] inpoint -- In point time of the current layer (in seconds) [cached] compTime -- Composition time (in seconds) pluginFolder -- Plugin directory (UTF-8) projectName -- Project name (UTF-8) projectPath -- Project path (UTF-8) projectFolder -- Path to the project folder (UTF-8) ds_width -- Downsampled composition width ds_height -- Downsampled composition height origin_x -- X-coordinate of the top-left corner of the input layer in the layer coordinate system origin_y -- Y-coordinate of the top-left corner of the input layer in the layer coordinate system layerName -- Name of the current layer; if not set, it is empty (v3.6.4+) [cached] layerSourceName -- Source name of the current layer; usually not empty (v3.6.4+) [cached] compName -- Current composition name (v3.6.4+) [cached] fps -- Frames per second Printing Global Variables Run the following code in Lua mode to print global variables (including global functions): printGlobals.lua version3() in2out() for k, v in pairs(_G) do print(k) print(\" \" .. type(v), .5, .5, .5) print(\" \".. tostring(_G[k]), 0, 1, 1) println(\"\") end "},"contents/Lua/FuncList.html":{"url":"contents/Lua/FuncList.html","title":"Function list","keywords":"","body":"Function List Below is a list of functions defined in Lua mode for PixelsWorld. Mandatory Declaration Function version3 Parameter Retrieval Functions slider, angle, point, point3d, checkbox, color, layer Output Information Functions print, println, alert Transformation Functions move, scale, rotate, rotateX, rotateY, rotateZ, twirl beginGroup, endGroup, beginGlobal, endGlobal global2local, local2global, global2screen, screen2global getTransformMatrix Drawing Functions Primitives tri, quad, rect, circle, ellipse, par, line cube, tet, cone, ball, tube image, imageAlign, imageAnchor text, textSize, textFont, textAlign, textAnchor, textAlignOuter, textInterval, textAdvanceScale coord, grid poly, setPoly background, in2out Drawing Attribute Controls dim2, dim3 perspective, noPerspective fill, noFill, stroke, noStroke, dot, noDot wireframe, noWireframe blendAlpha, noBlendAlpha back, noBack pure, phong, anime rgba, depth, normal setDepth Lighting newLight, delLight, getLightInfo activateLight, deactivateLight, getActivatedLight, setActivatedLight fetchLight ambientLight (legacy), pointLight (legacy), parallelLight (legacy) clearLight (legacy), getLight (legacy) Camera aeCamera, lookAt, viewSpace Stroked Detail strokeWidth, strokeDivision, strokeGlobal, strokeLocal Dot Rendering Detail dotRadius, dotDivision, dotGlobal, dotLocal Output Detail smooth, noSmooth Texture Manipulation newTex, delTex, getSize, swapTex, drawTo, castTex, blendTex, copyTex, savePNG, loadPNG, saveEXR, loadEXR, rotateTex, flipTex, resizeTex, trimTex Utilities r2d, d2r map clamp step smoothStep bezier rgb2hsl,hsl2rgb,rgb2hsv,hsv2rgb,rgb2cmy,cmy2rgb,rgb2cmyk,cmyk2rgb,cmy2cmyk,cmyk2cmy,hsl2hsv,hsv2hsl utf8ToLocal, localToUtf8 getGLInfo, getDrawRecord, getStatus getAudio loadString saveString Pixel Reading and Writing Functions getColor, setColor, getSize, Code Execution Functions shadertoy, glsl, cmd, lua, runFile, txt Detailed Explanation version3 The function version3() must be declared in the first line in Lua mode. Its purpose is to import all functions under the pw3 table into the global scope. If this line is missing, you need to prefix all functions provided by PixelsWorld with pw3., such as the println() function, which would need to be written as pw3.println(). Conversely, if you call the version3() function at the beginning of your code, you do not need the pw3. prefix. This design is intended to ensure backward compatibility with your code. We recommend that you include a call to version3() in the first line of any Lua rendering mode code in all circumstances. version3.lua version3() println(\"Hello PixelsWorld! \") without_version3.lua pw3.println(\"Hello PixelsWorld! \") print print(str), print(str,brightness), print(str,r,g,b), print(str,r,g,b,a) are functions to output information on the top left corner of the screen. print.lua version3() print(\"Hello PixelsWorld! \") str = \"Hello, I am colorful PixelsWorld! \" for i=1,#str do local c = str:sub(i,i) local phase = math.sin(i/#str*TPI + time*10) / 2 + .5 print(c,phase,1-phase,1,1) end println println(str), println(str, brightness), println(str, r, g, b), println(str, r, g, b, a) are functions for outputting information in the top left corner of the screen, with each output followed by a newline. println.lua version3() println(\"Hello PixelsWorld! \") str = \"Hello, I am colorful PixelsWorld! \" for i=1,#str do local c = str:sub(i,i) local phase = math.sin(i/#str*TPI + time*10) / 2 + .5 -- println(c,phase,1-phase,1,1) print(c,phase,1-phase,1,1) end alert alert(str) is a function to output warning messages in the top left corner of the screen. It is currently equivalent to println(str, 1, 1, 0, 1). alert.lua version3() alert(\"Warning: Write your message here! \") move move(x,y),move(x,y,z)moves Paintbrush. All transformations are performed based on the current Paintbrush coordinates. Example: move.md version3() coord() -- Display Paintbrush position before transformation move(100,0) coord() -- Display Paintbrush position after 1st transformation move(0,100) coord() -- Display Paintbrush position after 2nd transformation Eventually, the Paintbrush will be at position (100, 100, 0). scale scale(ratio),scale(x,y),scale(x,y,z)scales the Paintbrush coordinate. All transforms are done basing on the Paintbrush coordinate. scale.lua version3() move(100,100) scale(2) rect(50,25) no_scale.lua version3() move(100,100) --scale(2) rect(50,25) rotate rotateX rotateY rotateZ rotate(theta) is a function to rotate the Paintbrush coordinates by theta radians, rotateX(theta) rotates the Paintbrush coordinates along its X-axis, and rotate(theta) is essentially equivalent to rotateZ(theta). All transformations are performed based on the current Paintbrush coordinates. If you are unfamiliar with radians, you can use the function d2r(degree) to convert degrees into radians. For example: rotate(d2r(90)) rotates by ninety degrees. rotate_degree.lua version3() move(100, 100) rotate(d2r(45)) rect(50, 25) rotate_radian.lua version3() move(100, 100) rotate(PI/4) rect(50, 25) rotateX.lua version3() dim3() move(100, 100) grid() coord() rotateX(d2r(45)) cube(50, 25, 10) rotateY.lua version3() dim3() move(100, 100) grid() coord() rotateY(d2r(45)) cube(50, 25, 10) rotateZ.lua version3() dim3() move(100, 100) grid() coord() rotateZ(d2r(45)) cube(50, 25, 10) twirl twirl(theta, x, y, z) is a function to rotate the Paintbrush coordinate along the (x, y, z) axis by theta radians. For instance, the above rotateX(theta) is equivalent to twirl(theta, 1, 0, 0). All transformations are performed based on the current PaintBrush coordinates. twirl uses a matrix implementation for quaternion rotation. twirl.lua version3() dim3() move(100, 100) grid() coord() stroke(1, 1, 0) line(-50, -50, -50, 50, 50, 50) stroke(0, 0, 0) twirl(d2r(90), 1, 1, 1) cube(50, 25, 10) beginGroup endGroup beginGroup(), endGroup() are functions to create parent-child relationships. Transformations (move, scale, rotate, twirl) between beginGroup() and endGroup() are undone after endGroup(). beginGroup(mat) creates a parent-child relationship and pushes a 4x4 matrix mat into the scene (you can use getTransformMatrix to obtain transformation matrix). It is equivalent to pushMatrix() and popMatrix() in Processing. For example, the following two code blocks are equivalent: group.lua version3() for i = 1, 6 do beginGroup() move(i * 25, i * 25) rotate(d2r(15 * i)) rect(25) endGroup() end without_group.lua version3() for i = 1, 6 do move(i * 25, i * 25) rotate(d2r(15 * i)) rect(25) rotate(d2r(-15 * i)) move(-i * 25, -i * 25) end beginGlobal endGlobal Drawing functions enclosed in beginGlobal, endGlobal will temporarily draw in the global coordinate system. beginGlobal.lua version3() move(100, 100) fill(0, 1, 0) -- green rect(50) -- Draw on (100, 100, 0) beginGlobal() fill(1, 0, 0) -- red rect(50) -- Draw on (0, 0, 0) endGlobal() move(100, 100) fill(0, 0, 1) -- blue rect(50) -- Draw on (200, 200, 0) global2local global2local(x, y, z) converts global coordinates to local coordinates and returns three double values. global2local.lua version3() move(100, 100) rect(25) move(0, 50) rotate(d2r(30)) coord() x, y, z = global2local(100, 100, 0) println(\"The local coordinate of the rectangle is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") local2global local2global(x, y, z) converts local coordinates to global coordinates and returns three doubles. local2global.lua version3() move(100, 100) move(0, 50) rotate(d2r(30)) coord() move(25, 50) rect(25) x, y, z = local2global(0, 0, 0) println(\"The global coordinate of the rectangle is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") global2screen global2screen(x, y, z) converts global coordinates to screen coordinates and returns three doubles. This conversion is affected by perspective mode. global2screen.lua version3() dim3() move(100, 100, 0) move(0, 50, 0) rotateZ(d2r(30)) coord() move(25, 50, 0) cube(25) x, y, z = global2screen(local2global(0, 0, 0)) println(\"The screen coordinate of the rectangle is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") screen2global screen2global(x, y, z) converts screen coordinates to global coordinates and returns three doubles. This conversion is affected by perspective mode. screen2global.lua version3() dim3() x, y, z = screen2global(0, 0, 0) println(\"The global coordinate of the camera is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") getTransformMatrix getTransformMatrix() returns a column-major 4x4 transformation matrix. This transformation matrix can be applied in beginGroup(mat). mat[i][j] can access the element at column i, row j. (i, j range 1~4) Example: matrix.lua version3() dim3() beginGroup() move(width/3, height/3) twirl(d2r(30), 1, 1, 1) cubetransform = getTransformMatrix() endGroup() beginGroup(cubetransform) cube(50) endGroup() tri tri(radius) creates an equilateral triangle inscribed in a circle with radius radius and points in the positive y-direction of the Paintbrush coordinate. tri() is equivalent to tri(100) tri(w, h) creates an isosceles triangle with base w and height h. tri(p1x, p1y, p2x, p2y, p3x, p3y) creates a triangle with vertices at the 2D points p1, p2, p3. tri(p1x, p1y, p1z, p2x, p2y, p2z, p3x, p3y, p3z) creates a triangle with vertices at the 3D points p1, p2, p3. To observe a 3D triangle, please add dim3() after the version3() function and set up a camera view in the Ae layer. Triangles constructed by the first three methods have normals by default in the negative direction of the z-axis of the Paintbrush coordinate, while the triangles from the last two are geometrically normal by cross(p1-p2, p3-p2). The function name is a shorthand for triangle. tri1.lua version3() move(width/2, height/2) tri(100) tri5.lua version3() dim3() move(width/2, height/2) tri(0, 0, 100, 50, 0, 0, 0, 50, 0) quad quad(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) quad(p1x, p1y, p1z, p2x, p2y, p2z, p3x, p3y, p3z, p4x, p4y, p4z) Draw the first triangle in the order of p1, p2, p3, and the second triangle in the order of p1, p3, p4. quad.lua version3() move(200, 100) quad(0, 0, 75, 0, 50, 40, 0, 15) rect rect(size) draws a square with the given size. rect() is equivalent to rect(100) rect(width, height) draws a rectangle with the specified width and height. The rectangle is generated with its center as the intersection point of the diagonal in the Paintbrush coordinate system. The function name is a shorthand for rectangle. rect.lua version3() move(200, 100) rect(100, 75) circle circle(radius) draws a circle with a radius of radius. circle() is equivalent to circle(100) circle(radius, div) draws a circle with a radius of radius and div segments. The default number of segments is 128. circle.lua version3() move(100, 100) fill(1, 0, 0) circle(25) move(100, 0) fill(0, 1, 0) circle(25, 10) move(100, 0) fill(0, 0, 1) circle(25, 3) ellipse ellipse(radiusx, radiusy) draws an ellipse with an x-radius of radiusx and a y-radius of radiusy. ellipse() is equivalent to ellipse(100, 100) ellipse(radiusx, radiusy, div) draws an ellipse with an x-radius of radiusx, a y-radius of radiusy, and div segments. The default number of segments is 128. ellipse.lua version3() move(100, 100) fill(1, 0, 0) ellipse(25, 15) move(100, 0) fill(0, 1, 0) ellipse(25, 15, 10) move(100, 0) fill(0, 0, 1) ellipse(25, 15, 4) line line(p1x, p1y, p2x, p2y) draws a line segment. line(p1x, p1y, p1z, p2x, p2y, p2z) draws a 3D line segment. line() is equivalent to line(0, 0, 0, 100, 100, 100) The color of the line is controlled by stroke(r, g, b). The thickness of the line is controlled by strokeWidth(width). Lines are rendered by default; to disable line rendering, use noStroke(), and to enable it, use stroke(). line.lua version3() move(200, 100, 0) stroke(1, 0, 0) line(0, 0, 0, 50) move(100, 0, 0) stroke(0, 1, 0) line(0, 0, 0, 50) move(100, 0, 0) stroke(0, 0, 1) line(0, 0, 0, 50) line_circle.lua version3() math.randomseed(1) num = 32 move(width/2, height/2) for i=1, num do beginGroup() rotateZ(d2r(360/num*i)) strokeWidth(math.random()*3) line(0, 0, 100, 0) endGroup() end par par(x) draws a point at position (x,0,0). par(x, y) draws a point at position (x, y, 0). par(x, y, z) draws a point at position (x, y, z). par() is equivalent to par(0,0,0). Point rendering is off by default; use dot() to enable it. You can disable it at any time with noDot(). The radius of the point is controlled by dotRadius(radius). The color of the point is controlled by dot(r, g, b). If you do not want the point to be distorted or shrunk, use dotGlobal(). By default, points are rendered in dotLocal() mode. par.lua version3() dot() dotRadius(3) move(200, 100) par() dot(1, 0, 0) dotRadius(7) move(100, 0) par() cube cube(size) draws a cube with a side length of size. cube(sizex, sizey, sizez) draws a cuboid with dimensions sizex, sizey, sizez. cube() is equivalent to cube(100). The normals of the cuboid are outward by default. Negative lengths or the use of scale() with a negative sign may result in inward normals. cube.lua version3() dim3() move(200, 100, 0) rotateY(d2r(30)) rotateX(d2r(30)) cube(40, 25, 10) tet tet(radius) draws an inscribed regular tetrahedron with a spherical radius of radius. tet() is equivalent to tet(50). tet(p1x, p1y, p1z, p2x, p2y, p2z, p3x, p3y, p3z, p4x, p4y, p4z) draws a tetrahedron with vertices at p1, p2, p3, p4. The normals of tetrahedra drawn using the third method are determined by the drawing order: vertices are drawn in the order p1, p2, p3; p2, p1, p4; p3, p2, p4; p1, p3, p4. Please refer to the tri section for triangle normal directions. The function name is a shorthand for tetrahedron. tet.lua version3() dim3() move(200, 100, 0) tet(0, 0, 0, 100, 0, 0, 0, 100, 0, 30, 20, -50 ) cone cone(size) draws a cone with a base radius of size and height 2*size. cone() is equivalent to cone(50). cone(radius, height) draws a cone with a radius of radius and height of height. cone(radius, height, div) draws a cone with a radius of radius, height of height, and segmented into div sections. The default number of segments is 64. When the number of segments is greater than 16, the cone face outlines and base vertices will be hidden. Negative input values or the use of scale() with a negative sign may result in inward normals. cone.lua version3() dim3() move(100, 100, 0) beginGroup() rotateY(d2r(60)) cone(25) endGroup() move(100, 0, 0) beginGroup() rotateY(d2r(60)) noStroke() cone(25) endGroup() move(100, 0, 0) beginGroup() rotateY(d2r(60)) stroke(1, 0, 0) dot(1, 1, 0) dotRadius(3) cone(30, 100, 12) endGroup() ball ball(radius) draws a 3D sphere with a radius of radius. ball() is equivalent to ball(50). ball(radius, level) draws a sphere with a radius of radius and subdivision level of level. The default level is 4. Level must be greater than or equal to 0. A level of 0 results in an octahedron. When the level is greater than 2, outlines and vertices will be hidden. Negative input values or the use of scale() with a negative sign may result in inward normals. ball.lua version3() dim3() move(200, 100, 0) beginGroup() rotateY(d2r(60)) ball(25) endGroup() move(100, 0, 0) beginGroup() rotateY(d2r(60)) stroke(0, 0.25, 0.5) dot(0, 0.5, 1) dotRadius(3) ball(30, 2) endGroup() tube tube(size) draws a cylinder with a base radius of size and height 2*size. tube() is equivalent to tube(50). tube(radius, height) draws a cylinder with a radius of radius and height of height. tube(radius1, radius2, height) draws a cylinder with a base radius of radius1 near the Paintbrush coordinate origin, a base radius of radius2 on the far side, and height of height. tube(radius1, radius2, height, div) adds segment control to the fourth function. tube(radius1, radius2, height, div, needMesh) adds a boolean to control whether to render the two circular faces based on the fifth function. tube(radius1, radius2, height, div, needMesh1, needMesh2) adds booleans needMesh1 to control rendering of the near side base and needMesh2 for the far side base based on the fifth function. div defaults to 64. needMesh defaults to true. When the number of segments is more than 16, the cylinder's side outlines and vertices on both bases will be hidden. Negative input values or the use of scale() with a negative sign may result in inward normals. tube.lua version3() dim3() move(200, 100, 0) beginGroup() rotateY(d2r(60)) tube(25) endGroup() move(100, 0, 0) beginGroup() rotateY(d2r(60)) stroke(1, 0.25, 0.5) dot(0, 0, 1) dotRadius(3) tube(30, 25, 50, 8) endGroup() image image(id, width, height) draws an image of specified width and height onto the scene. id is the texture identifier, PARAM0 to PARAM9 are textures obtained from the plugin panel's layer controls, INPUT is the input image to the plugin, and OUTPUT is the output image. Specifying OUTPUT as id triggers a screen capture action of the current drawing since OUTPUT is the texture used as your drawing board, making it slightly slower than other parameters. The difference between this function and in2out(id) is that image(id, width, height) interacts with the scene's depth information based on the Paintbrush coordinates. This means the image is rendered upside down by default, as Ae's coordinate system has a downward y-axis; you should add a rotateX(PI) before to correct this (using scale(1, -1) is not recommended, as it could cause incorrect normals in subsequent shapes). In contrast, in2out(id) ignores depth information and writes pixels directly onto the current drawing board (without the upside-down issue). The example below demonstrates a cube interacting with the input image. render_image.lua version3() dim3() move(width/2, height/2) twirl(d2r(45), -1, 1, 0) beginGroup() rotateX(d2r(180)) image(INPUT, width, height) endGroup() twirl(d2r(60), 1, 1, 1) cube() imageAlign New in v3.3.0. Use imageAlign(rule) to change the orientation of the image in the image function. rule follows these rules: rule is a string of length 4. The 1st character is + or -. The 2nd character is one of x, y, z. The 3rd character is + or -. The 4th character is one of x, y, z. rule specifies how the UV coordinates of an image (origin at the lower left corner) align with the axes of the Paintbrush coordinate system. The default rule is \"+x+y\", meaning the u-axis aligns with positive x and the v-axis with positive y. imageAlign.lua version3() dim3() move(100, 100, 0) coord() image(PARAM0, 128, 128) move(150, 0, 0) coord() imageAlign(\"+x-y\") image(PARAM0, 128, 128) move(150, 0, 0) coord() imageAlign(\"+z-y\") image(PARAM0, 128, 128) imageAnchor New in v3.5.0. imageAnchor(u, v) specifies the position of the image anchor point. imageAnchor(a) is a shorthand for imageAnchor(a, a). text New in v3.5.0 text(str) is used to render text on the screen. text.lua version3() move(width/2, height/2) textAlign(\"+x-y\") text(\"Hello PixelsWorld!\") You can also use the following functions to change the text style: Text fill color: fill(r,g,b) Text stroke color: stroke(r,g,b) Disable fill: noFill() Disable stroke: noStroke() Stroke thickness: strokeWidth(width) Font: textFont(fontFileName) Font size: textSize(size) Letter spacing: textInterval(dx,dy) Text width proportional scaling: textAdvanceScale(rx,ry) textSize New in v3.5.0 textSize(size, resolution) sets the size and resolution for the text to be drawn. size controls the text size, and resolution controls the text resolution. textSize(size) is equivalent to textSize(size, size) textSize.lua version3() textAlign(\"+x-y\") textAnchor(0, 1) for i = 1, 13 do local sz = i + 8 textSize(sz) text(\"~MiLai visual performance group~\") move(0, sz + 4) end textFont New in v3.5.0 textFont(fontFileName) sets the font for the text to be drawn. fontFileName is the file name of the font within the C:\\Windows\\Fonts folder (you can see the file name by checking the properties through right-click). You can also enter the full path of the font file. This means you can access fonts from any location (e.g., textFont([[D:\\MyFolder\\arial.ttf]])). textFont.lua version3() textAlign(\"+x-y\") textAnchor(0, 1) textSize(20) font_list = { {\"arial.ttf\", \"The quick brown fox jumps over the lazy dog.\"}, {\"MATURASC.TTF\", \"The quick brown fox jumps over the lazy dog.\"}, {\"KUNSTLER.TTF\", \"The quick brown fox jumps over the lazy dog.\"}, {\"msmincho.ttc\", \"色は匂へど　散りぬるを\"}, {\"UDDigiKyokashoN-R.ttc\", \"我が世誰ぞ　常ならむ\"}, {\"STXINGKA.TTF\", \"人生得意须尽欢 莫使金樽空对月\"}, {\"msjh.ttc\", \"山氣日夕佳 飛鳥相與還\"}, {\"simsun.ttc\", \"吥葽 莣記莪、伱知道 莪 拿起伱 就 倣吥丅。\"}, {\"STZHONGS.TTF\", \"○●対沵倾注ㄋ珴所侑旳温柔︶ㄣ\"}, } for i = 1, #font_list do textFont(font_list[i][1]) text(font_list[i][2]) move(0, 28) end textAlign New in v3.5.0 textAlign(rule) is used to set the rendering orientation of the font. rule is the same as in imageAlign(rule). See imageAlign details >>> textAnchor New in v3.5.0 textAnchor(x, y) is used to set the anchor point position of the font. See imageAnchor details >>> textAlignOuter New in v3.5.0 textAlignOuter(flag) sets whether to align the text using the outer outline. flag is a boolean value. textInterval New in v3.5.0 textInterval(x, y) sets the spacing for text mapping. Default is x:0, y:0. textAdvanceScale New in v3.5.0 textAdvanceScale(rx, ry) controls the advancement scaling of text mapping. Default is rx:1, ry:1. coord coord() visualizes the current Paintbrush coordinates. coord.lua version3() move(100, 100) coord() move(150, 0) coord() rotate(d2r(30)) move(50, 0) scale(2, 1) coord() grid grid() visualizes a grid on the xy plane at the current Paintbrush coordinates with a grid size of 100x100. grid.lua version3() move(width/2, height/2) rotate(d2r(30)) grid() setPoly setPoly(obj) can pre-parse the object information to be drawn. After setting, you can call poly() to quickly render the object that was just set. When you draw the same object multiple times in a scene, using this function to set the object in advance will be efficient. For information on constructing obj, please refer to the Poly section. background background(brightness), background(r,g,b), background(r,g,b,a) fills the current canvas with the specified color. Note: If you have previously drawn shapes, they will be covered. background.lua version3() background(1, 1, 0) in2out in2out(id) sets the specified layer parameter as the background. in2out() is equivalent to in2out(INPUT), which uses the input layer as the background. id range: PARAM0~PARAM9 or INPUT. dim2 dim2() uses 2D drawing mode. This is enabled by default, so you generally do not need to call it. Essentially, 2D mode in PixelsWorld is an orthographic 3D mode without depth information. dim3 dim3() switches to 3D drawing mode. We recommend declaring it right after version3(). Note: When rendering 3D shapes on a layer different from the composition size, use viewSpace to change the camera's far plane size to avoid unexpected positioning results. perspective perspective() renders using a perspective view, where objects follow the rule of being larger when closer and smaller when farther. You can use viewSpace to adjust camera information and lookAt to adjust the camera position. If you have called dim3(), the perspective mode is enabled by default. noPerspective noPerspective() renders using an orthographic view, where parallel edges of objects remain parallel in the rendered view. noPerspective.lua version3() dim3() n = 20 move(100, 100, 0) beginGroup() rotateX(d2r(85)) for i = 1, n do move(0, 300, 0) fill(i/n, 1-i/n, 1) cube(50) end endGroup() move(300, 0, 0) noPerspective() beginGroup() rotateX(d2r(85)) for i = 1, n do move(0, 300, 0) fill(i/n, 1-i/n, 1) cube(50) end endGroup() fill fill() enables fill, which is enabled by default. fill(brightness), fill(r, g, b), fill(r, g, b, a) enables fill and sets the fill color. Note: In 3D mode, if you set the fill transparency to a value less than 1, render objects from farthest to nearest. Otherwise, objects in front may completely obscure those behind them. (This is a characteristic of OpenGL rendering.)noFill noFill() disables the fill. fill.lua version3() move(200, 100, 0) fill(1, 0, 0) rect(50) move(100, 0, 0) fill(1, 1, 0) rect(50) move(100, 0, 0) noFill() rect(50) stroke stroke() enables stroke. It is enabled by default. stroke(brightness), stroke(r, g, b), stroke(r, g, b, a) enables stroke and sets the stroke color. noStroke noStroke() disables the stroke. stroke.lua version3() fill(0) move(200, 100, 0) stroke(1, 0, 0) rect(50) move(100, 0, 0) stroke(1, 1, 0) rect(50) move(100, 0, 0) noStroke() rect(50) dot dot() enables vertex rendering, which is disabled by default. dot(brightness), dot(r, g, b), dot(r, g, b, a) enables vertex rendering and sets the vertex rendering color. noDot noDot() disables vertex rendering. dot.lua version3() fill(1) move(200, 100, 0) stroke(1, 0, 0) rect(50) move(100, 0, 0) dot(1, 1, 0) rect(50) move(100, 0, 0) noDot() rect(50) wireframe wireframe() enables wireframe mode. noWireframe noWireframe() disables wireframe mode. wireframe.lua version3() n = 8 dim3() move(width/2, height/2) for i = 1, n do if i > n // 2 then wireframe() else noWireframe() end beginGroup() rotateZ(d2r(i * 360 / n)) move(100, 0, 0) fill(i/n, 1-i/n, 1) ball(30, 1) endGroup() end blendAlpha blendAlpha() enables blending mode. noBlendAlpha noBlendAlpha() disables blending mode. blendAlpha.lua version3() castTex(OUTPUT, INPUT) move(200, 100, 0) fill(1, 0, 0, 0.2) rect(80) move(100, 0, 0) noBlendAlpha() fill(1, 0, 0, 0.2) rect(80) back When filled with a transparent color, back() displays the backside of the object. Disabled by default. noBack noBack() disables backface rendering mode. back.lua version3() dim3() fill(1, 0, 0, 0.2) rotateX(d2r(30)) rotateY(d2r(-15)) move(200, 180, 0) cube(80) move(150, 0, 0) back() cube(80) pure pure() uses pure color mode to render the scene. Enabled by default. anime, phong, and pure are three materials that cannot be applied simultaneously. Enabling one will disable the others. phong phong(ambient, diffuse, specular, specularPower) switches to phong mode and sets the ambient reflection intensity to ambient, diffuse reflection intensity to diffuse, and specular intensity to specular. specularPower determines the specular attenuation level; the larger it is, the faster the specular attenuates. phong() switches to phong material mode without changing settings. The default scene has no light sources, so you need to use functions like getLight(), ambientLight(), parallelLight(), or pointLight to get light sources. If the rendered object is still pure black under the premise of having light sources, check if normals are correct by calling normal. Each parameter's initial value: ambient: 1, diffuse: 1, specular: 1, specularPower: 1. anime, phong, and pure are three materials that cannot be applied simultaneously. Enabling one will disable the others. Execute dim3() before using. phong.lua version3() dim3() move(width/2, height/2, 0) grid() coord() n = 10 beginGroup() move(0, 0, -100) pointLight() endGroup() for i = 1, n do beginGroup() rotateZ(d2r(i * 360 / n)) move(100, 0, 0) fill(i/n, 1-i/n, 1) if(i anime anime(ambient, diffuse, specular, specularPower, diffuseThreshold, specularThreshold). anime() switches to anime material mode without changing settings. Anime material is developed based on phong. Therefore, the first four parameters — ambient, diffuse, specular, and specularPower — are the same as in phong. The remaining two parameters, diffuseThreshold and specularThreshold, set the thresholds for diffuse and specular reflection. When diffuse reflection brightness exceeds the threshold, it is set as a highlight; if it is below, it is set as a shadow. Similarly, specularThreshold sets the threshold for highlights. Anime material has anti-aliasing optimization; if you have anti-aliasing enabled (enabled by default), the light and shadow transition edges will be anti-aliased. Disabling anti-aliasing settings in the plugin panel can turn off edge anti-aliasing. Initial value for each parameter: ambient:1, diffuse:1, specular:1, specularPower:1, diffuseThreshold:0.5, specularThreshold:0.8. Anime, phong, and pure are three materials that cannot be applied simultaneously. Enabling one will disable the others. Execute dim3() before using. anime.lua version3() dim3() move(width/2, height/2, 0) grid() coord() n = 10 beginGroup() move(0, 0, -100) pointLight() endGroup() for i = 1, n do beginGroup() rotateZ(d2r(i * 360 / n)) move(100, 0, 0) fill(i/n, 1-i/n, 1) if(i rgba rgba() is the mode for direct RGBA output, enabled by default. rgba, depth, and normal are three modes that cannot be active simultaneously; turning on one will turn off the other two. Materials can be used in this mode. rgba.lua version3() dim3() background(1) move(width/2, height/2, 0) n = 10 beginGroup() move(0, 0, -100) pointLight() endGroup() rgba() -- depth() -- normal() noStroke() for x = 1, n do for y = 1, n do for z = 1, n do beginGroup() fill(x/n, y/n, z/n) move(map(x, 1, n, -n/2, n/2) * 50, map(y, 1, n, -n/2, n/2) * 50, map(z, 1, n, -n/2, n/2) * 200) ball(10, 2) endGroup() end end end depth depth(blackDistance, whiteDistance) is a mode that outputs depth as brightness information. For example, to output a depth map, you can specify blackDistance and whiteDistance to set the distance from the camera at which black or white is rendered. A linear interpolation of gray will be done for distances in between. If you set blackDistance and whiteDistance to the same value, the specified value will be used as a threshold to output pure black or pure white. rgba, depth, and normal are three modes that cannot be active simultaneously; turning on one will turn off the others. This mode ignores materials. Execute dim3() before using. depth.lua version3() dim3() background(1) move(width/2, height/2, 0) n = 10 beginGroup() move(0, 0, -100) pointLight() endGroup() -- rgba() depth() -- normal() noStroke() for x = 1, n do for y = 1, n do for z = 1, n do beginGroup() fill(x/n, y/n, z/n) move(map(x, 1, n, -n/2, n/2) * 50, map(y, 1, n, -n/2, n/2) * 50, map(z, 1, n, -n/2, n/2) * 200) ball(10, 2) endGroup() end end end normal normal(faceToCamera, normalize) switches to normal mode and modifies faceToCamera and normalize variables. normal(faceToCamera) switches to normal mode and only modifies the faceToCamera variable. normal() simply switches to normal mode. faceToCamera is a boolean value that controls whether normals are generated from the camera's perspective. normalize is a boolean value that specifies whether to output normalized normals (length 1). Initial values: faceToCamera: true, normalize: true. rgba, depth, and normal are three modes that cannot be active simultaneously; turning on one will turn off the others. This mode ignores materials. Execute dim3() before using. normal.lua version3() dim3() background(0.5, 0.5, 1) move(width/2, height/2, 0) n = 10 beginGroup() move(0, 0, -100) pointLight() endGroup() -- rgba() -- depth() normal() noStroke() for x = 1, n do for y = 1, n do for z = 1, n do beginGroup() fill(x/n, y/n, z/n) move(map(x, 1, n, -n/2, n/2) * 50, map(y, 1, n, -n/2, n/2) * 50, map(z, 1, n, -n/2, n/2) * 200) ball(10, 2) endGroup() end end end setDepth setDepth(id, blackDistance, whiteDistance) reads the red channel of the material on the given id and sets areas with a channel value of 0 to blackDistance and areas with a value of 1 to whiteDistance, then applies the material to the depth test material. You can import depth sequences rendered from 3D software through this function, allowing PixelsWorld to interact with other layers at different depths. Execute dim3() before using. Valid ids: INPUT, PARAM0~PARAM9. newLight A function introduced in 3.7.0. newLight is responsible for creating a light instance. There are currently three built-in light instances: ambient light, point light, and parallel light. Create an ambient light: newLight(AMBIENT_LIGHT, r, g, b, intensity) Create a point light: newLight(POINT_LIGHT, r, g, b, intensity, x, y, z, radius, smoothWidth) Create a parallel light: newLight(PARALLEL_LIGHT, r, g, b, intensity, tx, ty, tz) AMBIENT_LIGHT, POINT_LIGHT, PARALLEL_LIGHT are constants. r, g, b specify the light color, range 0~1. intensity is the light intensity, range >=0. x, y, z are the coordinates of the point light. tx, ty, tz is the directional vector of the parallel light. radius is the radius of influence of the point light (see the diagram below). smoothWidth is the attenuation distance of the point light (see the diagram below). Return value: A positive integer id representing the light data. Note: This function only creates the light. You also need to call activateLight to apply the light to the scene. delLight A function introduced in 3.7.0. delLight is used to delete light instances. delLight(id1) delLight(id1, id2) delLight(id1, id2, id3) ... (Any number of ids can be input) id is a positive integer representing light data, obtained from the return value of the newLight function. Generally, you do not need to delete lights manually. PixelsWorld will automatically clear all lights at the end of each frame. getLightInfo A function introduced in 3.7.0. Use getLightInfo(id) to retrieve information about the specified light. For ambient lights, use type, r, g, b, intensity = getLightInfo(id) to capture light data. For point lights, use type, r, g, b, intensity, x, y, z, radius, smoothWidth = getLightInfo(id) to capture light data. For parallel lights, use type, r, g, b, intensity, tx, ty, tz = getLightInfo(id) to capture light data. If you're unsure of the light type of a given id, you can manage light information as follows: getLightInfo.lua version3() -- Create three test lights local lightList = { newLight(AMBIENT_LIGHT, 1, 0, 0, 1), newLight(POINT_LIGHT, 1, 0, 0, 1, 100, 200, 300, 20, 30), newLight(PARALLEL_LIGHT, 1, 0, 0, 1, 100, 200, 300), } for i, v in ipairs(lightList) do -- Store all return values in an array local returnList = {getLightInfo(v)} -- Determine light type based on the first return value. (Note: Lua arrays start indexing from 1, not 0) if (returnList[1] == AMBIENT_LIGHT) then println(\"Ambient light! Its intensity is: \" .. returnList[5]) elseif (returnList[1] == POINT_LIGHT) then println(\"Point light! Its radius is: \" .. returnList[9]) elseif (returnList[1] == PARALLEL_LIGHT) then println(\"Parallel light! Its x component of direction is: \" .. returnList[6]) end end -- Deleting lights is optional delLight(table.unpack(lightList)) activateLight A function introduced in 3.7.0. Activates the light and makes it affect the output color of all 3D objects drawn later. activateLight(id1) activateLight(id1, id2) activateLight(id1, id2, id3) ... (Any number of ids can be input) id is a positive integer representing light data, obtained from the return value of the newLight function. deactivateLight A function introduced in 3.7.0. Deactivates the light, preventing it from affecting the output color of all 3D objects drawn later. deactivateLight(id1) deactivateLight(id1, id2) deactivateLight(id1, id2, id3) ... (Any number of ids can be input) id is a positive integer representing light data, obtained from the return value of the newLight function.getActivatedLight A function introduced in 3.7.0. Retrieve the ids of all activated lights in the current environment. getActivatedLight() Returns: The ids of all lights activated by activateLight (the number of return values is 0 or more). If you prefer all return values to be packaged in a list, use idList = {getActivatedLight()}. setActivatedLight A function introduced in 3.7.0. Clear all activated lights in the environment and reset activated lights. setActivatedLight() clears all lights in the environment. setActivatedLight(id1) clears all lights in the environment and activates the light indicated by id1. setActivatedLight(id1, id2) clears all lights in the environment and activates the lights indicated by id1 and id2. ... (Any number of ids can be input) To simply append lights without clearing existing ones, use activateLight. fetchLight A function introduced in 3.7.0. Fetch light information from an Ae scene with the specified name, create light source instances internally in PixelsWorld based on the fetched parameters, and return the ids of these light instances. fetchLight(matchName) fetchLight() is equivalent to fetchLight(\"*\") matchName rules: If the string does not end with \"*\", it will search for lights named matchName in the layers of the current Ae composition and add them to the scene; if it ends with \"*\", all lights starting with matchName will be added to the scene. Currently supported Ae light types: ambient, point, parallel. Returns: One or more ids of light data that match matchName (the number of return values is 0 or more). Note: This function only creates light instances. To have the light instances affect the scene, you need to call activateLight in combination. ambientLight Since version v3.7.0, this function is not recommended. Please use newLight instead. ambientLight(r, g, b, intensity) ambientLight() is equivalent to ambientLight(1, 1, 1, 1) ambientLight(brightness) is equivalent to ambientLight(brightness, brightness, brightness, 1) ambientLight(brightness, intensity) is equivalent to ambientLight(brightness, brightness, brightness, intensity) ambientLight(r, g, b) is equivalent to ambientLight(r, g, b, 1) Creates an ambient light effective for all objects in the scene. This light ignores the direction of object normals; it can illuminate objects even if the normals are facing the opposite direction. al.lua version3() dim3() move(width/2, height/2, 0) n = 4 phong() ambientLight(1, 0.5, 0.2, 10) noStroke() for r = 1, n do local ra = r * 50 local cn = math.floor(ra * TPI / 40) for i = 1, cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn, 0.5, 0.5)) move(ra, 0, 0) ball(15, 3) endGroup() end end pointLight Since version v3.7.0, this function is not recommended. Please use newLight instead. pointLight(r, g, b, intensity, radius, smoothWidth) pointLight() is equivalent to pointLight(1, 1, 1, 1, 1000, 1000) pointLight(brightness, intensity) is equivalent to pointLight(brightness, brightness, brightness, intensity, 1000, 1000) pointLight(r, g, b) is equivalent to pointLight(r, g, b, 1, 1000, 1000) pointLight(r, g, b, intensity) is equivalent to pointLight(r, g, b, intensity, 1000, 1000) pointLight(r, g, b, intensity, radiusAndSmoothWidth) is equivalent to pointLight(r, g, b, intensity, radiusAndSmoothWidth, radiusAndSmoothWidth) Creates a point light source at the current drawing Paintbrush coordinate origin. This light is affected by the direction of object normals; objects with normals facing away will not produce diffuse reflection and highlights but can still receive ambient light from point sources. radius denotes the illumination radius; light intensity decreases from radius to radius+smoothWidth. pl.lua version3() dim3() move(width/2, height/2, 0) n = 4 phong() ambientLight(0.2, 0.5, 1, 2) beginGroup() move(0, 0, -100) pointLight(1, 0.5, 0.2, 2, 500, 100) endGroup() noStroke() for r = 1, n do local ra = r * 50 local cn = math.floor(ra * TPI / 40) for i = 1, cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn, 0.5, 0.5)) move(ra, 0, 0) ball(15, 3) endGroup() end end parallelLight Since version v3.7.0, this function is not recommended. Please use newLight instead. parallelLight(r, g, b, intensity, tx, ty, tz) Generates a parallel light globally with a direction of (tx, ty, tz). pll.lua version3() dim3() move(width/2, height/2, 0) n = 4 phong() ambientLight(0.2, 0.5, 1, 2) parallelLight(1, 0.5, 0.2, 2, 1, -1, 1) noStroke() for r = 1, n do local ra = r * 50 local cn = math.floor(ra * TPI / 40) for i = 1, cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn, 0.5, 0.5)) move(ra, 0, 0) ball(15, 3) endGroup() end end light_effects.lua version3() dim3() background(0.1, 0.2, 0.3) move(width/2, height/2, 0) math.randomseed(1) n = 5 ambientLight(0.2, 0.5, 1, 1) parallelLight(1, 0.5, 0.2, 0.1, 1, -1, 1) beginGroup() move(200, 0, -100) pointLight(1, 0.5, 0.2, 1, 200, 100) endGroup() beginGroup() move(-30, 200, -100) pointLight(0, 1, 1, 1, 200, 100) endGroup() beginGroup() move(-30, -200, -100) pointLight(0, 1, 1, 1, 200, 100) endGroup() noStroke() for r = 1, n do local ra = r * 50 local cn = math.floor(ra * TPI / 40) for i = 1, cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn, r/n, 0.6)) move(ra, 0, 0) if math.random() clearLight Since version v3.7.0, this function is not recommended. Consider using deactivateLight, delLight, or setActivatedLight instead. clearLight() clears all lights in the scene. getLight Since version v3.7.0, this function is not recommended. Use a combination of fetchLight and activateLight instead. getLight(matchName) getLight() is equivalent to getLight(\"*\") Retrieves lights in the current composition that match the matchName. matchName rules: If the string does not end with \"*\", it searches for lights named matchName in the layers of the current Ae composition and adds them to the scene. If it ends with \"*\", all lights starting with matchName are added to the scene. Currently supported Ae light types: ambient, point, parallel. aeCamera aeCamera() uses the current scene camera from Ae as the camera for the PixelsWorld scene. lookAt lookAt(eyePosX, eyePosY, eyePosZ, objPosX, objPosY, objPosZ, upVecX, upVecY, upVecZ) sets the camera position and orientation. lookAt(eyePosX, eyePosY, eyePosZ, objPosX, objPosY, objPosZ) is equivalent to lookAt(eyePosX, eyePosY, eyePosZ, objPosX, objPosY, objPosZ, 0, -1, 0) eyePos is your eye's position, objPos is the position of the object you want to look at, and upVec is the direction pointing from the top of your head. Note that the Y-axis in Ae default points downward, so you generally need upVec to be (0, -1, 0). eyePos and objPos should not be too close (recommended distance is no less than 1e-7). upVec should not be parallel to your line of sight. upVec length should not be too small. viewSpace viewSpace(width, height, distanceToPlane, farLevel) viewSpace(width, height, distanceToPlane) is equivalent to viewSpace(width, height, distanceToPlane, 4) width and height are the dimensions of the camera's far plane. The perpendicular distance from the camera to the camera's far plane is distanceToPlane. farLevel * distanceToPlane is the distance to the farthest plane; objects beyond this distance will not be rendered. Typically, setting farLevel to 4 is sufficient. If your scene is very large, this value can be set higher, which only affects whether distant objects are rendered. Setting this value too high might affect the depth testing precision of nearby objects. strokeWidth strokeWidth(width) sets the thickness of the stroke. Default value: 2 strokeWidth.lua version3() background(1) move(100, 100) for i = 1, 30 do move(10, 0) strokeWidth(i/8) line(0, 0, 0, 100) end strokeDivision strokeDivision(level) sets the subdivision level of the stroke. Default value: 3 strokeDivision.lua version3() background(1) strokeWidth(30) move(100, 100) for i = 0, 3 do strokeDivision(i) line(0, 0, 0, 100) move(75, 0) end strokeGlobal strokeGlobal() draws lines in global mode, with line thickness unaffected by scale. Default is local mode strokeGlobal.lua version3() strokeWidth(4) strokeGlobal() move(50, 100) beginGroup() for i = 1, 13 do beginGroup() scale(1/i) rect(50) endGroup() move(50/i + 20, 0) end endGroup() strokeLocal strokeLocal() draws lines in local mode, with line thickness affected by scale. Default is local mode strokeLocal.lua version3() strokeWidth(4) strokeLocal() move(50, 100) beginGroup() for i = 1, 13 do beginGroup() scale(1/i) rect(50) endGroup() move(50/i + 20, 0) end endGroup() dotRadius dotRadius(radius) sets the thickness of the dot. Default value: 2 dotRadius.lua version3() background(1) fill(0, 1, 1) dot(1, 0, 0) move(100, 100) for i = 1, 7 do dotRadius(i/2) rect(40) move(50, 0) end dotDivision dotDivision(level) sets the subdivision level of the dot (non-negative integer, maximum 7). Default value: 3 dotDivision.lua version3() background(1) fill(0, 1, 1) dot(1, 0, 0) dotRadius(10) move(100, 100) for i = 0, 4 do dotDivision(i) rect(40) move(70, 0) end dotGlobal dotGlobal() draws dots in global mode, with dot radius unaffected by scale. Default is local mode dotGlobal.lua version3() dot(1, 0, 0) dotGlobal() move(50, 100) beginGroup() for i = 1, 13 do beginGroup() scale(1/i) rect(50) endGroup() move(50/i + 20, 0) end endGroup() dotLocal dotLocal() draws dots in local mode, with dot radius affected by scale. Default is local mode dotLocal.lua version3() dot(1, 0, 0) dotLocal() move(50, 100) beginGroup() for i = 1, 13 do beginGroup() scale(1/i) rect(50) endGroup() move(50/i + 20, 0) end endGroup() smooth smooth() draws with anti-aliasing mode. Default is on. The anti-aliasing strength can be adjusted in the plugin panel. noSmooth noSmooth() draws without anti-aliasing mode. This function takes precedence over anti-aliasing settings in the plugin panel. r2d r2d(radians) converts radians to degrees, returning the degree value. d2r d2r(degrees) converts degrees to radians, returning the radian value. map map(value, in1, in2, out1, out2) maps the value value from the range in1~in2 to out1~out2. When in1 equals in2, the function returns out1 if value , otherwise it returns out2. clamp clamp(value, lower, upper) clamps the value value within the range [lower, upper], returning the clamped value. New function in v3.2.0. That is, when value is between lower and upper, it returns value; if value is less than lower, it returns lower; if value is greater than upper, it returns upper. step step(value, threshold) returns 0 when value , otherwise returns 1. New function in v3.2.0.smoothStep smoothStep(value, lower, upper) returns 0 when value , 1 when value > upper, and performs smooth interpolation between lower and upper based on value. Interpolation formula: t:=x−lowerupper−lower\r t := \\frac{x - lower}{upper - lower}\r t:=​upper−lower​​x−lower​​ Result:=t2(3−2t)\r Result := t^2(3 - 2t)\r Result:=t​2​​(3−2t) New function in v3.2.0. bezier bezier(t, p0, p1, ..., pn) performs n-th order Bezier interpolation on p0, p1, ..., pn, returning the interpolated result. Interpolation formula: Result:=∑k=0nCnk⋅(1−t)n−k⋅tk⋅pk\r Result := \\sum_{k=0}^n{C_n^k \\cdot (1-t)^{n-k} \\cdot t^k \\cdot p_k}\r Result:=∑​k=0​n​​C​n​k​​⋅(1−t)​n−k​​⋅t​k​​⋅p​k​​ Cnk:=n!(n−k)!k!\r C_n^k := \\frac{n!}{(n-k)!k!}\r C​n​k​​:=​(n−k)!k!​​n!​​ New function in v3.2.0. The maximum value of n is 66. Color Conversion xxx2xxx allows conversions as shown in the diagram below: For example, if you want to convert color data from hsl format to rgb, use the function: hsl2rgb, with three input values and three return values. All color data is converted within the range 0~1. New function in v3.2.0. color_convert.lua version3() dim3() strokeWidth(0.5) stroke(0) move(width/2, height/2, 0) for x = -5, 5 do for y = -5, 5 do for z = -5, 5 do beginGroup() move(x*15, y*15, z*15) fill(cmy2rgb(x/10 + 0.5, y/10 + 0.5, z/10 + 0.5)) cube(12) endGroup() end end end utf8ToLocal utf8ToLocal(str) converts a unicode string to a local string, returning the locally encoded string. If you're using Lua's io module and encounter a path with utf8 characters that cannot be read, use this function to convert the path encoding. localToUtf8 localToUtf8(str) converts a local string to a unicode string, returning the unicode encoded string. getGLInfo getGLInfo() retrieves information about the current graphics card. Returns a string. getDrawRecord getDrawRecord(needStringFormat) outputs the drawing record information of the current scene. needStringFormat is a Boolean value; if true, it outputs a string, if false, it outputs a Lua table. getDrawRecord() is equivalent to getDrawRecord(true). printDrawRecord.lua version3() dot(1, 0, 0) move(width/2, height/2) dim3() cube() println(getDrawRecord()) getStatus getStatus(needStringFormat) can output the current draw status information. needStringFormat is a Boolean value; if true, it outputs a string, if false, it outputs a Lua table. getStatus() is equivalent to getStatus(true). getStatus.lua version3() move(width/2, height/2) dim3() cube() println(getStatus()) getAudio Ensure you have v3.4.0+ version of PixelsWorld. getAudio([startTime, duration[, id[, sampleRate, startFrequency, endFrequency[, resolution]]]]) retrieves audio information, returning six tables: two waveform sampling tables (left and right channels), two FFT result tables (left and right channels), and two spectrum tables (left and right channels). Omitted fields will be filled with audio setting data from the plugin panel. Left channel waveform (-1~1) Right channel waveform (-1~1) Left channel FFT (0~positive infinity) Right channel FFT (0~positive infinity) Left channel spectrum (0~positive infinity) Right channel spectrum (0~positive infinity) waveInfo.lua version3() castTex(OUTPUT,INPUT) local wl, wr, ftl, ftr, specl, specr = getAudio() local nm = math.floor(height/8); for i = 1, nm do local wid = math.max(math.floor(i/nm * #wl), 1) local fid = math.max(math.floor(i/nm * #specl), 1) print(string.format(\"%8.5f\", wl[wid]), wl[wid] * 4, 0, -wl[wid] * 4) print(\" \", 1, 0, 0, 0) print(string.format(\"%8.5f\", wr[wid]), wr[wid] * 4, 0, -wr[wid] * 4) print(\" \", 0.5, 0.5, 0.5) print(string.format(\"%8.5f\", specl[fid]), specl[fid], 0, 0) print(\" \", 1, 0, 0, 0) print(string.format(\"%8.5f\", specr[fid]), 0, 0, specr[fid]) println(\"\") end saveString saveString(utf8_path, string) saves a string as a text format in the local system. loadString loadString(utf8_path) reads a local text file, returning the string. getColor getColor(id, x, y) returns the pixel value at coordinate (x, y) of the texture id, with r, g, b, a as four double-precision floating-point numbers. getColor(x, y) is equivalent to getColor(INPUT, x, y). When getColor is used before drawing any scene (i.e., immediately after version3()), the function is most efficient. Using getColor during scene drawing is very inefficient as Lua operates on the CPU, and all textures are sent to your graphics card during drawing, making communication between the GPU and CPU costly. Valid ids are INPUT, OUTPUT, PARAM0 ~ PARAM9. setColor setColor(x, y, r, g, b, a) sets the pixel value at coordinate (x, y) of the OUTPUT texture. Efficiency is highest when using setColor before drawing any scene (i.e., immediately after version3()). getSize getSize(id) returns the size of the texture id (two doubles, width, and height). When you change scene downsample (e.g., half, quarter), the returned size may jitter by 0~4 pixels due to Ae’s downsampling feature. However, this jitter does not change over time. When downsampling is turned off, this function guarantees the correct layer size. shadertoy shadertoy(code) executes code from Shadertoy. Not all Shadertoy code is supported. glsl glsl(code) executes Fragment stage code. cmd cmd(code) executes a cmd command. If the command runs successfully, the first return value is true; otherwise, it is nil. After the first return value, the function returns a string and a number. As follows: \"exit\": The command ended normally; the following number is the command’s exit status code. \"signal\": The command was interrupted by a signal; the next number is the signal that interrupted the command. lua lua(code) executes Lua code. runFile runFile(utf8_path) reads a local file as a txt file and executes it as Lua code. Supports utf8 by default, so no need to call utf8ToLocal for conversion. txt txt(utf8_path) reads a local file as a txt file and returns a string. Supports utf8 by default, so no need to call utf8ToLocal for conversion. "},"contents/Lua/Texture.html":{"url":"contents/Lua/Texture.html","title":"Texture system","keywords":"","body":"Texture System Ensure you have v3.3.0+ of PixelsWorld Through this chapter, you can quickly understand and learn how to use the texture system in PixelsWorld. newTex delTex getSize swapTex drawTo castTex blendTex copyTex fetchTex savePNG, loadPNG, saveEXR, loadEXR, saveRAW, loadRAW rotateTex, flipTex, resizeTex, trimTex Texture ID In PixelsWorld, textures are represented by an integer (texture ID). The basic texture IDs provided by PixelsWorld are as follows: Texture ID Lua Mode Global Constant GLSL Mode Global Constant Shadertoy Mode Global Constant Description -3 OUTPUT Not accessible Not accessible Output texture -2 TEMP PW_TEMP_LAYER _PixelsWorld_PW_TEMP_LAYER Temporary texture -1 INPUT AE_INPUT_LAYER _PixelsWorld_AE_INPUT_LAYER Input texture 0 PARAM0 0 0 Parameter layer 0 1 PARAM1 1 1 Parameter layer 1 ... PARAM... ... ... ... 9 PARAM9 9 9 Parameter layer 9 You can also create your own texture ID, the method is explained later. Basic Process Usually, Ae sends an image to PixelsWorld, which first places the image in INPUT. After computation, the result is placed in the OUTPUT texture. Once all instructions are done, the OUTPUT texture is sent back to Ae as the result. Role of TEMP Since OpenGL does not support reading and writing the same texture simultaneously, PixelsWorld provides TEMP to store the results drawn by functions such as glsl, shadertoy, etc. You can use getColor(PW_TEMP_LAYER, uv); to sample the color of TEMP in shaders. Create Texture Use newTex(width, height) to create a texture, which returns a texture ID (a random integer value). Delete Texture Use delTex(id) to delete a specified texture. Usually, you don’t need to delete textures manually; PixelsWorld will delete all textures at the end of each frame. However, it's a good habit to free up video memory when a texture is no longer needed. Get Size Use getSize(id) to get the dimensions of a texture. getSize.lua version3() mytex = newTex(512,256) w,h = getSize(mytex) println(\"Width of mytex is: \" .. w) println(\"Height of mytex is: \" .. h) Swap Textures Use swapTex(id1, id2) to swap the textures represented by id1 and id2. swapTex.lua version3() tex1 = newTex(128,128) tex2 = newTex(256,256) w, h = getSize(tex1) println(\"tex1 size: \" .. w .. \", \" .. h) swapTex(tex1, tex2) w, h = getSize(tex1) println(\"tex1 size after swapped: \" .. w .. \", \" .. h) Set Draw Texture Use drawTo(id) to change the draw texture. The default draw texture is OUTPUT. Note: PixelsWorld will ultimately use OUTPUT as the result to send to Ae. The following three methods can send results to OUTPUT from other textures: drawTo(OUTPUT) + image castTex swapTex Cast Texture Use castTex(toTexId, fromTexId) to project pixels from fromTexId to toTexId. For example, you can project parameter layer 0 PARAM0 to the output texture OUTPUT: castTex.lua version3() castTex(OUTPUT, PARAM0) You can also specify the range of the cast texture (with the texture's top-left corner as the origin): castTex(toTexId, fromTexId, to1x, to1y, to2x, to2y) castTex(toTexId, fromTexId, to1x, to1y, to2x, to2y, from1x, from1y, from2x, from2y) Default is to use the entire texture when the range is omitted. Blend Textures Use blendTex(toTexId, fromTexId, blendRule) to use blending rule blendRule to paste texture fromTex onto texture toTex. blendRule can be any of NORMAL, ADD, SUBTRACT, MULTIPLY, DIVIDE, MAX, MIN. blendRule can also be a string, with rules as follows: A represents pixels from toTexId B represents pixels from fromTexId C represents output pixels to toTexId For example, you can use the following code to blend the image from the input texture with parameter layer 0 using addition: blendRule.lua version3() castTex(OUTPUT, INPUT) -- Cast INPUT texture to OUTPUT firstly. blendTex(OUTPUT, PARAM0, \"C=A+B\") -- Blend PARAM0 to OUTPUT. Internally, this string is translated into GLSL code. The \"C=A+B\" translates into the following GLSL code: blendRuleGLSL.frag #version 330 core out vec4 outColor; in vec2 uv; in vec2 uv2; uniform sampler2D inLayerA; uniform sampler2D inLayerB; void main(){ vec4 A = texture(inLayerA, uv); vec4 B = texture(inLayerB, uv2); vec4 C = A; C=A+B // Your blend rule is combined here. ; outColor = C; } Like castTex, blendTex also supports specifying the texture range for blending: blendTex(toTexId, fromTexId, blendRule, to1x, to1y, to2x, to2y) blendTex(toTexId, fromTexId, blendRule, to1x, to1y, to2x, to2y, from1x, from1y, from2x, from2y) Copy Texture Use copyTex(refTexId) to copy a texture and return the newly copied texture. Fetch Any Time Layer Pixel Use fetchTex(layerId, time) to get the image at a specific time from a specified layer, returning the captured texture ID. layerId: Only PARAM0~PARAM9 can be input. time: Layer time (floating point number, in seconds) Note: Using this function may cause Ae’s cache errors; please clear the cache regularly. Function added in v3.4.3+. Read and Save Textures Use savePNG(utf8Path, texId), loadPNG(utf8Path) to save and read PNG images. Use saveEXR(utf8Path, texId), loadEXR(utf8Path) to save and read EXR images. Use saveRAW(utf8Path, texId), loadRAW(utf8Path) to save and read MiLai’s original uncompressed memory images. Here are the image specifications supported by PixelsWorld: Format Library Used Supported Compression Method Image Color Specification PNG cute_headers DEFLATE compliant decompressor zlib(RFC 1950) RGBA, clamped 8bit unsigned integer per channel. EXR tinyexr NONE, RLE, ZIP, ZIPS, PIZ, ZFP RGBA, HDR 32bit floating point per channel. RAW (None) MiLai original format. (See figure below) RGBA, HDR 32bit floating point per channel. Read a PNG image into the scene: loadPNG.lua version3() local mypng = loadPNG([[d:\\test.png]]) -- Replace with your path. castTex(OUTPUT, mypng) -- Cast pixels from mypng to OUTPUT. Save a PNG image to local storage: savePNG.lua version3() --Draw something to OUTPUT move(width/2, height/2) rotate(time) triangle() --End drawing. savePNG([[d:\\test.png]], OUTPUT) -- Save OUTPUT as PNG to local disk. Replace with your path here. Replace PNG with EXR to save and read EXR images. Saving to certain locations may require administrator permissions. Adjust Texture Use rotateTex(texId, times) to rotate the texture by 90*times degrees, where rotateTex(texId) is equivalent to rotateTex(texId, 1). Use flipTex(texId, flipV) to flip the texture, where flipV is a boolean value. flipV is true for vertical mirroring and false for horizontal mirroring. Use resizeTex(texId, width, height) to scale the texture. Use trimTex(texId, p1x, p1y, p2x, p2y) to crop the texture. p1x, p1y, p2x, p2y are coordinates with the texture's top-left corner as the origin. "},"contents/Lua/Filter.html":{"url":"contents/Lua/Filter.html","title":"Filter system","keywords":"","body":"Filter System Please ensure you have PixelsWorld v3.6.0+ The filter system is an encapsulation of rectangle shaders, allowing you to quickly develop post-processing shaders for overall image effects. Through this chapter, you can quickly understand and learn how to use the filter system of PixelsWorld. newFilter Create Filter runFilter Run Filter delFilter Delete Filter setFilterUniform Set Filter Uniforms setFilterDrawto Set Output Image newFilterModule Create Filter Module Advanced Application Create Filter Use newFilter(glslCode) to create a filter program. Return: A random integer representing the filter program (Filter ID) glslCode will be inserted into the following context: glslcode_context.glsl #version 330 core in vec2 uv; out vec4 outColor; // Your glslCode here! Example Note: In Lua, we use double square brackets [[...]] to denote multiline strings newFilter.lua version3() filterID = newFilter([[ void main(){ outColor = vec4(uv,0,1); } ]]) Run Filter Use runFilter(filterID) to run a filter program. Example runFilter.lua version3() filterID = newFilter([[ void main(){ outColor = vec4(uv,0,1); } ]]) runFilter(filterID) Delete Filter Use delFilter(filterID) to delete a filter. Usually, you don't need to delete filters, as PixelsWorld automatically deletes all filters at the end of each frame. However, it's still a good practice to delete a filter when it's no longer needed. Example delFilter.lua version3() filterID = newFilter([[ void main(){ outColor = vec4(uv,0,1); } ]]) delFilter(filterID) Set Filter Uniforms Use setFilterUniform(filterID, uniformType, uniformName, data0, data1, data2, ...) to set the uniform properties you defined in a filter. filterID: Filter ID, integer. uniformType: String representing the variable type. Supports one-dimensional data (\"int\",\"float\",\"bool\"), vectors (\"vec2\",\"vec3\",\"vec4\",\"ivec2\"...), matrices (\"mat2, mat4x3, ...\"), textures (\"sampler2D\") uniformName: Variable name string. data0,data1,...: Floating point data. (See example for details) Example setFilterUniform.lua version3() filterID = newFilter([[ uniform float myfloat; uniform vec2 myvec; uniform mat3x2 mymat; uniform sampler2D mytex1; void main(){ outColor = vec4(myfloat,myvec[0],mymat[0][1],1) + texture(mytex1,uv); } ]]) setFilterUniform(filterID, \"float\", \"myfloat\", math.sin(time)*0.5 + 0.5) setFilterUniform(filterID, \"vec2\", \"myvec\", 1,2) -- Column major, namely mymat[0][0]==1, mymat[0][1]==slider(0), mymat[0][2]==2, mymat[1][0]==3, ... setFilterUniform(filterID, \"mat3x2\", \"mymat\", 1, slider(0), 2, 3, 4, 5) -- Use INPUT texture as mytex1 setFilterUniform(filterID, \"sampler2D\", \"mytex1\", INPUT) -- ** You can also set the texture you created as mytex1 ** -- myInputTexID = newTex(512,256) -- setFilterUniform(filterID, \"sampler2D\", \"mytex1\", myInputTexID) runFilter(filterID) Set Output Image Use setFilterDrawto(filterID, texID) to specify which texture the result of the filter should be placed on. For texID, refer to the Texture System. The default output texture is OUTPUT. You can even perform iterative shading on an image. See Advanced Application for details. Create Filter Module Use newFilterModule(glslCode) to create a filter module. Return: A table containing the filter ID and some utility functions. The purpose of a filter module is to simplify your code. If you do not use a filter module, normally you need to write a filter like this: no_module.lua version3() filterID = newFilter([[ uniform float myfloat; void main(){ outColor = vec4(myfloat,0,0,1); } ]]) setFilterUniform(filterID, \"float\", \"myfloat\", math.sin(time)*0.5 + 0.5) setFilterDrawto(filterID, OUTPUT) runFilter(filterID) delFilter(filterID) With a filter module, you can write it like this: no_module.lua version3() filter = newFilterModule([[ uniform float myfloat; void main(){ outColor = vec4(myfloat,0,0,1); } ]]) filter.set(\"float\", \"myfloat\", math.sin(time)*0.5 + 0.5) filter.drawto(OUTPUT) filter.run() filter.del() Advanced Application Below is a code example for channel blur: slider 0: Blur intensity layer 0: Blur mask iterateFilter.lua version3() -- Create a temporary texture tempTexID = newTex(width, height) -- Copy input to temp texture castTex(tempTexID, INPUT) -- Blur code blurGLSLCode = [[ uniform sampler2D in_tex; uniform mat3 kernel; uniform vec2 resolution; void main() { vec2 xy = resolution * uv; vec4 res = vec4(0,0,0,0); for(int x = 0; x "},"contents/Lua/Simulation.html":{"url":"contents/Lua/Simulation.html","title":"Physics simulation","keywords":"","body":"Physics Simulation Below is the result of Chimera's Breath by nimitz running in PixelsWorld. View the full video. This chapter will introduce how to cache data in PixelsWorld. Note: Due to limited Ae functionality, please strictly follow the cache specifications outlined in this manual. Please ensure you have v3.3.3+ version of PixelsWorld. This article assumes the reader has a certain proficiency in Ae operations and PixelsWorld coding. If you are not yet familiar with using PixelsWorld, please refer to previous chapters. We recommend turning off Ae's multi-core rendering functionality. Physics Simulation Caching Data Caching Textures Practicing Data Caching - The Three-Body Problem Simulation Practicing Texture Caching - Conway's Game of Life Practicing Texture Caching - Fluid Simulation Caching Data To cache data in PixelsWorld, follow these steps: Code logic: Set the cache location and cache file name. Calculate frameId=time*fps. Calculate lastFrameId=frameId-1. If lastFrameId is less than 0, go to step 5; otherwise, go to step 6. Initialize data, then go to step 7. Read the previously stored simulation data file for the previous frame, throw an error if the file does not exist, then go to step 7. Compute the simulation data for the current frame. Store the current frame's simulation data locally. Operational logic: Insert code satisfying the above logic into PixelsWorld. Move the time indicator to the beginning of the current layer. Clear all Ae caches (Edit->Purge->All Memory & Disk Cache... as shown below). Hold Ctrl+Alt and click the LOGO on the plugin panel (optional step). Press the spacebar to start rendering (do not render sporadically). Note: If you encounter any undesired situations (errors, flickering images, etc.), repeat steps 2-5. Caching Textures Code logic: An error occurs if downsampling (half, quarter mode) is active. Set the cache location and cache file name. Calculate frameId=time*fps. Calculate lastFrameId=frameId-1. If lastFrameId is less than 0, go to step 5; otherwise, go to step 6. Initialize data, then go to step 7. Read the previously stored texture file for the previous frame, throw an error if the file does not exist, then go to step 7. Compute the texture file for the current frame. Store the current frame's texture file locally. For texture operations, refer to the Textures chapter. Operational logic: Insert code satisfying the above logic into PixelsWorld. Set Advanced->Internal texture format in the plugin panel to Floating point 32bit x RGBA (HDR). Move the time indicator to the beginning of the current layer. Clear all Ae caches (Edit->Purge->All Memory & Disk Cache...). Hold Ctrl+Alt and click the LOGO on the plugin panel (optional step). Press the spacebar to start rendering (do not render sporadically). Practicing Data Caching - The Three-Body Problem Simulation the_three_body_problem.lua version3() -- Import vector library require(\"veclib\") -- Set cache file name local cacheFileName = \"A\" -- Declare function to check if a file exists (function source: https://stackoverflow.com/questions/4990990/check-if-a-file-exists-with-lua) function file_exists(name) local f=io.open(name,\"r\") if f~=nil then io.close(f) return true else return false end end -- Calculate the current frame number and round to the nearest integer local frameId = math.floor(time * fps + .5) -- Calculate the previous frame number local lastFrameId = frameId -1 -- Check if the current frame number is non-negative, throw an error if it's negative. assert(frameId >= 0, \"FrameId not support\") -- Print the current frame number (this line can be deleted) println(\"Frame ID: \" .. frameId) -- Set cache folder (here I'm using the cache folder next to the aep project folder as the directory, save the project before using projectFolder) local cachePath = projectFolder .. \"cache\\\\\" -- Print the current output folder (this line can be deleted) println(\"Cache path: \" .. cachePath) -- If the current frame number is 0 (i.e., the previous frame is less than 0) if(lastFrameId Practicing Texture Caching - Conway's Game of Life game_of_life.lua version3() -- Check for downsampling assert(width == ds_width and height == ds_height , \"Downsample not supported\" ) -- Declare function to check if a file exists (function source: https://stackoverflow.com/questions/4990990/check-if-a-file-exists-with-lua) function file_exists(name) local f=io.open(name,\"r\") if f~=nil then io.close(f) return true else return false end end -- Calculate the current frame number and round to the nearest integer local frameId = math.floor(time * fps + .5) -- Calculate the previous frame number local lastFrameId = frameId -1 -- Check if the current frame number is non-negative, throw an error if it's negative. assert(frameId >= 0, \"FrameId not supported\") -- Print the current frame number (this line can be deleted) println(\"Frame ID: \" .. frameId) -- Set cache path local cachePath = projectFolder .. \"cache\\\\\" println(\"Cache path: \" .. cachePath) -- Check if it is the first frame if(lastFrameId = res.x || iuv.x =res.y || iuv.y.5; } // From https://thebookofshaders.com/10/ float random (vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123); } void main(){ if(time == 0.) { outColor = vec4(random(uv)>.5); }else{ bool curstatus = fetchStatus(0,0); int roundCount = 0; for(int i = 0;i 3) outColor = vec4(0); else outColor = vec4(curstatus); } else { if(roundCount == 3) outColor = vec4(1); else outColor = vec4(0); } } } ]==] -- Place the previous frame image at PARAM0 so that glsl can read the previous frame's texture from layer[0] swapTex(PARAM0,lastTexA) -- Render code glsl(fragCode) -- Place the previous frame image back to its original position swapTex(PARAM0,lastTexA) -- Save the current frame's texture locally saveRAW(cachePath .. \"A_\" .. tostring(frameId) .. \".raw\",OUTPUT) Practicing Texture Caching - Fluid Simulation Note: According to the code license requirements of the original author, the following code is for educational and non-commercial use only. Don't forget to change the Internal texture format setting on the plugin panel to Floating point 32 bit x RGBA (HDR). Please ensure you have read the previous operational instructions before starting the simulation! Read More>>> Setting Mipmap filter to NONE can speed up the process. fluid_simulation.lua version3() assert(width == ds_width and height == ds_height , \"Downsample not supported\" ) function file_exists(name) local f=io.open(name,\"r\") if f~=nil then io.close(f) return true else return false end end local frameId = math.floor(time * fps + .5) local lastFrameId = frameId -1 assert(frameId >= 0, \"FrameId not supported\") println(\"Frame ID: \" .. frameId) local cachepath = projectFolder .. \"cache\\\\\" println(\"Cache path: \" .. cachepath) if(lastFrameId "},"contents/Lua/Poly.html":{"url":"contents/Lua/Poly.html","title":"Poly function","keywords":"","body":"The Genesis Revelation — Poly Function The poly(obj) function parses the obj and renders the object. Example of Use If you have used Houdini, the construction process of obj is similar to filling out a spreadsheet in Houdini. Below is an example of constructing an unusual triangle obj. PolyTest1.lua version3() background(0.95) move(width/2, height/2) dim3() dotRadius(5) obj = { point = { {p = {0, 0, 0}, color = {0, 1, 1}}, {p = {100, 0, 0}, color = {1, 1, 0}}, {p = {0, 100, 0}, color = {1, 0, 1}}, {p = {100, 100, 0}, color = {1, 0, 0}}, }, prim = { {type = \"triangle\", pref = {1, 2, 3}}, {type = \"line\", pref = {2, 3, 3, 4, 4, 2}}, {type = \"point\", pref = {2, 4}}, } } poly(obj) Supported Primitives and Names Below, we explain using pref={1,2,3,4,5,6} as an example. pref means point reference. It refers to the sequence of point indices that the primitive will draw in. A semicolon (;) indicates the end of drawing a primitive. Standard Name (type name) Corresponding Primitive Drawing Sequence Full Name points Point 1;2;3;4;5;6; points pointd Plane Point 1;2;3;4;5;6; point disc pointb Sphere Point 1;2;3;4;5;6; point ball line Single Line 123456; single line linef Flat Line 123456; line flat linec 3D Line 123456; line capsule linel Loop Line 1234561; line loop linelf Flat Loop Line 1234561; line loop flat linelc Capsule Loop Line 1234561; line loop capsule lines Multiple Lines 12;34;56; lines linesf Multiple Flat Lines 12;34;56; lines flat linesc Multiple Capsule Lines 12;34;56; lines capsule triangles Triangle Surface 123;456; triangles triangleb Bridge Constructed Triangle Surface 123;324;345;546; triangle bridge triangler Radially Constructed Triangle Surface 123;134;145;156; triangle radial Constructing obj We define the details of obj in the following steps. obj is a table. obj can include four keys: point, vertex, prim, detail. These keys correspond to four tables, named pointArray, vertexArray, primArray, and detailList. pointArray must exist. vertexArray is optional. primArray must exist. detailList is optional. Tables with the suffix Array can contain N sub-tables, where N can be freely defined. The k-th sub-table in pointArray is called point[k] or \"the k-th point\". The k-th sub-table in vertexArray is called vertex[k] or \"the k-th sub-point\". The k-th sub-table in primArray is called prim[k] or \"the k-th primitive\". detailList and the aforementioned points, sub-points, and primitives contain several indivisible units: key-value pairs. These keys are temporarily called K, and the values are V. K is recommended to contain only English letters, numbers, and underscores, and should not be purely numeric. V can be one-dimensional, two-dimensional, three-dimensional, four-dimensional, string, texture ID, or index group. For any floating precision numbers x, y, z, w: x or {x} is a one-dimensional V. {x, y} is a two-dimensional V. {x, y, z} is a three-dimensional V. {x, y, z, w} is a four-dimensional V. \"Hello! PixelsWorld!\" is a string V. When the last four characters of K are \"_tex\" and V is an integer corresponding to a valid texture, it is called a texture ID V. For an integer sequence a1,...,an, {a1,a2,a3,...,an} is called an index group V. For each point point[k], a key named \"p\" must exist to represent the point's location. Otherwise, it is an invalid point. For each sub-point vertex[k], a key named \"pref\" with a one-dimensional V must exist to indicate the reference point ID. Otherwise, it is an invalid sub-point. For each primitive prim[k], a \"type\" key must exist with a string V to indicate the primitive type. Additionally, \"vref\" or \"pref\" keys with an index group V must exist to indicate the drawing point order of the primitive. Overriding Priority For a K with the same name, we define the following overriding priorities: Similar to Houdini vertex point prim detail Example of use: In the obj below, the prim contains color information (red), resulting in a solid red triangle. PrimColor.lua version3() background(0.95) move(width/2, height/2) dim3() obj = { point = { {p = {0, 0, 0}}, {p = {100, 0, 0}}, {p = {0, 100, 0}}, }, prim = { {type = \"triangle\", pref = {1, 2, 3}, color = {1, 0, 0}}, }, } poly(obj) In the obj below, both prim and point have color. Since point has a higher priority, the triangle uses the data provided by point, resulting in a colorful triangle. PointColor.lua version3() background(0.95) move(width/2, height/2) dim3() obj = { point = { {p = {0, 0, 0}, color = {0, 1, 1}}, {p = {100, 0, 0}, color = {1, 1, 0}}, {p = {0, 100, 0}, color = {1, 0, 1}}, }, prim = { {type = \"triangle\", pref = {1, 2, 3}, color = {1, 0, 0}}, }, } poly(obj) Use of Vertices Vertices (sub-points) can inherit the information of points. VertexColor.lua version3() background(0.95) move(width/2, height/2) dim3() obj = { point = { {p = {0, 0, 0}}, {p = {100, 0, 0}}, {p = {0, 100, 0}}, {p = {100, 100, 0}}, }, vertex = { {pref = 1, color = {1, 0, 0}}, {pref = 2, color = {1, 0, 0}}, {pref = 3, color = {1, 0, 0}}, {pref = 2, color = {0, 1, 0}}, {pref = 3, color = {0, 1, 0}}, {pref = 4, color = {0, 1, 0}}, }, prim = { {type = \"triangle\", vref = {1, 2, 3, 4, 5, 6}}, }, } poly(obj) pref indicates which point the current vertex is referencing. It stands for Point reference. vref in prim stands for Vertex reference. Note: In Lua tables, the first element index is 1, not 0. Without using vertices, the situation turns into the one below: NoVertex.lua version3() background(0.95) move(width/2, height/2) dim3() obj = { point = { {p = {0, 0, 0}, color = {1, 0, 0}}, {p = {100, 0, 0}, color = {1, 0, 0}}, {p = {0, 100, 0}, color = {1, 0, 0}}, {p = {100, 100, 0}, color = {0, 1, 0}}, }, prim = { {type = \"triangle\", pref = {1, 2, 3, 2, 3, 4}}, }, } poly(obj) Using Shaders You can even use shader language within Poly. FragColor.lua version3() background(0.95) move(width/2, height/2) dim3() obj = { point = { {p = {0, 0, 0}, myattribute = {1, 0}}, {p = {100, 0, 0}, myattribute = {0, 1}}, {p = {0, 100, 0}, myattribute = {0, 0}}, {p = {100, 100, 0}, myattribute = {1, 1}}, }, prim = { { type = \"triangle\", pref = {1, 2, 3, 2, 3, 4}, frag = [==[ #define t ]==] .. tostring(time) .. [==[ void main(){ outColor = vec4(mod(myattribute*10+vec2(t),1),0,1); } ]==], }, }, } poly(obj) Using Textures The following obj will use the input layer as a texture output to the scene. When the key name suffix of an integer property value has _tex, it is considered a texture ID. By using custom shaders, multiple textures can be used simultaneously within a single primitive. More information about textures UVTex.lua version3() background(0.95) move(width/2, height/2) dim3() obj = { point = { {p = {0, 0, 0}, uv = {0, 0}}, {p = {100, 0, 0}, uv = {1, 0}}, {p = {0, 100, 0}, uv = {0, 1}}, {p = {100, 100, 0}, uv = {1, 1}}, }, prim = { { type = \"triangler\", pref = {1, 2, 4, 3}, my_tex = INPUT, }, }, } poly(obj) "},"contents/Lua/TransparencyRender.html":{"url":"contents/Lua/TransparencyRender.html","title":"Transparency render","keywords":"","body":"Rendering Transparent Shapes When rendering a series of semi-transparent cubes, here's the result you might typically get: normalCubes.lua version3() in2out() dim3() fill(1,.5) move(width/2, height/2) for i = 1,10 do move(20,0,200) cube() end However, this result is incorrect as we cannot see the parts of the transparent cubes behind. To achieve the correct blending of colors, we need to render these cubes from the farthest to the nearest relative to the camera: sortCubes.lua version3() in2out() dim3() fill(1,.5) sortarr = {} beginGroup() move(width/2, height/2) for i = 1,10 do move(20,0,200) local x,y,z = global2screen(local2global(0,0,0)) -- Get camera distance sortarr[i] = {z,getTransformMatrix()} -- {distance, transform status} pairs end endGroup() table.sort( sortarr, function(a,b) return a[1] > b[1] end -- Sort by z distance ) for i = 1,10 do beginGroup(sortarr[i][2]) -- Apply transform status cube() endGroup() end "},"contents/Lua/RunGLSL.html":{"url":"contents/Lua/RunGLSL.html","title":"Run GLSL in Lua","keywords":"","body":"Running GLSL in Lua Usage glsl.lua version3() glsl(Your_code_string_here) Note that we recommend using [==[Your_code_string_here]==] to enclose the string to avoid any escaping issues. For example, your code should generally be written in the following form: glsl2.lua version3() glsl([==[ void main(){ outColor = vec4(uv,sin(time*10)/2+.5,1); } ]==]) The following code can be used to render code from shadertoy.com: shadertoy.lua version3() shadertoy(Your_shadertoy_code_here) "},"contents/GLSL/GLSLCode.html":{"url":"contents/GLSL/GLSLCode.html","title":"GPU Berserker GLSL","keywords":"","body":"Graphics Warrior GLSL In this section, we will quickly learn how to run GLSL in the world of pixels. What is GLSL? GLSL stands for OpenGL Shader Language, which is a GPU-based rendering language supported by OpenGL. It's mainly used to write pixel rendering rules and utilize the GPU for computation. How to learn? We recommend The Book of Shaders, which is available for free online reading. Advantages of Graphics Language If we compare the Central Processing Unit (CPU) on the motherboard to the Graphics Processing Unit (GPU) on the graphics card, the CPU is like a super sports car, while the GPU is like a large bus. For transporting a small number of people over a certain distance, a super sports car performs extraordinarily well. However, if you want to perform highly repetitive tasks—such as computing an image—where you can imagine moving hundreds or thousands of people, then choosing a large bus is clearly the wise choice. The programming languages we usually learn, such as C/C++, Java, and Python, mostly run directly on the CPU. Whereas languages like GLSL are designed to run on the GPU. When processing an image, the GPU can deploy many \"workers\" simultaneously to carry out highly repetitive tasks, with the specific work content defined by GLSL. For more information on GLSL syntax, it is recommended to visit shadertoy.com. Find some interesting and simple effects to explore how they work. Details: Before running GLSL, we predefine many variables and functions. If you are a beginner, you can temporarily ignore this part. PixelsWorld V3.0.0 uses #version 330 core. Click here to view additional predefined code. "},"contents/GLSL/RunGLSL.html":{"url":"contents/GLSL/RunGLSL.html","title":"Run GLSL","keywords":"","body":"Running GLSL Code GLSL code should be executed in GLSL(GPU) mode; Click \"Edit\" in the \"World rule\" section; At this point, some code will be displayed on the panel. default.shader void main(){ outColor = getColor(uv); } This code will send the input pixel to the output pixel. You can change getColor(uv) to vec4(uv,0.0,1.0) to create a visually appealing UV color pattern; uvcolor.shader void main(){ outColor = vec4(uv,0.0,1.0); } Then, simply click \"Ok\". Normally, you should see the following effect: "},"contents/GLSL/GetStart.html":{"url":"contents/GLSL/GetStart.html","title":"Quick start","keywords":"","body":"What Is It Like to Write Shader Code? Shader code is akin to the expression function in Excel spreadsheets. By writing expressions into a spreadsheet, the spreadsheet processes all the data for you. If we consider the data in the spreadsheet as input pixels and the calculated spreadsheet as output pixels, coding in the pixel world can be understood as expressions in an Excel spreadsheet. Example: Brightening an Image To make an image brighter, the simplest calculation is to increase the values of red, green, and blue for all pixels. In an Excel spreadsheet, we would proceed as follows: This adjusts all the pixel data on the left to be \"brighter.\" In the pixel world, we would input: bright_describe.shader outColor=getColor(uv)+vec4(0.2); Translated into plain language: obtain the input pixel at the current position (uv) using (getColor), add 0.2 to the four channels (red, green, blue, alpha) (+vec4(0.2)), and finally assign the calculated result to the output (outColor). Of course, a single line alone doesn't suffice for the pixel world to function correctly; an outer \"shell\" is needed to make it operational! Here is the complete code: bright.shader void main(){ outColor=getColor(uv)+vec4(0.2); } How to Operate: Input Image (Right-click to save): (Original Source Link) Effect Image: Adding More Control! Typically, simply adding 0.2 to the image isn't ideal; you'd want more control. You can replace 0.2 with slider[0], allowing you to adjust the effect using a slider from the parameters panel. bright_control.shader void main(){ outColor=getColor(uv)+vec4(slider[0]); } However, you'll notice that when the value is negative, the transparency also reduces, which is usually undesirable. If you want to avoid altering the transparency channel, the rendering code should be written as below: bright_control.shader void main(){ vec4 inColor = getColor(uv); inColor.rgb = inColor.rgb + vec3(slider[0]); outColor = inColor; } Explanation: First, store the input pixel in a four-dimensional (vec4) variable inColor, then add the value of slider[0] to the rgb (representing red, green, blue) channels. Finally, assign the value of inColor to outColor, leaving the alpha channel (representing transparency) unchanged in the output. Naming Parameters For a cleaner parameters panel, you can take the following steps: Save to Presets Finally, you can save the code, especially ones you might use later, into presets. Refer to the Preset Management section for more details. Congratulations! You now have a fundamental understanding of using Pixel World! Pixel World not only allows for code writing but also for finding exciting effects on websites like shadertoy to incorporate into it. For instructions on rendering code from shadertoy, please refer to here. "},"contents/GLSL/Functions.html":{"url":"contents/GLSL/Functions.html","title":"Functions","keywords":"","body":"Functions This section briefly introduces the built-in functions. These functions can be used without any declaration. "},"contents/GLSL/getColor.html":{"url":"contents/GLSL/getColor.html","title":"getColor","keywords":"","body":"getColor This function has two versions: getColor(vec2) and getColor(int, vec2). getColor(vec2) Description: Retrieves the color of the input layer at a specified position. Parameters: vec2: UV position (range 0 to 1 in each dimension) Returns: vec4: RGBA color (range 0 to 1 in each dimension) getColor(int, vec2) Description: Retrieves the pixel of a specific input layer at a specified position. Parameters: int: Layer index, -1 (or AE_INPUT_LAYER) refers to the input layer, numbers 0-9 refer to the corresponding layer parameters on the plugin panel (PW_TEMP_LAYER (Layer index-2) used in Lua rendering mode). vec2: UV coordinates Returns: vec4: RGBA color Note: In summary, getColor(AE_INPUT_LAYER, uv); and getColor(uv) are equivalent; getColor(n, uv); can return pixel information of layer[n]. "},"contents/GLSL/uvxy.html":{"url":"contents/GLSL/uvxy.html","title":"uv2xy,xy2uv","keywords":"","body":"uv2xy, xy2uv These two functions are used for conversion between UV coordinates and XY coordinates by performing simple multiplication and division. uv2xy(vec2) Description: Calculate xy values from given uv values. Parameter: vec2 : uv position value. Returns: vec2 : xy position value. Note: If the layer dimensions are 1280 x 720, uv2xy(vec2(0.1,0.5)); returns vec2(128.0,360.0); xy2uv(vec2) Description: Calculate uv values from given xy values. Parameter: vec2 : xy position value. Returns: vec2 : uv position value. Note: If the layer dimensions are 1920 x 1080, xy2uv(vec2(192,108)); returns vec2(0.1,0.1); "},"contents/GLSL/LinkParameters.html":{"url":"contents/GLSL/LinkParameters.html","title":"Link parameters","keywords":"","body":"Link Parameters Using external parameters, animations can be set up. There are currently 7 types of parameters available for animations: Sliders Angles Points 3D Points Checkboxes Colors Layers And each group of parameters has 10 controllers for manipulation. Example: link_slider.shader void main(){ outColor = vec4(uv, slider[0], 1.0); } For instance, changing slider 0 will alter the color in the preview window. Details In PixelsWorld, parameters are declared as follows: parameters.shader uniform float slider[10]; uniform float angle[10]; uniform bool checkbox[10]; uniform vec2 point[10]; uniform vec3 point3d[10]; uniform vec4 color[10]; uniform sampler2D layer[10]; uniform sampler2D inLayer; Note \"inLayer\" represents the input layer. sampler2D is a variable type provided by GLSL; you don't need to understand this type. If you want to know about layer parameters, please refer to \"getColor\". \"uniform\" denotes a global variable. "},"contents/GLSL/debug.html":{"url":"contents/GLSL/debug.html","title":"Debug","keywords":"","body":"Debug Check the debug checkbox in the plugin panel. When there are error messages, they will be printed on the screen in red font. "},"contents/GLSL/Advanced_settings.html":{"url":"contents/GLSL/Advanced_settings.html","title":"Advanced settings","keywords":"","body":"Advanced Settings This section introduces the advanced options settings available in the effects panel. Wrap U/V Sampler This parameter affects the result of getColor() when the sampled pixels exceed the image boundaries. Test Code (Apply on material using PixelsWorld): wrap_uv_sampler.shader void main() { outColor = getColor(uv*10); } Magnify/Minify Sampler This parameter affects the behavior of getColor() when the sampler performs interpolated sampling around neighboring pixels. Test Code (Apply on material using PixelsWorld): wrap_uv_sampler.shader void main() { outColor = getColor(uv*0.1); } If you want to achieve a similar pixel style effect, set this option to Nearest pixel. Mipmap Allows you to specify the color-picking method when the texture is minimized. wrap_uv_sampler.shader void main() { outColor = getColor(uv*10); } "},"contents/GLSL/predefined.html":{"url":"contents/GLSL/predefined.html","title":"Pre-defined code","keywords":"","body":"Predefined Code Before running, shader code is encapsulated with predefined environmental code to support various features. GLSL mode only includes prelude code. Shadertoy mode contains both prelude and postlude code. GLSL Mode Prelude Code: pre_frag_shader_glsl.frag #define gl_Position uv2xy(uv) #define gl_FragCoord uv2xy(uv) #define gl_FragColor outColor #define INPUT_LAYER_INDEX -1 #define OUTPUT_LAYER_INDEX -2 #define AE_INPUT_LAYER -1 #define PW_TEMP_LAYER -2 out vec4 outColor; in vec2 uv; uniform float slider[10]; uniform float angle[10]; uniform bool checkbox[10]; uniform vec2 point[10]; uniform vec3 point3d[10]; uniform vec4 color[10]; uniform sampler2D layer[10]; uniform vec2 layerResolution[10]; uniform sampler2D inLayer; uniform sampler2D outLayer; uniform float time; uniform float inpoint; uniform float duration; uniform float comp_time; uniform vec4 date; // vec4(year,month,day,hour*3600 + minute*60 + second + millisecond/1000.) uniform float fps; uniform float width; uniform float height; uniform vec2 origin; uniform vec2 resolution; uniform vec2 downsample; uniform mat4 camera_matrix; uniform vec4 camera_info; // x,y: resolution, z: distance to plane, w: distance to focus. uniform bool camera_perspective; uniform sampler1D inWaveL; // Left wave samples uniform sampler1D inWaveR; // Right wave samples uniform float inWaveN; // Wave sample number uniform float inWaveS; // Sample rate, settings in plugin panel. Default: 44100. uniform vec2 inWaveT; // vec2(sampleStartTime, sampleEndTime), unit: second. New in v3.4.0 uniform sampler1D inSpecL; // Left spectrum samples uniform sampler1D inSpecR; // Right spectrum samples uniform float inSpecN; // Spectrum sample number uniform vec2 inSpecF; // vec2(spectrumStartFrequency, spectrumEndFrequency), unit: hz. New in v3.4.0 vec4 getColor(int layerId,vec2 coord) { if(layerId==AE_INPUT_LAYER) return texture(inLayer,coord); if(layerId==PW_TEMP_LAYER) return texture(outLayer,coord); else if(layerId>=0 && layerId Shadertoy Code Prelude Code pre_frag_shader_shadertoy.frag #define gl_Position (_PixelsWorld_uv * iResolution.xy) #define gl_FragCoord (_PixelsWorld_uv * iResolution.xy) #define gl_FragColor _PixelsWorld_outColor #define _PixelsWorld_INPUT_LAYER_INDEX -1 #define _PixelsWorld_OUTPUT_LAYER_INDEX -2 #define _PixelsWorld_AE_INPUT_LAYER -1 #define _PixelsWorld_PW_TEMP_LAYER -2 uniform vec3 iResolution; uniform float iTime; uniform float iTimeDelta; uniform int iFrame; // uniform float iChannelTime[4]; uniform vec4 iMouse; uniform vec4 iDate; uniform sampler2D iChannel0; uniform sampler2D iChannel1; uniform sampler2D iChannel2; uniform sampler2D iChannel3; uniform vec3 iChannelResolution[4]; uniform float _PixelsWorld_slider[10]; uniform float _PixelsWorld_angle[10]; uniform bool _PixelsWorld_checkbox[10]; uniform vec2 _PixelsWorld_point[10]; uniform vec3 _PixelsWorld_point3d[10]; uniform vec4 _PixelsWorld_color[10]; uniform sampler2D _PixelsWorld_layer[10]; uniform vec2 _PixelsWorld_layerResolution[10]; uniform sampler2D _PixelsWorld_inLayer; uniform sampler2D _PixelsWorld_outLayer; uniform float _PixelsWorld_time; uniform float _PixelsWorld_inpoint; uniform float _PixelsWorld_duration; uniform float _PixelsWorld_comp_time; uniform vec4 _PixelsWorld_date; uniform float _PixelsWorld_fps; uniform float _PixelsWorld_width; uniform float _PixelsWorld_height; uniform vec2 _PixelsWorld_origin; uniform vec2 _PixelsWorld_resolution; uniform vec2 _PixelsWorld_downsample; uniform mat4 _PixelsWorld_camera_matrix; uniform vec4 _PixelsWorld_camera_info; uniform bool _PixelsWorld_camera_perspective; uniform sampler1D _PixelsWorld_inWaveL; uniform sampler1D _PixelsWorld_inWaveR; uniform float _PixelsWorld_inWaveN; uniform float _PixelsWorld_inWaveS; uniform vec2 _PixelsWorld_inWaveT; uniform sampler1D _PixelsWorld_inSpecL; uniform sampler1D _PixelsWorld_inSpecR; uniform float _PixelsWorld_inSpecN; uniform vec2 _PixelsWorld_inSpecF; in vec2 _PixelsWorld_uv; out vec4 _PixelsWorld_outColor; vec4 _PixelsWorld_getColor(int layerId,vec2 coord) { if(layerId==_PixelsWorld_AE_INPUT_LAYER) return texture(_PixelsWorld_inLayer,coord); if(layerId==_PixelsWorld_PW_TEMP_LAYER) return texture(_PixelsWorld_outLayer,coord); else if(layerId>=0 && layerId Postlude Code post_frag_shader_shadertoy.frag void main(){ mainImage(_PixelsWorld_outColor, _PixelsWorld_uv * iResolution.xy); } "},"contents/GLSL/shadertoy.html":{"url":"contents/GLSL/shadertoy.html","title":"Template Zone shadertoy","keywords":"","body":"ShaderToy Sanctuary Template Usage In this mode, you can directly use code from shadertoy.com. Note Not all code from shadertoy.com can perfectly run in PixelsWorld (e.g., code with audio input, requiring VR support, and containing loop buffer references). Details If you would like to use custom parameter panels in shadertoy mode, simply add the _PixelsWorld_ prefix to all variables in GLSL mode to enable them. For instance, slider[0] in GLSL mode will become _PixelsWorld_slider[0]. Refer to here to understand the definitions of all global variables. Of course, in shadertoy mode, it's not recommended to define variables with the _PixelsWorld_ prefix on your own. Using Buffers Shadertoy inherently offers 4 buffers, and you can also implement buffers in PixelsWorld. Non-Cyclic Buffers If the effects you are using do not involve cyclic calls between Buffers (as shown in the lower half of the previous diagram), then the buffers in your effect are non-cyclic. You can call them using the code template below (note: you need to switch to Lua mode). For instance, for the code from: https://www.shadertoy.com/view/4dVGRW: This effect uses BufferA, so the code sets A to true in the fourth line below. BufferA is ultimately bound to iChannel0 on the Main image, so the code sets AtoMain to 0 on line 15 below. Next, copy the BufferA and Main codes into their respective variables. Finally, to ensure correct results, set the plugin panel's Advanced->Internal texture format to Floating point 32 bit x RGBA (HDR) to prevent PixelsWorld from flattening the Alpha channel internally. Make sure you are in Lua rendering mode. rotatingCubes.lua version3() enable = { A=true, B=false, C=false, D=false, -- '-1': disable -- '0~3': which iChannel to set AtoB = -1, AtoC = -1, AtoD = -1, AtoMain = 0, BtoC = -1, BtoD = -1, BtoMain = -1, CtoD = -1, CtoMain = -1, DtoMain = -1, } mainCode = [==[ // Paste the main code here. mat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) { vec3 rr = vec3(sin(roll), cos(roll), 0.0); vec3 ww = normalize(target - origin); vec3 uu = normalize(cross(ww, rr)); vec3 vv = normalize(cross(uu, ww)); return mat3(uu, vv, ww); } vec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) { mat3 camMat = calcLookAtMatrix(origin, target, 0.0); return normalize(camMat * vec3(screenPos, lensLength)); } vec2 squareFrame(vec2 screenSize, vec2 coord) { vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0; position.x *= screenSize.x / screenSize.y; return position; } vec2 getDeltas(sampler2D buffer, vec2 uv) { vec2 pixel = vec2(1. / iResolution.xy); vec3 pole = vec3(-1, 0, +1); float dpos = 0.0; float dnor = 0.0; vec4 s0 = texture(iChannel0, uv + pixel.xy * pole.xx); // x1, y1 vec4 s1 = texture(iChannel0, uv + pixel.xy * pole.yx); // x2, y1 vec4 s2 = texture(iChannel0, uv + pixel.xy * pole.zx); // x3, y1 vec4 s3 = texture(iChannel0, uv + pixel.xy * pole.xy); // x1, y2 vec4 s4 = texture(iChannel0, uv + pixel.xy * pole.yy); // x2, y2 vec4 s5 = texture(iChannel0, uv + pixel.xy * pole.zy); // x3, y2 vec4 s6 = texture(iChannel0, uv + pixel.xy * pole.xz); // x1, y3 vec4 s7 = texture(iChannel0, uv + pixel.xy * pole.yz); // x2, y3 vec4 s8 = texture(iChannel0, uv + pixel.xy * pole.zz); // x3, y3 dpos = ( abs(s1.a - s7.a) + abs(s5.a - s3.a) + abs(s0.a - s8.a) + abs(s2.a - s6.a) ) * 0.5; dpos += ( max(0.0, 1.0 - dot(s1.rgb, s7.rgb)) + max(0.0, 1.0 - dot(s5.rgb, s3.rgb)) + max(0.0, 1.0 - dot(s0.rgb, s8.rgb)) + max(0.0, 1.0 - dot(s2.rgb, s6.rgb)) ); dpos = pow(max(dpos - 0.5, 0.0), 5.0); return vec2(dpos, dnor); } void mainImage(out vec4 fragColor, in vec2 fragCoord) { vec3 ro = vec3(sin(iTime * 0.2), 1.5, cos(iTime * 0.2)) * 5.; vec3 ta = vec3(0, 0, 0); vec3 rd = getRay(ro, ta, squareFrame(iResolution.xy, fragCoord.xy), 2.0); vec2 uv = fragCoord.xy / iResolution.xy; vec4 buf = texture(iChannel0, fragCoord.xy / iResolution.xy); float t = buf.a; vec3 nor = buf.rgb; vec3 pos = ro + rd * t; vec3 col = vec3(0.5, 0.8, 1); vec2 deltas = getDeltas(iChannel0, uv); if (t > -0.5) { col = vec3(1.0); col *= max(0.3, 0.3 + dot(nor, normalize(vec3(0, 1, 0.5)))); col *= vec3(1, 0.8, 0.35); } col.r = smoothstep(0.1, 1.0, col.r); col.g = smoothstep(0.1, 1.1, col.g); col.b = smoothstep(-0.1, 1.0, col.b); col = pow(col, vec3(1.1)); col -= deltas.x - deltas.y; fragColor = vec4(col, 1); } ]==]; commonCode = [==[ // Paste the common code here ]==] bufferACode = [==[ // Paste the Buffer A code here float sdBox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); } vec2 mirror(vec2 p, float v) { float hv = v * 0.5; vec2 fl = mod(floor(p / v + 0.5), 2.0) * 2.0 - 1.0; vec2 mp = mod(p + hv, v) - hv; return fl * mp; } vec2 rotate2D(vec2 p, float a) { return p * mat2(cos(a), -sin(a), sin(a), cos(a)); } float map(vec3 p) { float r = iMouse.z > 0.0 ? iMouse.x / 100.0 : iTime * 0.9; p.xz = mirror(p.xz, 4.); p.xz = rotate2D(p.xz, r); float d = sdBox(p, vec3(1)); d = min(d, sdBox(p, vec3(0.1, 0.1, 3))); d = min(d, sdBox(p, vec3(3, 0.1, 0.1))); return d; } mat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) { vec3 rr = vec3(sin(roll), cos(roll), 0.0); vec3 ww = normalize(target - origin); vec3 uu = normalize(cross(ww, rr)); vec3 vv = normalize(cross(uu, ww)); return mat3(uu, vv, ww); } vec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) { mat3 camMat = calcLookAtMatrix(origin, target, 0.0); return normalize(camMat * vec3(screenPos, lensLength)); } float calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) { float latest = precis * 2.0; float dist = +0.0; float type = -1.0; float res = -1.0; for (int i = 0; i maxd) break; float result = map(rayOrigin + rayDir * dist); latest = result; dist += latest; } if (dist = 0 and sch Cyclic Buffers Hmm... if you want to use effects involving cyclic buffers, we highly discourage using them in PixelsWorld. (However, it is still achievable, but be prepared for a night of struggle with AE and PixelsWorld. I am ready >>>) "},"contents/Lua/JavaScript.html":{"url":"contents/Lua/JavaScript.html","title":"World Outskirts JavaScript","keywords":"","body":"JavaScript Code In Lua (CPU & GPU) mode, the pixel world can execute JavaScript code using js. executeJS.lua version3() js(\"alert('Hello PixelsWorld!')\"); Note: Due to the structure of the Ae program, we do not recommend using js code in the pixel world (especially for retrieving UI control parameter information). You can use js code for simple computations between local variables. "},"contents/Lua/CMDCode.html":{"url":"contents/Lua/CMDCode.html","title":"World Bed Rocks CMD","keywords":"","body":"CMD Code In Lua (CPU & GPU) mode, the pixel world can execute CMD commands using cmd(\"Your cmd commands\"). executeCMD.lua version3() cmd(\"echo Hello PixelsWorld! & pause\"); "},"contents/Serial/SerialAttention.html":{"url":"contents/Serial/SerialAttention.html","title":"Apointments","keywords":"","body":"Serial Number Usage Agreement Note: These terms do not apply to customers who purchased on the aescripts.com platform. A serial number contains N \"registrations\" (N is greater than or equal to 1). One \"registration\" permanently registers one computer. One computer's \"registration\" can be used across multiple versions of Ae. Registering a computer will decrease one \"registration\", while unbinding an already registered computer will increase one \"registration\". Only registering and unbinding require an internet connection; after registering, the software can be used offline. Before replacing your motherboard or CPU, please unbind the serial number and re-bind it after the replacement. If you forget to unbind the serial number, please contact us by email. The serial number is not tied to any personal information. It is allowed but not recommended to share or resell among friends. If shared or resold, any issues or benefits resulting from this are not the responsibility of the Future Vision Animation Group. By default, only one \"registration\" is included with purchase. If you have multiple devices and wish to use Pixel World simultaneously on them, please purchase the appropriate number of Pixel World serial numbers, and we will send serial numbers with the corresponding number of \"registrations\". "},"contents/Serial/Lost.html":{"url":"contents/Serial/Lost.html","title":"Help, I forgot to deactivate it!!!","keywords":"","body":"Help, I forgot to unregister! Solution Solution: Register on the new machine The serial number authentication system will automatically delete seats that have not been active for more than a month in the cloud. If you received the error message: key_already_used.This indicates that your previous seat hasn't been inactive long enough to be automatically deleted. Please wait up to a month before trying again. "},"contents/QA/EntryPointErr.html":{"url":"contents/QA/EntryPointErr.html","title":"Error: Couldn't find main entry point for PixelsWorld.aex (48::72)","keywords":"","body":"Error: Couldn't find main entry point for PixelsWorld.aex (48::72) If you encounter the following error message when testing/using PixelsWorld for the first time, please check the following items. You need to update Ae to the latest version via Creative Cloud (recommended 16.1.3+ for CC2019 and 17.5.1+ for 2020) Windows 10 should be updated to the latest version (recommended Windows 10 20H2 or later) You need to have the latest graphics driver Your graphics card should support the OpenGL 3.3 or later protocol at the hardware level (you can use the OpenGL Extensions Viewer tool to check) OpenCL.dll should be present in the C:\\Windows\\System32 directory "}}