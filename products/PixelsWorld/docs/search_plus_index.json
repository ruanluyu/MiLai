{"./":{"url":"./","title":"Be the Creator of your World","keywords":"","body":"Be the Creator of your world PixelsWorld documentation version: v3.0.0 Author ZzStarSound History v2.3.1 v1.0 中文版 Welcome to PixelsWorld! We have compressed all essence of how to use PixelsWorld in this section. If you master it, you will be a new creator of PixelsWorld! To be simple PixelsWorld renders image basing on your code You can use presets that written by other people. By learning how to write the Draw code, drawing shapes step-by-step to your scene. By learning the hardcore GLSL, creating advanced visual effect by yourself. How to do? PixelsWorld is a Drawing robot, if you tell it what/where to draw step-by-step, it will draw the shapes into the current scene for you. For instance, consider the case that you want to draw a house in the middle of the canvas, but the painter is your friend Andrew (and Andrew doesn't know what you want to draw). How to make the instructions so that Andrew can draw it for you? We would say: DrawHouse.myBro Draw a house in the middle of the canvas This is OK, but what if you cannot tell Andrew the answer directly, but 1. where to draw, 2. what to draw, 3. the color instead, maybe we need to say: DrawHouse2.myBro move the paintbrush to the center use yellow pigment draw a 10x10cm square move the paintbrush 5cm upward use red pigment draw a 15cm base length, 10cm height isoceles triangle. And then, you and Andrew complete the house painting! Indeed, the instructions above is exactly what we need to write in PixelsWorld. By clearing it up, it looks like this: DrawHouse3.lua version3() -- use version 3, this is a function that you always have to call in the first line. move(width/2, height/2) -- move the paintbrush to the center rotateX(PI) -- rotate space along X axis fill(1,1,0) -- use yellow pigment (Red=1,Green=1,Blue=0) rect(100) -- draw a 100x100px square fill(1,0,0) -- use red pigment(Red=1,Green=0,Blue=0) move(0,50) -- move the paintbrush 50px up tri(150,100) -- draw a 150px base length, 100px height isoceles triangle. There is a function rotateX(PI) we didn't mention before. Because the default orientation of the Y axis is downward, we need to rotate it along X axis 180 degrees (PI radians) to make it upward. Otherwise, the following movement of paintbrush will move it 50cm downward. Here we want to add some extra controls to the scene like change the color combination of our house. DrawHouse3.lua version3() -- use version 3, this is a function that you always have to call in the first line. move(width/2, height/2) -- move the paintbrush to the center rotateX(PI) -- rotate space along X axis fill(color(0)) -- use color parameter 0 as pigment rect(100) -- draw a 100x100px square fill(color(1)) -- use color parameter 1 as pigment move(0,50) -- move the paintbrush 50px up tri(150,100) -- draw a 150px base length, 100px height isoceles triangle. If you click the Ok button, the house would disappear! Actrually the house is still drawn in your scene, but the default color controls are black, so the house is also black. Open the Parameter list, find the first 2 Color controls, change it to the color you want. Mayor is me! Draw more houses One big advantage of using code is doing repetitive things. Lua language is able to repeat your instructions as many times as you want. DrawHouse3.lua version3() -- use version 3, this is a function that you always have to call in the first line. move(width/2, height/2) -- move the paintbrush to the center rotateX(PI) -- rotate space along X axis for i=1,3 do -- begin repeat (3 times) fill(color(0)) -- use color parameter 0 as pigment rect(100) -- draw a 100x100px square fill(color(1)) -- use color parameter 1 as pigment move(0,50) -- move the paintbrush 50px up tri(150,100) -- draw a 150px base length, 100px height isoceles triangle. move(0,-50) -- move the paintbrush back move(175,0) -- move the paintbrush 175px right end -- End mark of repeat Finally, we want to give the controls some names: Save the instructions to preset. Note: This step may need the Administrator mode if you have installed Ae in the System disc (maybe C). First of all, add a new Preset column to save your preset: Then, save your preset in the new Preset column: Apply preset Select the preset you want to apply, click the Replace button. Congratulations! You have mastered the main part of how to use PixelsWorld. >>> Next step: Go to chapter 3 for more details "},"contents/HowTo.html":{"url":"contents/HowTo.html","title":"Get/Try/Purchase","keywords":"","body":"Get/Try/Purchase Download Purchase/Download PixelsWorld Note: Some preset are under non-commercial license. Put the \"MiLai\" folder into (Your AE root folder)/Support Files/Plug-ins/ How to apply it Open Adobe After Effects. \"Ctrl + N\"(or \"Command + N\") to create a comp. Create a solid layer. Select the solid you created. Right click it => Effects => MiLai => PixelsWrold. Click \"Edit\" to change \"World formula\". There will be a World formula editor showed up . Find \"Preset list\" and select \"shadertoy\" Choose an effect that are interesting to you. Click \"Ok\". "},"contents/Editor/ScriptWindow.html":{"url":"contents/Editor/ScriptWindow.html","title":"World formula editor","keywords":"","body":"World formula editor How to open Click \"Edit\" button in plugin panel. To make it simple to describe, we assigned defferent area with color. ◆Code area Input your creative code here. Language can override the settings in your plugin panel. (default) selection means don't override. ◆Reference list You can copy reference code here, this is read-only currently. ◆Parameter settings Here you can see the labels, the default value of parameters and the language settings. Click Parameter manager button to manage them. See also Parameter manager Parameter settings will be saved with code into preset. ◆Preset list The pop-up menu will show you all the preset files in your local disc. Here we have same definition: A file with .pwp post fix, has JSON format and put beside plugin will be treat as one Preset column. The name of Preset column is the name of that file. One Preset column containing several Presets All Presets will be list on the bottom of the pop-up menu. ◆Formula preview The selected Preset's code will be shown here. If you want it to go to your code area, click Replace button to override code in the code area. If you only want to replace the text and don't want the parameter settings changed. Uncheck Apply when replace in Parameter settings preview area. If you want to add the preset code before your code, click button; If you want it behind your code, click Bottom>> button. ◆Parameter settings preview The selected Preset's parameter settings will be shown here. If you want it to go to your code area, click Replace button to override code in the code area. Apply when replace means if auto apply parameter settings when you clicked Replace button in Formula preview area. "},"contents/Editor/ParameterWindow.html":{"url":"contents/Editor/ParameterWindow.html","title":"Parameter manager","keywords":"","body":"Parameter manager Click Parameter manager button on World rule editor to start Parameter manager. This window will show up: Rule Type in lables in the first input area, default values in the following input area. (Decimal number) Clear names button will clear names in input area of label. Clear all names button will clear all names in input area of label. Reset names button will reset names in input area of label. Reset all names button will reset all names in input area of label. Reset values button will reset values in input area of default value. Reset all value button will reset all values in input area of default value. Encoding PixelsWorld supports utf-8. Some not supported character will be converted to ? If you work with international authors. We recommand using ASCII characters as the label. "},"contents/Editor/SavePresets.html":{"url":"contents/Editor/SavePresets.html","title":"Preset management","keywords":"","body":"Preset management Save preset In World formula editor,you can click Save as preset button to save your code as preset. Note: Override will happen if you use the name that already exists. Override save In World formula editor,you can click Save as preset button, and type the existing name to override the previous preset. Note This is not undoable. Rename presets Double click the preset to rename. Use name EXCEPTREMOVE and SORT. Sort presets Double click one preset and type in SORT. Remove presets Double click the preset you want to remove and type in REMOVE. Add preset column Click Add button in Preset list Note: Name must be unique. If failed, you might need to re-open Ae with administrator mode. Format Format: utf-8,JSON Not encrypted. Contribute presets Send your preset to rly_pxx_123@sina.com with your name. "},"contents/Lua/LuaCode.html":{"url":"contents/Lua/LuaCode.html","title":"World Center Lua","keywords":"","body":"Lua Code The instructions that we wrote in chapter 1 is called Lua Lua is a lightweight, high-level, multi-paradigm programming language designed primarily for embedded use in applications. ——Wiki) Version : Lua5.3 So Lua plays the roll that manages the communication between Ae and Users. It is quite similar to Ae script and expression language. Basically you can draw highly variant scene by remembering just a little words. For instance, if you want to draw a cube that can interact with Ae camera, just type: DrawCube.lua version3() move(width/2,height/2) dim3() cube(300) dim3() means draw shapes in 3 dimension. If you want to run GLSL code, just type: RunGlsl.lua version3() glsl([==[ Your GLSL code here ]==]) If you want to run code from shadertoy, just type: RunShadertoy.lua version3() pw.shadertoy([==[ The shadertoy code here ]==]) In Lua, you can : Get pixels data Write pixels data Run JavaScript Run GLSL Get paramters data Run outer C library (COOL!) Load outer lua module Because of the advanced features, the users who using Lua render mode should have basic programming abilities and have a primary understanding about Lua language. If you have no idea about Lua, don't warry about it, it is pretty easy to learn. "},"contents/Lua/RunLua.html":{"url":"contents/Lua/RunLua.html","title":"Run Lua","keywords":"","body":"Run Lua code Switch your luange to Lua ( CPU & GPU ) And input the code below : hello.lua version3() a = 5+6 b = \"PixelsWorld\" c = \"is cool!\" d = time e = slider(0) f = \"5 + 6 = \" .. a .. \"\\nMessage : \" .. b .. \" \" .. c .. \"\\nCurrent time is : \" .. d .. \" (s)\\nValue of slider0 is : \" .. e print(f) a..b means combine variable a and b as string. print() reports message to debug window. slider() fetches the value of a specified parameters. You are allowed to add ; in the end of each line, but it is not indispensable. Lua regards the \\n(line break) as the end mark of one section of code. A message will show up in the left top corner of your screen. "},"contents/Lua/WriteLocalCode.html":{"url":"contents/Lua/WriteLocalCode.html","title":"Load local code","keywords":"","body":"在本地写代码 If you don't prefer to use PixelsWorld's editor, PixelsWorld can read txt file from local disc. So you can write the file with the IDE you like. Don't put the file to system disc(C:\\ disc). loadTxt.lua version3() runFile([[d:\\mycode.txt]]) -- Replace to your path The reason we use [[d:\\mycode.txt]] but not \"d:\\mycode.txt\" is that the latter's \\ will cause escape problem. You can use any postfix you want(*.lua, *.code, *.magic) as long as its contents are texts. Use following code to read the code file beside your Ae project file. loadTxt.lua version3() runFile( projectFolder .. [[mycode.txt]]) -- Replace to your file name Note: You should save your Ae project to local disc or the projectFolder is just an empty string. It is not over! Don't forget to refresh PixelsWorld If you saved your code file, PixelsWorld cannot read it immediatly. You should then hold Ctrl + Alt, click the logo image, this will trigger the rerender of PixelsWorld, then your new code will be read by PixelsWorld. The logo image here is appearing basing on a constant probability distribution. For artists who are crazy about collecting things, we have designed lots of beautiful logo image here. "},"contents/Lua/importantFuncs.html":{"url":"contents/Lua/importantFuncs.html","title":"Important functions","keywords":"","body":"Important functions There are some functions that we use most in PixelsWorld. Default code default_code.lua version3() in2out() move(width/2,height/2) version3() function must be called in the first line. It put all function that in the table pw3 to the global field. If you don't call it, you need to add a pw3. prefix to all the function provided by PixelsWorld. For instance, the following demonstrated function print() should be pw3.print(). On the contrary, If you call the function version3() in the first line, the pw3. prefix could be omitted. This function is designed for backward compatibility. We recommend calling version3() in the first line any time you use Lua render mode. in2out() copys the input image to the output. If you don't need input image but a pure color backgroud instead, call background(r,g,b,a)(RGBA range: 0~1). If you want your background to be empty, remove the in2out() function. move(x,y) moves the Paintbrush along vector (x,y). The default location of Paintbrush is (0,0), hence move(width/2,height/2) means move the Paintbrush to the middle of your scene. Remove this function if you don't need this moving. "},"contents/Lua/LinkParameters.html":{"url":"contents/Lua/LinkParameters.html","title":"Link parameters","keywords":"","body":"Link parameters parameters.lua slider(id) -- return 1 double angle(id) -- return 1 double point(id) -- return 2 double point3d(id) -- return 3 double checkbox(id) -- return 1 boolean color(id) -- return 3 double layer(id,x,y) -- return 4 double If there are more than one values returned, the corresponding number of variables need be declared to catch the values. For instance, the point() function: point.lua version3() x,y = point(0) -- Declear two variables x and y println('x is ' .. x) println('y is ' .. y) "},"contents/Lua/globals.html":{"url":"contents/Lua/globals.html","title":"Globals","keywords":"","body":"Globals Global constants Here are some global constants in PixelsWorld: const.lua PI -- the Circular constant pi TPI -- two pi HPI -- half pi QPI -- quarter pi E -- the Natural number e PHI -- the Golden ratio phi R2 -- square root 2 R3 -- square root 3 R5 -- square root 5 R7 -- square root 7 INPUT -- Index of input image -1 TEMP -- Index of temp image -2 OUTPUT -- Index of output image -3 PARAM0 -- Index of the #0 layer parameter 0 PARAM1 -- Index of the #1 layer parameter 1 PARAM2 -- Index of the #2 layer parameter 2 PARAM3 -- Index of the #3 layer parameter 3 PARAM4 -- Index of the #4 layer parameter 4 PARAM5 -- Index of the #5 layer parameter 5 PARAM6 -- Index of the #6 layer parameter 6 PARAM7 -- Index of the #7 layer parameter 7 PARAM8 -- Index of the #8 layer parameter 8 PARAM9 -- Index of the #9 layer parameter 9 platform -- Windows == 0, no other platforms. host -- Ae == 0, no other hosts. Global variables Here are some global variables in PixelsWorld: globalvars.lua depth -- Dpc: 8,16,32 width -- Width input image height -- Height input image time -- Current time(s) duration -- Duration of current layer(s) inpoint -- Inpoint of current layer(s) compTime -- Comp current time(s) pluginFolder -- The plugin folder(utf8) projectName -- Project name(utf8) projectPath -- Project path(utf8) projectFolder -- Project folder(utf8) ds_width -- Width of downsampled input image ds_height -- Height of downsampled input image Print the globals Globals can be printed by using following code: printGlobals.lua version3() in2out() for k, v in pairs(_G) do print(k) print(\" \" .. type(v) , .5,.5,.5) print(\" \".. tostring(_G[k]),0,1,1) println(\"\") end "},"contents/Lua/FuncList.html":{"url":"contents/Lua/FuncList.html","title":"Function list","keywords":"","body":"函数列表 以下是定义在PixelsWorld中Lua模式的所有函数。 必须声明函数 version3 获取参数函数 slider, angle, point, point3d, checkbox, color, layer 输出信息函数 print, println, alert, 变换函数 move, scale, rotate, rotateX, rotateY, rotateZ, twirl beginGroup, endGroup, beginGlobal, endGlobal 绘制函数 图元 tri, quad, rect, circle, ellipse, par, line cube, tet, cone, ball, tube image, coord, grid poly, setPoly background, in2out 绘制属性控制 dim2, dim3 perspective, noPerspective fill, noFill, stroke, noStroke, dot, noDot wireframe, noWireframe blendAlpha, noBlendAlpha back, noBack pure, phong, anime color, depth, normal setDepth 灯光 ambientLight, pointLight, parallelLight clearLight, getLight 摄像机 aeCamera, lookAt, viewSpace 描边细节 strokeWidth, strokeDivision, strokeGlobal, strokeLocal 点渲染细节 dotRadius, dotDivision, dotGlobal, dotLocal 输出细节 smooth, noSmooth 工具 r2d, d2r utf8ToLocal, localToUtf8 getGLInfo, getDrawRecord, getStatus getAudio 读写像素函数 getColor, setColor, getSize, 执行代码函数 shadertoy, glsl, cmd, lua, runFile, txt 详细介绍 version3 version3() 函数是Lua模式必须在第一行声明的函数。它的作用是把pw3这个表下的所有函数放到全局域中，如果没有这一行，您需要把所有PixelsWorld提供的函数前面加入pw3.前缀，比如之后会介绍的println()函数则需要写成pw3.println()。相反，如果您在第一行调用了version3()函数，则不需要写pw3.前缀。这是为了让您的代码能向后兼容而设计的函数。我们推荐（Lua渲染模式下的）任何情况下都在第一行加入version3()的调用。 version3.lua version3() println(\"Hello PixelsWorld! \") without_version3.lua pw3.println(\"Hello PixelsWorld! \") print print(str),print(str,brightness),print(str,r,g,b),print(str,r,g,b,a)是在屏幕左上角输出信息的函数。 print.lua version3() print(\"Hello PixelsWorld! \") str = \"Hello, I am colorful PixelsWorld! \" for i=1,#str do local c = str:sub(i,i) local phase = math.sin(i/#str*TPI + time*10) / 2 + .5 print(c,phase,1-phase,1,1) end println println(str),println(str,brightness),println(str,r,g,b),println(str,r,g,b,a)是在屏幕左上角输出信息的函数。并在每次输出信息后换行。 println.lua version3() println(\"Hello PixelsWorld! \") str = \"Hello, I am colorful PixelsWorld! \" for i=1,#str do local c = str:sub(i,i) local phase = math.sin(i/#str*TPI + time*10) / 2 + .5 -- println(c,phase,1-phase,1,1) print(c,phase,1-phase,1,1) end alert alert(str)是在屏幕左上角输出警示信息的函数。它目前等价于println(str,1,1,0,1) alert.lua version3() alert(\"Warning: Write your message here! \") move move(x,y),move(x,y,z)是平移画笔坐标的函数。 所有变换都是以当前画笔坐标为基准进行的。 例如下面这个例子： move.md version3() coord() -- 显示变换前的画笔位置 move(100,0) coord() -- 显示第1次变换后的画笔位置 move(0,100) coord() -- 显示第2次变换后的画笔位置 最终画笔会在(100,100,0)位置处。 scale scale(ratio),scale(x,y),scale(x,y,z)是缩放画笔坐标的函数。 所有变换都是以当前画笔坐标为基准进行的。 rotate rotateX rotateY rotateZ rotate(theta)是把画笔坐标旋转theta弧度的函数，rotateX(theta)则是把画笔坐标沿着其X轴旋转的函数，rotate(theta)本质等价于rotateZ(theta)。 所有变换都是以当前画笔坐标为基准进行的。 如果您不熟悉弧度，可以用函数d2r(degree)来把角度转成弧度。例如：rotate(d2r(90))则是旋转九十度。 twirl twirl(x,y,z,theta)是沿着(x,y,z)轴旋转theta弧度画笔的函数。比如，上面的rotateX(theta)则等价于这里的twirl(1,0,0,theta)。 所有变换都是以当前画笔坐标为基准进行的。 twirl是对四元数旋转的一种矩阵实现。 beginGroup endGroup beginGroup(),endGroup()是创建父子级关系的函数。beginGroup()到endGroup()之间的变换(move,scale,rotate,twirl)在endGroup()之后会被撤销掉。 它等价于Processing中的pushMatrix()和popMatrix() 例如：下面两块代码是等价的 group.lua version3() for i = 1,10 do beginGroup() move(i*100,i*100) rotate(d2r(45*i)) rect(50) endGroup() end without_group.lua version3() for i = 1,10 do move(i*100,i*100) rotate(d2r(45*i)) rect(50) rotate(d2r(-45*i)) move(-i*100,-i*100) end beginGlobal endGlobal 夹在beginGlobal,endGlobal之间的绘图函数 将暂时以全局坐标系绘制 beginGlobal.lua version3() move(100,100) fill(0,1,0) -- green rect(50) -- Dran on (100,100,0) beginGlobal() fill(1,0,0) -- red rect(50) -- Draw on (0,0,0) endGlobal() move(100,100) fill(0,0,1) -- blue rect(50) -- Draw on (200,200,0) tri tri(radius)以半径为radius的圆做一个内接正三角形，并指向画笔坐标y轴正方向。 tri()等价于tri(100) tri(w,h)以底边为w高为h做一个等腰三角形。 tri(p1x,p1y,p2x,p2y,p3x,p3y)以p1,p2,p32个二维点为顶点做三角形 tri(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z)以p1,p2,p33个三维点为顶点做三角形 如果想要观察三维三角形，请在version3()函数后加入dim3()，并在Ae图层中建立摄像机观测。 前3种方式构造的三角形的法线默认为画笔坐标z轴负方向，后2种方式构造的三角形则以cross(p1-p2,p3-p2)定几何法线。 函数名为triangle的缩写 tri1.lua version3() move(width/2,height/2) tri(100) tri5.lua version3() dim3() move(width/2,height/2) tri(0,0,100,50,0,0,0,50,0) quad quad(p1x,p1y,p2x,p2y,p3x,p3y,p4x,p4y) quad(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z,p4x,p4y,p4z) 以p1,p2,p3的顺序绘制第一个三角形，以p1,p3,p4的顺序绘制第二个三角形。 rect rect(size)绘制size尺寸的正方形 rect()等价于rect(100) rect(width,height)绘制长width高height的长方形 长方形将以画笔坐标中心为对角线交点生成。 函数名为rectangle的缩写 circle circle(size)绘制一个半径为size的圆 circle()等价于circle(100) circle(size, div)绘制一个半径为size，分段数为div的圆。 默认分段为128 ellipse ellipse(width,height)绘制一个长width宽height的椭圆 ellipse()等价于ellipse(100,100) ellipse(width,height,div)绘制一个长width宽height分段div的椭圆 默认分段为128 line line(p1x,p1y,p2x,p2y)绘制一条线段 line(p1x,p1y,p1z,p2x,p2y,p2z)绘制一条三维线段 line()等价于line(0,0,0,100,100,100) 线的颜色是由stroke(r,g,b)控制的。 线的粗细是由strokeWidth(width)控制的 线默认是被渲染出来的，屏蔽线渲染请使用noStroke()，开启线渲染则用stroke() par par(x) 绘制一个半径为位置为(x,0,0)的点 par(x,y) 绘制一个半径为位置为(x,y,0)的点 par(x,y,z) 绘制一个半径为位置为(x,y,z)的点 par()等价于par(0,0,0) 点渲染默认是关闭的，请使用dot()打开。并且您随时可以调用noDot()关闭它 点的半径由dotRadius(radius)控制 点的颜色由dot(r,g,b)控制 如果您不想让点被变换压扁或者缩小，使用dotGlobal()。默认情况下点是在dotLocal()模式下渲染的。 cube cube(size)绘制一个边长为size的正方体 cube(sizex,sizey,sizez)绘制一个长宽高sizex,sizey,sizez的长方体 cube()等价于cube(100) cube() 长方体的法线默认是朝外的，如果输入负数长度、或者使用了带负号的scale()函数会导致法线向内 tet tet(radius)以radius为球面半径绘制一个内接正四面体 tet()等价于tet(50) tet(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z,p4x,p4y,p4z)以p1,p2,p3,p4为顶点绘制一个四面体 第三项绘制的四面体的法线根据绘制顺序而定，具体为：p1,p2,p3;p2,p1,p4;p3,p2,p4;p1,p3,p4.的顺序依次绘制四个三角面。关于三角面的法线方向请参考tri 函数名为tetrahedron的缩写 cone cone(size)以2*size为高，size为底边半径绘制一个圆锥 cone()等价于cone(50) cone(radius,height)以radius为半径，height为高绘制一个圆锥 cone(radius,height,div)以radius为半径，height为高绘制一个分段为div的圆锥 圆锥默认分段为64 当分段大于16时会隐藏锥面描边和底边顶点 负数的输入值或带负号的scale()有可能导致法线向内 ball ball(radius)以半径radius绘制一个三维球体 ball()等价于ball(50) ball(radius,level)以半径radiu和level细分等级绘制一个球体 默认level为4 level必须大于等于0 level等于0时为正八面体 level大于2时将隐藏描边和顶点 负数的输入值或带负号的scale()有可能导致法线向内 tube tube(size)绘制一个底面半径size、高2*size的圆柱体 tube()等价于tube(50) tube(radius,height)绘制一个半径为radius、高为height的圆柱体 tube(radius1,radius2,height)绘制一个靠近绘笔坐标原点底面半径为radius1、远离一侧底面半径为radius2、高为height的圆柱体 tube(radius1,radius2,height,div)在第3个函数基础上多了分段的控制。 tube(radius1,radius2,height,div,needMesh)在第4个函数基础上多了“是否要渲染两个圆面”的boolean tube(radius1,radius2,height,div,needMesh1,needMesh2)在第4个函数基础上，多了“是否要渲染近侧底面”的needMesh1和“是否要渲染远侧底面”的needMesh2，两者皆为boolean。 div默认值为64 needMesh默认值为true 当分段大于16时会隐藏柱面描边和两底边顶点 负数的输入值或带负号的scale()有可能导致法线向内 image image(id,width,height)以长度为width,高为height绘制一张图片到场景上 id是材质编号，PARAM0~PARAM9是您插件面板上的图层控件获得的材质，INPUT是输入插件的输入图像，OUTPUT是输出图像。 当您指定id为OUTPUT时，因为OUTPUT是您当前正绘制的充当绘板的材质，所以会发生一次绘板的截屏行为。因此会比其它参数稍慢一些。 这个函数与in2out(id)的区别是，image(id,width,height)会根据绘笔坐标生成一个与场景深度信息互动的图片。这意味着：图片默认绘制出来是上下颠倒的，因为Ae默认的坐标系y轴向下，您需要在前面加入一行rotateX(PI)来转正（我们不推荐使用scale(1,-1),这将会导致其它后续绘制图形出现法线错误）；而in2out(id)则是忽略深度信息，直接把像素写到当前绘板中（并且没有上下颠倒问题）。 下面这个例子将演示一个与输入图片穿插交互的立方体 render_image.lua version3() dim3() move(width/2,height/2) beginGroup() rotateX(PI) image(INPUT,width,height) endGroup() rotateX(QPI * time) rotateY(QPI * time) cube() coord coord()将把当前绘笔坐标可视化出来。 grid grid()将把当前绘笔坐标所在的xy平面以100x100网眼大小的的网格可视化出来。 setPoly setPoly(obj)可以提前解析要绘制的物体信息，您在设置后可以调用poly()来快速绘制刚刚设置的物体。 关于obj的构造请前往Poly章节 background background(brightness),background(r,g,b),background(r,g,b,a)将当前绘板涂成对应颜色。 注意：如果您之前绘制过形状，这些形状会被覆盖。 in2out in2out(id)会把第id个层参数设为背景。 in2out()等价于in2out(INPUT)，它负责把输入层当做背景。 dim2 dim2()将使用2D模式绘图，这一项默认是开启的，一般您无需调用。 本质PixelsWorld中的2D模式是没有深度信息的正交3D模式。 dim3 dim3()将使用3D模式绘图。我们推荐声明在紧随version3()之后的地方。 perspective perspective()将使用透视视图渲染，物体将符合近大远小规则，您可以使用viewSpace来调整摄像机信息、使用lookAt来调整摄像机位置。 这一项默认是开启的，一般您无需调用。 noPerspective noPerspective()将使用正交视图渲染，物体互相平行的边缘在渲染视图中也将平行。 fill fill()将开启填充。默认开启。 fill(brightness),fill(r,g,b),fill(r,g,b,a)将开启填充并设置填充色。 注意：在3D模式中，如果您将填充的透明值设为小于1的数的时候，请使用由远到近的顺序渲染物体，否则前面的透明物体会完全遮挡住后面的物体。（这是OpenGL绘图的一个特性） noFill noFill()将关闭填充。 stroke stroke()将开启描边。默认开启。 stroke(brightness),stroke(r,g,b),stroke(r,g,b,a)将开启描边并设置描边色。 noStroke noStroke()将关闭描边。 dot dot()开启顶点渲染。默认关闭。 dot(brightness),dot(r,g,b),dot(r,g,b,a)将开启顶点渲染并设置顶点渲染颜色。 noDot noDot()将关闭顶点渲染。 wireframe wireframe()将开启线框模式。 noWireframe noWireframe()将关闭线框模式。 blendAlpha blendAlpha()将开启混色。 noBlendAlpha noBlendAlpha将关闭混色。 back back()填充含透明色的时候，将显示物体背面。默认关闭。 noBack noBack()关闭背面渲染模式。 pure pure()将使用纯色模式渲染场景。默认开启。 anime,phong,pure是三种不能同时应用的材质，您在打开其中一个的时候另外两种会被关掉。 phong phong(ambient,diffuse,specular,specularPower)将切换到phong模式，并把环境光反射强度设为ambient、亮面漫反射强度设为diffuse、高光强度设为specular。specularPower负责设置高光衰减量级，该项越大，高光衰减越快。 phong()将切换到phong材质模式。不改动设置。 默认场景是没有任何光源的，所以您需要使用getLight()，或ambientLight()、parallelLight()、pointLight来获取光源。 如果在有光源的前提下渲染出来的物体仍然是纯黑色，调用normal请检查法线是否正确。 每一项参数初始值为：ambient:1,diffuse:1,specular:1,specularPower:1 anime,phong,pure是三种不能同时应用的材质，您在打开其中一个的时候另外两种会被关掉。 请在使用前执行dim3() anime anime(ambient,diffuse,specular,specularPower,diffuseThreshold,specularThreshold) anime()将切换到动漫材质模式。不改动设置。 anime材质是在phong的基础上做的。因此前四项参数：ambient,diffuse,specular,specularPower与phong相同，剩余两项diffuseThreshold负责设置漫反射的阈值，当漫反射亮度超过阈值时则设为亮面，低于阈值时则设置为暗面。同理，specularThreshold负责高光的阈值。 anime材质对抗锯齿进行了优化，如果您开启了抗锯齿（默认开启），那么光影过渡边缘会被抗锯齿处理。关闭插件面板的抗锯齿设置可以关闭光影边缘的抗锯齿处理。 每一项参数初始值为：ambient:1,diffuse:1,specular:1,specularPower:1,diffuseThreshold:0.5,specularThreshold:0.8 anime,phong,pure是三种不能同时应用的材质，您在打开其中一个的时候另外两种会被关掉。 请在使用前执行dim3() color color()RGBA直接输出模式，默认开启。 color,depth,normal是三个不能同时成立的模式，您在打开其中一项的时候另外两项会被关掉。 这个模式可以使用材质。 depth depth(blackDistance, whiteDistance)是把深度当做亮度信息输出的模式。例如您想输出一张深度图，可以指定blackDistance和whiteDistance来设置距离摄像机多远的时候输出黑色或白色。对于之间的距离，像素世界会做线性插值成灰色。当您把blackDistance和whiteDistance设为同一数值时，像素世界会把您设置的数值当做阈值来输出纯黑色或纯白色。 color,depth,normal是三个不能同时成立的模式，您在打开其中一项的时候另外两项会被关掉。 这个模式会无视材质。 请在使用前执行dim3() normal normal(faceToCamera, normalize)切换到normal模式，修改faceToCamera和normalize变量 normal(faceToCamera)切换到normal模式，只修改faceToCamera变量 normal()只负责切换到normal模式 faceToCamera是一个布尔值，用来控制normal是否以摄像机视角为基准生成。 normalize是一个布尔值，用来指定是否输出标准化(长度做成1)后的normal 初始值：faceToCamera:true, normalize:true。 color,depth,normal是三个不能同时成立的模式，您在打开其中一项的时候另外两项会被关掉。 这个模式会无视材质。 请在使用前执行dim3() setDepth setDepth(id,blackDistance,whiteDistance)可以读取id上的材质的红色通道，并把通道值为0的地方设为blackDistance，通道值为1的地方设为whiteDistance，再把材质应用到深度测试材质上。 您可以把从3D软件中渲染的深度序列通过这个函数导入像素世界，这样像素世界能和 请在使用前执行dim3() 有效的id: INPUT,PARAM0~PARAM9 ambientLight ambientLight(r,b,g,intensity) ambientLight()等价于ambientLight(1,1,1,1) ambientLight(brightness)等价于ambientLight(brightness,brightness,brightness,1) ambientLight(brightness,intensity)等价于ambientLight(brightness,brightness,brightness,intensity) ambientLight(r,g,b)等价于ambientLight(r,b,g,1) 生成一个环境光，对场景内所有物体有效。 这个光可以无视物体法线方向，即使法线方向反向仍能照亮物体。 pointLight pointLight(r,g,b,intensity,radius,smoothWidth) pointLight()等价于pointLight(1,1,1,1,1000,1000) pointLight(brightness,intensity)等价于pointLight(brightness,brightness,brightness,intensity,1000,1000) pointLight(r,g,b)等价于pointLight(r,g,b,1,1000,1000) pointLight(r,g,b,intensity)等价于pointLight(r,g,b,intensity,1000,1000) pointLight(r,g,b,intensity,radiusAndSmoothWidth)等价于pointLight(r,g,b,intensity,radiusAndSmoothWidth,radiusAndSmoothWidth) 在当前绘笔坐标原点处生成一个点光源。 这个光受物体法线方向影响，法线方向的物体不会产生漫反射和高光，但仍能接受点光源产生的环境光。 radius为点光源的光照半径，radius到radius+smoothWidth之间光照强度会衰减。 parallelLight parallelLight(r,g,b,intensity,tx,ty,tz) 在全局范围内生成一个方向为(tx,ty,tz)的平行光。 clearLight clearLight()清除场景中的所有灯光。 getLight getLight(matchName) getLight()等价于getLight(\"*\") 获取当前合成符合matchName名字的灯光。 matchName规则：当字符串末尾不含*时，会在Ae当前合成的图层中搜寻名字为matchName的灯光并加入场景中；当末尾含有*时，则会把所有开头为matchName的灯光全部加入场景中。 目前支持的Ae灯光类型：ambient,point,parallel aeCamera aeCamera()把Ae当前场景摄像机当做像素世界的场景摄像机。 lookAt lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ,upVecX,upVecY,upVecZ)用来设置摄像机位置和朝向 lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ)等价于lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ,0,-1,0) eyePos是您眼睛的位置，objPos是您想看的目标物体的位置，upVec是您头顶的指向。 注意Ae的Y轴默认是朝下的，一般您需要让upVec为(0,-1,0)。 eyePos和objPos不能太近（推荐两者距离不低于1e-7）。 upVec不能和您的视线平行。 upVec长度不能太小。 viewSpace viewSpace(width,height,distanceToPlane,farLevel) viewSpace(width,height,distanceToPlane)等价于viewSpace(width,height,distanceToPlane,4) width和height为摄像机远平面的尺寸 摄像机到摄像机远平面的垂直距离为distanceToPlane farLevel * distanceToPlane为最远平面的距离，超过这个距离的物体将不被渲染。通常设为4足够，若您的场景十分大，可以把这个数值设高一些，这个数值只会影响远处的物体是否被渲染。若您把这个数值设定的过高可能会影响近处物体的深度测试精度。 strokeWidth strokeWidth(width)来设置描边粗细 默认值：2 strokeDivision strokeDivision(level)来设置描边细分等级 默认值：3 strokeGlobal strokeGlobal()以全局模式绘制线，线的粗细不受scale影响。 默认值是局部模式 strokeLocal strokeLocal()以局部模式绘制线，线的粗细将受scale影响。 默认值是局部模式 dotRadius dotRadius(radius)来设置点粗细 默认值：2 dotDivision dotDivision(level)来设置点的细分等级。（非负整数，最大为7） 默认值：3 strokeGlobal strokeGlobal()以全局模式绘制点，点的半径不受scale影响。 默认值是局部模式 strokeLocal strokeLocal()以局部模式绘制点，点的半径将受scale影响。 默认值是局部模式 smooth smooth()以抗锯齿模式绘制。 默认开启 在插件面板上可以修改抗锯齿强度 noSmooth noSmooth()以非抗锯齿模式绘制。 不推荐和smooth混用。 这个函数的优先级大于插件面板上的抗锯齿设定。 r2d r2d(degrees)角度转弧度，返回弧度 d2r d2r(radians)弧度转角度，返回角度 utf8ToLocal utf8ToLocal(str)把unicode字符串转为本地字符串，返回本地编码的字符串 如果您在使用Lua的io模块，发现某个路径含有utf8字符的文件读不了的话，请用这个函数转换路径编码。 localToUtf8 localToUtf8(str)把本地字符串转为unicode字符串，返回unicode编码字符串 getGLInfo getGLInfo()获取当前显卡的信息。 getDrawRecord getDrawRecord(needStringFormat)将输出当前场景的绘制记录信息。needStringFormat是一个布尔值，true时输出字符串，false输出一个Lua表。 getDrawRecord()等价于getDrawRecord(true) printDrawRecord.lua version3() move(width/2,height/2) dim3() cube() println(getDrawRecord()); getStatus getStatus(needStringFormat)可以输出当前绘笔信息，needStringFormat是一个布尔值，true时输出字符串，false输出一个Lua表。 getStatus()等价于getStatus(true) printDrawRecord.lua version3() move(width/2,height/2) dim3() cube() println(getStatus()); getAudio getAudio(startTime,duration,id,sampleRate)将索取音频信息，返回四个表，两个波形采样表（左右声道）和两个由波形计算的频谱表（左右声道）。 getAudio(startTime,duration)等价于getAudio(startTime,duration,INPUT,44100) getAudio(startTime,duration,id)等价于getAudio(startTime,duration,id,44100) 左声道波形 (-1~1) 右声道波形 (-1~1) 左声道频谱 (0~正无穷) 右声道频谱 (0~正无穷) waveInfo.lua version3() background(0.2) local wl,wr,fl,fr = getAudio(time-0.1,0.2) local nm = math.floor(height/8); for i=1,nm do local wid =math.max(math.floor(i/nm*#wl),1) local fid = math.max(math.floor(i/nm*#fl/16),1) print(string.format(\"%8.5f\",wl[wid]),1,wl[wid]*4,0,-wl[wid]*4) print(\" \",1,0,0,0) print(string.format(\"%8.5f\",wr[wid]),1,wr[wid]*4,0,-wr[wid]*4) print(\" \",1,0.5,0.5,0.5) print(string.format(\"%8.5f\",fl[fid]),1,fl[fid]/math.sqrt(#fl),0,0) print(\" \",1,0,0,0) print(string.format(\"%8.5f\",fr[fid]),1,0,0,fr[fid]/math.sqrt(#fr)) println(\"\"); end getColor getColor(id,x,y)返回id材质处的(x,y)坐标处的像素值，返回r,g,b,a四个双精度浮点数。 getColor(x,y)等价于getColor(INPUT,x,y) 在绘制一切场景前使用getColor时(即在version3()紧接着的后面)，这个函数的效率是最高的，如果您在绘制场景时使用getColor时这个函数效率十分低下，因为Lua是工作在CPU上的，绘制场景时，所有的材质都会送入您的显卡，在显卡和CPU之间通信的时间成本会很高。 有效id为INPUT,OUTPUT,PARAM0~PARAM9 setColor setColor(x,y,r,g,b),setColor(x,y,r,g,b,a)会设置id材质处的(x,y)坐标处的像素值。 在绘制一切场景前使用setColor时(即在version3()紧接着的后面)，这个函数的效率是最高的 getSize getSize(id)返回id材质的尺寸 当您改变场景降采样（例如二分之一，四分之一）后，返回的尺寸会有0~4像素的抖动，这是由Ae的降采样机制产生的特性。但这个抖动不会随时间变化。在降采样关闭时，这个函数保证返回正确的图层尺寸。 shadertoy shadertoy(code)执行来自shadertoy的代码。 不是所有的shadertoy代码都被支持 glsl glsl(code)执行Fragment阶段代码 cmd cmd(code)执行cmd指令 如果命令成功运行完毕，第一个返回值就是 true，否则是 nil。在第一个返回值之后，函数返回一个字符串加一个数字。如下： \"exit\": 命令正常结束； 接下来的数字是命令的退出状态码。 \"signal\": 命令被信号打断； 接下来的数字是打断该命令的信号。 lua lua(code)执行Lua代码 runFile runFile(utf8_path)把本地文件当做txt文件读取，并当做Lua代码执行。 txt txt(utf8_path)把本地文件当做txt文件读取，并返回字符串。 "},"contents/Lua/Poly.html":{"url":"contents/Lua/Poly.html","title":"Poly function","keywords":"","body":"Creation origin: Poly function poly(obj) analyzes the input Obj, then draws it to scene. Usage If you are familiar with Houdini, the idea of construct an obj is basically to fill a SpreadSheet. Here is an example of constructing an obj of an unusual colorful triangle. PolyTest1.lua version3() background(0.95) move(width/2,height/2) dim3() dotRadius(5) obj={ point={ {p={0,0,0},color={0,1,1}}, {p={100,0,0},color={1,1,0}}, {p={0,100,0},color={1,0,1}}, {p={100,100,0},color={1,0,0}}, }, prim={ {type=\"triangle\",pref={1,2,3}}, {type=\"line\",pref={2,3,3,4,4,2}}, {type=\"point\",pref={2,4}}, } } poly(obj) The structure of obj The obj struction is defined by following steps: obj is a table. obj contains 4 keys: point,vertex,prim,detail. The 4 keys in obj have their own value called pointArray,vertexArray,primArray,detailList. pointArray is required. vertexArray is optional. primArray is required. detailList is optional. The above-mentioned value names that are Array suffixed holds N sub-tables, where N can be defined by users. The kth sub-table of pointArray is called point[k] or \"The kth point\". The kth sub-table of vertexArray is called vertex[k] or \"The kth child-point\". The kth sub-table of primArray is called prim[k] or \"The kth primitive\". The detailList and Points, child-points, primitives, has some unsubdividable units：the Key-value pairs. We call these keys K, and values V. K should only contains alphabets, numbers and underlines. And K shouldn't be all numbers. V has 7 types: 1D, 2D, 3D, 4D, string, texture id and index serial. For all double floating numbers x,y,z,w x or {x} is 1D V. {x,y} is 2D V. {x,y,z} is 3D V. {x,y,z,w} is 4D V. \"Hello! PixelsWorld!\" is string V. When (K ends up with \"_tex\" or K equals to \"texture\") and (V is integer and the corresponding texture exists), it is texture id V. For integer serial a1,...,an,{a1,a2,a3,...,an} is index serial V. For all point[k], there must be a K named \"p\" to represents the location, or it is a invalid point. For all vertex[k], there must be a K named \"pref\" and its V is integer to represent the reference point id, or it is an invalid child-point. For all prim[k], there must be a K named \"type\" and its V is string to represents the type of the primitive. And there also must be a K named \"vref\"or \"pref\" and its V is index serial to represent the order of points drawing. Override priority For same K, the following override priority is defined: Same with Houdini. vertex point prim detail Example: The following obj's prim contains color attribute (Red), So we will get a red triangle. PrimColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0}}, {p={100,0,0}}, {p={0,100,0}}, }, prim={ {type=\"triangle\",pref={1,2,3},color={1,0,0}}, }, } poly(obj) This time, both prim and point contains color, and because the priority of point is higher, so the color attribute in pointwill be used, then we will get a colorful triangle. PointColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},color={0,1,1}}, {p={100,0,0},color={1,1,0}}, {p={0,100,0},color={1,0,1}}, }, prim={ {type=\"triangle\",pref={1,2,3},color={1,0,0}}, }, } poly(obj) Usage of vertex Vertex (child-point) inherits all attributes in point. VertexColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0}}, {p={100,0,0}}, {p={0,100,0}}, {p={100,100,0}}, }, vertex={ {pref=1,color={1,0,0}}, {pref=2,color={1,0,0}}, {pref=3,color={1,0,0}}, {pref=2,color={0,1,0}}, {pref=3,color={0,1,0}}, {pref=4,color={0,1,0}}, }, prim={ {type=\"triangle\",vref={1,2,3,4,5,6}}, }, } poly(obj) pref is used to defined which point to be referenced, the full name of pref is Point reference. So the vref means Vertex reference. Note: The index in Lua starts from 1 not 0. Without vertex, the triangle looks like this: NoVertex.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},color={1,0,0}}, {p={100,0,0},color={1,0,0}}, {p={0,100,0},color={1,0,0}}, {p={100,100,0},color={0,1,0}}, }, prim={ {type=\"triangle\",pref={1,2,3,2,3,4}}, }, } poly(obj) Extra shader Yes! You even can write shader in an obj. FragColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},myattribute={1,0}}, {p={100,0,0},myattribute={0,1}}, {p={0,100,0},myattribute={0,0}}, {p={100,100,0},myattribute={1,1}}, }, prim={ { type=\"triangle\", pref={1,2,3,2,3,4}, frag=[==[ #define t ]==] .. tostring(time) .. [==[ void main(){ outColor = vec4(mod(myattribute*10+vec2(t),1),0,1); } ]==], }, }, } poly(obj) "},"contents/Lua/RunGLSL.html":{"url":"contents/Lua/RunGLSL.html","title":"Run GLSL in Lua","keywords":"","body":"Run GLSL in Lua Usage glsl.lua version3() glsl(Your_code_string_here) Note: We recommend using [==[Your_code_string_here]==] to quote your string on account of avoiding escape characters. Namely, your code should be like: glsl2.lua version3() glsl([==[ void main(){ outColor = vec4(uv,sin(time*10)/2+.5,1); } ]==]) The following function can run the code from shadertoy.com. shadertoy.lua version3() shadertoy(Your_shadertoy_code_here) "},"contents/GLSL/GLSLCode.html":{"url":"contents/GLSL/GLSLCode.html","title":"GPU Berserker GLSL","keywords":"","body":"GPU Berserker GLSL In this section, we will have a quick look at how the GLSL works in PixelsWorld. What is GLSL? GLSL is an abbreviation of OpenGL Shader Language, which is supported by OpenGL, run on GPU. In short GLSL is what we used in section one, it can run on GPU. Advantage of GPU render If we treat CPU as a supercar, the GPU should be more like a bus. In the case we transport little people, like one or three, the supercar would be nice. (Handle single complicated calculation) But when there are thousands of people need to be transported, it seems that the bus should be the right option. (Render thousands of data symultaneously) The language we are learning, like C/C++, Java, Python, almost are running on CPU. Languages like GLSL, is designed for GPU. When we are about to render a picture. GPU can distribute one repetitive task to a number of \"workers\". If you want to learn more about GLSL, we recommand you to go to shadertoy.com, find some interesting arts and make out why this works. Details Before the GLSL is sent to OpenGL, PixelsWorld will combine pre-defined and post-defined codes to support features of Ae. If you are beginner, you can ignore this section for the moment. PixelsWorld V2.0 use #version 330 core. Here are pre-defined and post-defined codes. "},"contents/GLSL/GetStart.html":{"url":"contents/GLSL/GetStart.html","title":"Quick start","keywords":"","body":"What it feels like to develop effects with PixelsWorld? PixelsWorld is just like Microsoft Excel. You write function, it will handle the data in the form for you. If we treat the data in form as input pixels, the calculated form as output pixels, Codes in PixelsWorld is the function in Microsoft Excel E.g. Make picture brighter To make a picture brighter, the simplest approach is just add the R,G,B by a number. If in Excel, we need to do something like this: Then we have made all pixels data \"brighter\" ! Here is what we need to write in PixelsWorld: bright_describe.shader outColor=getColor(uv)+vec4(0.2); It means: Get the input pixels (getColor) in current location (uv), and add the 4D vector RGBA by (0.2,0.2,0.2,0.2) (+vec4(0.2)). Finally, send (=) the result to the output pixel(outColor). But if we only write this single line, PixelsWorld cannot work fine. We need to add this line inside a \"shell\" to make it work. The complete version is this: bright.shader void main(){ outColor=getColor(uv)+vec4(0.2); } How to input codes Input picture (Right click to save) (Source artist) Result Add more controls! Mostly we don't just add 0.2 to the picture. We want it to be more controllable. So we can replace the 0.2 to slider[0]. In this way, we can change the value in Parameters panel to change the brightness of your picture. bright_control.shader void main(){ outColor=getColor(uv)+vec4(slider[0]); } But you can find that, if the value is negative, the picture will be transparent, we don't want this happened. Namely we need to avoid modifying the Alpha channel of the picture. bright_control.shader void main(){ vec4 inColor = getColor(uv); inColor.rgb = inColor.rgb + vec3(slider[0]); outColor = inColor; } It means: Save the input pixel into a temporary variable inColor, Add the value of slider[0] to the RGB of inColor, then send the inColor to the outColor. Add label to the parameter Save to preset Finally, we can save the code as a preset for next using. Go to the Preset management to learn more details. Congratulations! You have already mastered the most part of PixelsWorld! In addition to writing codes by yourself, you can go to the shadertoy, find some interesting code and run it in PixelsWorld. See this to learn how to use code from shadertoy. "},"contents/GLSL/RunGLSL.html":{"url":"contents/GLSL/RunGLSL.html","title":"Run GLSL","keywords":"","body":"Run GLSL Code Make sure you are in GLSL(GPU) mode; Then edit the World rule; You will see there is already some code in the showed up panel; default.shader void main(){ outColor = getColor(uv); } This code is just send the input pixels to the output. You can change the getColor(uv) to vec4(uv,0.0,1.0) for geting a beautiful uv color pattern; uvcolor.shader void main(){ outColor = vec4(uv,0.0,1.0); } Then, press the \"Ok\" button. If everything is right, you will get something in the scene like this: "},"contents/GLSL/Functions.html":{"url":"contents/GLSL/Functions.html","title":"Functions","keywords":"","body":"Functions This section will give a brief introduction of the functions created by us. The functions mentioned in this section could be immediately used without any declaration. "},"contents/GLSL/getColor.html":{"url":"contents/GLSL/getColor.html","title":"getColor","keywords":"","body":"getColor This function has two versions: getColor(vec2) and getColor(int ,vec2). getColor(vec2) Description : Get the color of inLayer in specified position. Parameters : vec2 : uv position. Return : vec4 : a RGBA color. getColor(int,vec2) Description : Get the color of specified layer in specified position. Parameters : int : layer id, -1 (or AE_INPUT_LAYER) means inLayer, number between 0 and 9 means the corresponding Layer Parameter in your plugin panel. (PW_TEMP_LAYER (which is -2) is provided in Lua render mode) vec2 : uv coordinates. Return : vec4 : a RGBA color. NOTE : So in other words, getColor(AE_INPUT_LAYER,uv); totally equals to getColor(uv); getColor(n,uv); can return the pixels of layer[n]. "},"contents/GLSL/uvxy.html":{"url":"contents/GLSL/uvxy.html","title":"uv2xy,xy2uv","keywords":"","body":"uv2xy,xy2uv This two functions can translate a vec2 between UV Coordinate and XY Coordinate. It just do some multiplication and division for you. uv2xy(vec2) Description : Calculate the xy position for a given uv position. Parameters : vec2 : uv position. Return : vec2 : xy position. NOTE : If your layer size is 1280 x 720. The uv2xy(vec2(0.1,0.5)); will return vec2(128.0,360.0); xy2uv(vec2) Description : Calculate the uv position for a given xy position. Parameters : vec2 : xy position. Return : vec2 : uv position. NOTE : If your layer size is 1920 x 1080. The xy2uv(vec2(192,108)); will return vec2(0.1,0.1); "},"contents/GLSL/LinkParameters.html":{"url":"contents/GLSL/LinkParameters.html","title":"Link parameters","keywords":"","body":"Link parameters The outside parameters are provided for you to do some animation. As you can see, there are 7 types of parameters are provided. Sliders Angles Points 3D Points Checkboxes Colors Layers Each of them have 10 controler for using. Example : link_slider.shader void main(){ outColor = vec4(uv,slider[0],1.0); } If you change the slider 0, the color in your scene would change. Details The parameters decleared in PixelsWorld are as below : parameters.shader uniform float slider[10]; uniform float angle[10]; uniform bool checkbox[10]; uniform vec2 point[10]; uniform vec3 point3d[10]; uniform vec4 color[10]; uniform sampler2D layer[10]; uniform sampler2D inLayer; NOTE : The \"inLayer\" means Input layer. The sampler2D is a value type provided by GLSL, you don't need to understand this value type. If you want to use the layer parameter. Please see the \"getColor\" section \"uniform\" means global value. "},"contents/GLSL/debug.html":{"url":"contents/GLSL/debug.html","title":"Debug","keywords":"","body":"Debug Check the debug checkbox in the plugin panel. If your program contains errors, it will be printed into left top corner of your screen when this is checked. "},"contents/GLSL/Advanced_settings.html":{"url":"contents/GLSL/Advanced_settings.html","title":"Advanced settings","keywords":"","body":"Advanced settings There are several advanced settings in the effect panel. Language It controls which compiler to be used. Wrap U/V sampler This will affect the result of getColor() when sampler the pixels which is outside the boundary of image. Test code (Apply PixelsWorld to a footage.): wrap_uv_sampler.shader void main(){ outColor = getColor(uv*10); } Magnify/Minify sampler This will affect the behavior of getColor() when sampler want to do the interpolation of surrounding pixels. Test code (Apply PixelsWorld to a footage.): wrap_uv_sampler.shader void main(){ outColor = getColor(uv*0.1); } If you want to build the same pixel style effect. Swith this option to Nearest pixel "},"contents/GLSL/predefined.html":{"url":"contents/GLSL/predefined.html","title":"Pre-defined code","keywords":"","body":"Predifined code Before run shader code, PixelsWorld conbine your input with some predifined code to support some features. GLSL mode only has pre-define code. shadertoy mode has both pre-define and post-define code. GLSL mode Pre-define code pre_frag_shader_glsl.frag #define gl_Position uv2xy(uv) #define gl_FragCoord uv2xy(uv) #define gl_FragColor outColor #define INPUT_LAYER_INDEX -1 #define OUTPUT_LAYER_INDEX -2 #define AE_INPUT_LAYER -1 #define PW_TEMP_LAYER -2 out vec4 outColor; in vec2 uv; uniform float slider[10]; uniform float angle[10]; uniform bool checkbox[10]; uniform vec2 point[10]; uniform vec3 point3d[10]; uniform vec4 color[10]; uniform sampler2D layer[10]; uniform vec2 layerResolution[10]; uniform sampler2D inLayer; uniform sampler2D outLayer; uniform float time; uniform float inpoint; uniform float duration; uniform float comp_time; uniform vec4 date; uniform float fps; uniform float width; uniform float height; uniform vec2 origin; uniform vec2 resolution; uniform vec2 downsample; uniform mat4 camera_matrix; uniform vec4 camera_info; // x,y: resolution, z: distance to plane, w: distance to focus. uniform bool camera_perspective; uniform sampler1D inWaveL; uniform sampler1D inWaveR; uniform float inWaveN; uniform float inWaveS; uniform sampler1D inSpecL; uniform sampler1D inSpecR; uniform float inSpecN; vec4 getColor(int layerId,vec2 coord) { if(layerId==AE_INPUT_LAYER) return texture(inLayer,coord); if(layerId==PW_TEMP_LAYER) return texture(outLayer,coord); else if(layerId>=0 && layerId shadertoy mode Pre-define code pre_frag_shader_shadertoy.frag #define gl_Position (_PixelsWorld_uv * iResolution.xy) #define gl_FragCoord (_PixelsWorld_uv * iResolution.xy) #define gl_FragColor _PixelsWorld_outColor uniform vec3 iResolution; uniform float iTime; uniform float iTimeDelta; uniform int iFrame; // uniform float iChannelTime[4]; uniform vec4 iMouse; uniform vec4 iDate; uniform sampler2D iChannel0; uniform sampler2D iChannel1; uniform sampler2D iChannel2; uniform sampler2D iChannel3; uniform vec3 iChannelResolution[4]; #define INPUT_LAYER_INDEX -1 #define OUTPUT_LAYER_INDEX -2 uniform float _PixelsWorld_slider[10]; uniform float _PixelsWorld_angle[10]; uniform bool _PixelsWorld_checkbox[10]; uniform vec2 _PixelsWorld_point[10]; uniform vec3 _PixelsWorld_point3d[10]; uniform vec4 _PixelsWorld_color[10]; uniform sampler2D _PixelsWorld_layer[10]; uniform vec2 _PixelsWorld_layerResolution[10]; uniform sampler2D _PixelsWorld_inLayer; uniform sampler2D _PixelsWorld_outLayer; uniform float _PixelsWorld_time; uniform float _PixelsWorld_inpoint; uniform float _PixelsWorld_duration; uniform float _PixelsWorld_comp_time; uniform vec4 _PixelsWorld_date; uniform float _PixelsWorld_fps; uniform float _PixelsWorld_width; uniform float _PixelsWorld_height; uniform vec2 _PixelsWorld_origin; uniform vec2 _PixelsWorld_resolution; uniform vec2 _PixelsWorld_downsample; uniform mat4 _PixelsWorld_camera_matrix; uniform vec4 _PixelsWorld_camera_info; uniform bool _PixelsWorld_camera_perspective; uniform sampler1D _PixelsWorld_inWaveL; uniform sampler1D _PixelsWorld_inWaveR; uniform float _PixelsWorld_inWaveN; uniform float _PixelsWorld_inWaveS; uniform sampler1D _PixelsWorld_inSpecL; uniform sampler1D _PixelsWorld_inSpecR; uniform float _PixelsWorld_inSpecN; in vec2 _PixelsWorld_uv; out vec4 _PixelsWorld_outColor; Post-define code post_frag_shader_shadertoy.frag void main(){ mainImage(_PixelsWorld_outColor, _PixelsWorld_uv * iResolution.xy); } "},"contents/GLSL/shadertoy.html":{"url":"contents/GLSL/shadertoy.html","title":"Template Zone shadertoy","keywords":"","body":"Template Zone shadertoy Usage On shadertoy mode, you can run codes from shadertoy.com. Note It doesn't mean all code from shadertoy can be support perfectly in PixelsWorld. Some like codes containing VR are not support. Details Add _PixelsWorld_ prefix to use variables that exist in GLSL mode. E.g. slider[0] on GLSL mode = _PixelsWorld_slider[0] on shadertoy mode. It is not recommended to define your own _PixelsWorld_ prefixed variables. "},"contents/Lua/JavaScript.html":{"url":"contents/Lua/JavaScript.html","title":"World Outskirts JavaScript","keywords":"","body":"JavaScript Code Javascript can be executed by function pw.js(\"Your code\") on Lua (CPU & GPU) language mode. executeJS.lua version3() js(\"alert('Hello PixelsWorld!')\"); Note: Due to the structure of Ae, running js code inside PixelsWorld is not recommended. You are supposed to use js to do some simple calculations basing on local variables. "},"contents/Lua/CMDCode.html":{"url":"contents/Lua/CMDCode.html","title":"World Bed Rocks CMD","keywords":"","body":"CMD Code CMD commands can be executed by function cmd(\"Your cmd commands\") on Lua (CPU & GPU) language mode. executeCMD.lua version3() cmd(\"echo Hello PixelsWorld! & pause\"); "},"contents/Serial/SerialAttention.html":{"url":"contents/Serial/SerialAttention.html","title":"Apointments","keywords":"","body":"Appointments One serial number contains N Register number (N >= 1) One Register number registers one PC permanently. One Register number can be shared in any version of Ae in a PC. Registering costs one Register number, deactivating recovers one Register number Only Registering and Deactivating need internet. You can use PixelsWorld offline after registering completed. You don't have to deactivate before re-installing your OS, UNLESS you changed the hardwares like CPU or mainboard. When you finished re-installing your OS, register PixelsWorld again, this kind of registration doesn't cost the Register number. Contact with us if you foget to deactivate your serial number and you have already changed your CPU and mainboard. Serial number does't bind with any personal information. You can BUT NOT RECOMMAND sell it. MiLai visual performance group is not responsible for ANY trouble that happened in this kind of deals. The default value of Register numbner is 1. If you have more than one PC and you also want to run PixelsWorld on your multiple machines at the same time. Please purchase the corresponding number of PixelsWorld, we will send you the Serial number with Register number specified by you. "}}