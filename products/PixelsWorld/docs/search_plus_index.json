{"./":{"url":"./","title":"Be the Creator of your World","keywords":"","body":"Be the Creator of your world PixelsWorld documentation version: v3.2.0 Author ZzStarSound History v2.3.1 v1.0 中文版 日本語 Welcome to PixelsWorld! We have compressed all essence of how to use PixelsWorld in this section. If you master it, you will be a new creator of PixelsWorld! To be simple PixelsWorld renders image basing on your code You can use presets that written by other people. By learning how to write the Draw code, drawing shapes step-by-step to your scene. By learning the hardcore GLSL, creating advanced visual effect by yourself. How to do? PixelsWorld is a Drawing robot, if you tell it what/where to draw step-by-step, it will draw the shapes into the current scene for you. For instance, consider the case that you want to draw a house in the middle of the canvas, but the painter is your friend Andrew (and Andrew doesn't know what you want to draw). How to make the instructions so that Andrew can draw it for you? We would say: DrawHouse.myBro Draw a house in the middle of the canvas This is OK, but what if you cannot tell Andrew the answer directly, but 1. where to draw, 2. what to draw, 3. the color instead, maybe we need to say: DrawHouse2.myBro move the paintbrush to the center use yellow pigment draw a 10x10cm square move the paintbrush 5cm upward use red pigment draw a 15cm base length, 10cm height isoceles triangle. And then, you and Andrew complete the house painting! Indeed, the instructions above is exactly what we need to write in PixelsWorld. By clearing it up, it looks like this: DrawHouse3.lua version3() -- use version 3, this is a function that you always have to call in the first line. move(width/2, height/2) -- move the paintbrush to the center rotateX(PI) -- rotate space along X axis fill(1,1,0) -- use yellow pigment (Red=1,Green=1,Blue=0) rect(100) -- draw a 100x100px square fill(1,0,0) -- use red pigment(Red=1,Green=0,Blue=0) move(0,50) -- move the paintbrush 50px up tri(150,100) -- draw a 150px base length, 100px height isoceles triangle. There is a function rotateX(PI) we didn't mention before. Because the default orientation of the Y axis is downward, we need to rotate it along X axis 180 degrees (PI radians) to make it upward. Otherwise, the following movement of paintbrush will move it 50cm downward. Here we want to add some extra controls to the scene like change the color combination of our house. DrawHouse3.lua version3() -- use version 3, this is a function that you always have to call in the first line. move(width/2, height/2) -- move the paintbrush to the center rotateX(PI) -- rotate space along X axis fill(color(0)) -- use color parameter 0 as pigment rect(100) -- draw a 100x100px square fill(color(1)) -- use color parameter 1 as pigment move(0,50) -- move the paintbrush 50px up tri(150,100) -- draw a 150px base length, 100px height isoceles triangle. If you click the Ok button, the house would disappear! Actrually the house is still drawn in your scene, but the default color controls are black, so the house is also black. Open the Parameter list, find the first 2 Color controls, change it to the color you want. Mayor is me! Draw more houses One big advantage of using code is doing repetitive things. Lua language is able to repeat your instructions as many times as you want. DrawHouse3.lua version3() -- use version 3, this is a function that you always have to call in the first line. move(width/2, height/2) -- move the paintbrush to the center rotateX(PI) -- rotate space along X axis for i=1,3 do -- begin repeat (3 times) fill(color(0)) -- use color parameter 0 as pigment rect(100) -- draw a 100x100px square fill(color(1)) -- use color parameter 1 as pigment move(0,50) -- move the paintbrush 50px up tri(150,100) -- draw a 150px base length, 100px height isoceles triangle. move(0,-50) -- move the paintbrush back move(175,0) -- move the paintbrush 175px right end -- End mark of repeat Finally, we want to give the controls some names: Save the instructions to preset. Note: This step may need the Administrator mode if you have installed Ae in the System disc (maybe C). First of all, add a new Preset column to save your preset: Then, save your preset in the new Preset column: Apply preset Select the preset you want to apply, click the Replace button. Congratulations! You have mastered the main part of how to use PixelsWorld. >>> Next step: Go to the lua chapter for more details PixelsWorld ability "},"contents/HowTo.html":{"url":"contents/HowTo.html","title":"Get/Try/Purchase","keywords":"","body":"Get/Try/Purchase Download Purchase/Download PixelsWorld Note: Some presets are under non-commercial license. Put the \"MiLai\" folder into (Your AE root folder)/Support Files/Plug-ins/ Usage Open Adobe After Effects. \"Ctrl + N\"(or \"Command + N\") to create a comp. Create a solid layer. Select the solid you created. Right click it => Effects => MiLai => PixelsWrold. Click \"Edit\" to change \"World formula\". There will be a World formula editor showed up. Find \"Preset list\" and select a column that is interesting to you, select a preset in that column Click the \"Replace\" button. Click the \"Ok\" button. "},"contents/Editor/ScriptWindow.html":{"url":"contents/Editor/ScriptWindow.html","title":"World formula editor","keywords":"","body":"World formula editor Open the formula editor Click the \"Edit\" button in the plugin panel. For demonstrating purpose, we highlight different area with colored rectangle. ◆Code area Input your creative code here. Language in this panel overrides the Language setting in your plugin panel. (default) selection means current language. ◆Reference list Reference code that would help you to remind some frequently-used functions are listed here, this list is read-only currently. ◆Parameter settings Here you can see the labels, the default value of parameters and the language settings. Click Parameter manager button to manage them. See also Parameter manager Parameter settings are saved with code into preset. ◆Preset list The pop-up menu contains all preset files in your local disc. Here are same definition: A file with .pwp post fix, JSON format and located beside plugin is a Preset column. The name of the Preset column is the file name. One Preset column contains several Presets All Presets are listed below the pop-up menu. ◆Formula preview The selected Preset's code can be previewed here. Click the Replace button to send preset code to the left code area (This will override the previouse code). If you only want to replace the text and don't want the parameter settings change. Uncheck Apply when replace in Parameter settings preview area. If you want the preset code to be combined in the front of your code, click button; Bottom>> means to combine preset code behind your current code. ◆Parameter settings preview The selected Preset's parameter settings can be previewed here. If you want to apply it, click Apply button to override the current settings. Apply when replace means if auto apply parameter settings when you click the Apply button in the Formula preview area. "},"contents/Editor/ParameterWindow.html":{"url":"contents/Editor/ParameterWindow.html","title":"Parameter manager","keywords":"","body":"Parameter manager Click the Parameter manager button on the World rule editor to start Parameter manager. This is the Parameter manager window: Rule Type the lables into the first input area, the default values into the following input area. (Decimal number 0~1) Clear names button clears label names. Clear all names button clears all label names. Reset names button resets label names to default. Reset all names button resets all label names to default. Reset values button resets values. Reset all value button resets all values. Encoding PixelsWorld supports utf-8. Some not supported characters are converted to ? in plugin panel. If you work with international authors. We recommand using ASCII characters for all labels. "},"contents/Editor/SavePresets.html":{"url":"contents/Editor/SavePresets.html","title":"Preset management","keywords":"","body":"Preset management Save preset In World formula editor,you can click the Save as preset button to save your code as a preset. Note: Same name brings overriding. Override save In World formula editor,click the Save as preset button, and type the existing name to override the previous preset. Note All operation in the editor is not undoable. Rename presets Double click the preset to rename a preset. Use name EXCEPTREMOVE and SORT. Sort presets Double click one preset and type in SORT. Remove presets Double click the preset you want to remove and type in REMOVE. Add preset column Click Add button in the Preset list Note: Name must be unique. If failed, you might need to re-open Ae with administrator mode. Format Format: utf-8, JSON Not encrypted. Contribute presets Send your preset to ZzStarSound@gmail.com with your name and detailed description. "},"contents/Lua/LuaCode.html":{"url":"contents/Lua/LuaCode.html","title":"World Center Lua","keywords":"","body":"Lua Code The instructions that we wrote in chapter 1 is called Lua Lua is a lightweight, high-level, multi-paradigm programming language designed primarily for embedded use in applications. ——Wiki) Version : Lua5.3 So Lua plays the roll that manages the communication between Ae and Users. It is quite similar to Ae script and expression language. Basically you can draw highly variant scene by remembering just a little words. For instance, if you want to draw a cube that can interact with Ae camera, just type: DrawCube.lua version3() move(width/2,height/2) dim3() cube(300) dim3() means draw shapes in 3 dimension. If you want to run GLSL code, just type: RunGlsl.lua version3() glsl([==[ void main(){ vec3 col = 0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4)); outColor = vec4(col,1.0); } ]==]) If you want to run code from shadertoy, just type: RunShadertoy.lua version3() pw.shadertoy([==[ void mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec2 uv = fragCoord/iResolution.xy; vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)); fragColor = vec4(col,1.0); } ]==]) In Lua, you can : Get pixels data Write pixels data Run JavaScript Run GLSL Get paramters data Run outer C library (COOL!) Load outer lua module Because of the advanced features, the users who using Lua render mode should have basic programming abilities and have a primary understanding about Lua language. If you have no idea about Lua, don't warry about it, it is pretty easy to learn. "},"contents/Lua/RunLua.html":{"url":"contents/Lua/RunLua.html","title":"Run Lua","keywords":"","body":"Run Lua code Switch your luange to Lua ( CPU & GPU ) And input the code below : hello.lua version3() a = 5+6 b = \"PixelsWorld\" c = \"is cool!\" d = time e = slider(0) f = \"5 + 6 = \" .. a .. \"\\nMessage : \" .. b .. \" \" .. c .. \"\\nCurrent time is : \" .. d .. \" (s)\\nValue of slider0 is : \" .. e print(f) a..b means combine variable a and b as string. print() reports message to your screen. slider() fetches the value of a specified parameters. You are allowed to add ; in the end of each line, but it is not indispensable. Lua regards the \\n(line break) as the end mark of one section of code. A message will show up in the left top corner of your screen. "},"contents/Lua/WriteLocalCode.html":{"url":"contents/Lua/WriteLocalCode.html","title":"Load local code","keywords":"","body":"Load local Lua code If you don't prefer to use PixelsWorld's editor, PixelsWorld can read txt file from local disc. So you can write the file with the IDE you like. Don't put the file to system disc(C:\\ disc). loadTxt.lua version3() runFile([[d:\\mycode.txt]]) -- Replace to your path The reason we use [[d:\\mycode.txt]] but not \"d:\\mycode.txt\" is that the latter's \\ will cause escape problem. You can use any postfix you want(*.lua, *.code, *.magic) as long as its contents are texts. Use following code to read the code file beside your Ae project file. loadTxt.lua version3() runFile( projectFolder .. [[mycode.txt]]) -- Replace to your file name Note: You should save your Ae project to local disc or the projectFolder is just an empty string. It is not over! Don't forget to refresh PixelsWorld If you saved your code file, PixelsWorld cannot read it immediatly. You should then hold Ctrl + Alt, click the logo image, this will trigger the rerender of PixelsWorld, then your new code will be read by PixelsWorld. The logo image here is appearing basing on a constant probability distribution. For artists who are crazy about collecting things, we have designed lots of beautiful logo image here. "},"contents/Lua/importantFuncs.html":{"url":"contents/Lua/importantFuncs.html","title":"Important functions","keywords":"","body":"Important functions There are some functions that we use most in PixelsWorld. Default code default_code.lua version3() in2out() move(width/2,height/2) version3() function must be called in the first line. It put all functions that in the table pw3 to the global field. If you don't call it, you need to add a pw3. prefix to all the function provided by PixelsWorld. For instance, the following demonstrated function print() should be pw3.print(). On the contrary, If you call the function version3() in the first line, the pw3. prefix could be omitted. This function is designed for backward compatibility. We recommend calling version3() in the first line any time you use Lua render mode. in2out() copys the input image to the output. If you don't need input image but a pure color backgroud instead, call background(r,g,b,a)(RGBA range: 0~1). If you want your background to be empty, remove the in2out() function. move(x,y) moves the Paintbrush along vector (x,y). The default location of Paintbrush is (0,0), hence move(width/2,height/2) means move the Paintbrush to the middle of your scene. Remove this function if you don't need this moving. "},"contents/Lua/LinkParameters.html":{"url":"contents/Lua/LinkParameters.html","title":"Link parameters","keywords":"","body":"Link parameters parameters.lua slider(id) -- return 1 double angle(id) -- return 1 double point(id) -- return 2 double point3d(id) -- return 3 double checkbox(id) -- return 1 boolean color(id) -- return 3 double layer(id,x,y) -- return 4 double If there are more than one values returned, the corresponding number of variables need be declared to catch the values. For instance, the point() function: point.lua version3() x,y = point(0) -- Declear two variables x and y println('x is ' .. x) println('y is ' .. y) "},"contents/Lua/globals.html":{"url":"contents/Lua/globals.html","title":"Globals","keywords":"","body":"Globals Global constants Here are some global constants in PixelsWorld: const.lua PI -- the Circular constant pi TPI -- two pi HPI -- half pi QPI -- quarter pi E -- the Natural number e PHI -- the Golden ratio phi R2 -- square root 2 R3 -- square root 3 R5 -- square root 5 R7 -- square root 7 INPUT -- Index of input image -1 TEMP -- Index of temp image -2 OUTPUT -- Index of output image -3 PARAM0 -- Index of the #0 layer parameter 0 PARAM1 -- Index of the #1 layer parameter 1 PARAM2 -- Index of the #2 layer parameter 2 PARAM3 -- Index of the #3 layer parameter 3 PARAM4 -- Index of the #4 layer parameter 4 PARAM5 -- Index of the #5 layer parameter 5 PARAM6 -- Index of the #6 layer parameter 6 PARAM7 -- Index of the #7 layer parameter 7 PARAM8 -- Index of the #8 layer parameter 8 PARAM9 -- Index of the #9 layer parameter 9 platform -- Windows == 0, no other platforms. host -- Ae == 0, no other hosts. Global variables Here are some global variables in PixelsWorld: globalvars.lua depth -- Dpc: 8,16,32 width -- Width input image height -- Height input image time -- Current time(s) duration -- Duration of current layer(s) inpoint -- Inpoint of current layer(s) compTime -- Comp current time(s) pluginFolder -- The plugin folder(utf8) projectName -- Project name(utf8) projectPath -- Project path(utf8) projectFolder -- Project folder(utf8) ds_width -- Width of downsampled input image ds_height -- Height of downsampled input image origin_x -- The X coordinate of left top corner of input image in the layer coordinate. origin_y -- The Y coordinate of left top corner of input image in the layer coordinate. Print the globals Globals can be printed by using following code: printGlobals.lua version3() in2out() for k, v in pairs(_G) do print(k) print(\" \" .. type(v) , .5,.5,.5) print(\" \".. tostring(_G[k]),0,1,1) println(\"\") end "},"contents/Lua/FuncList.html":{"url":"contents/Lua/FuncList.html","title":"Function list","keywords":"","body":"Function List This page covers all functions provided in Lua render mode. Required functions version3 Parameter link functions slider, angle, point, point3d, checkbox, color, layer Print message functions print, println, alert Transform functions move, scale, rotate, rotateX, rotateY, rotateZ, twirl beginGroup, endGroup, beginGlobal, endGlobal global2local, local2global, global2screen, screen2global getTransformMatrix Draw functions Primitives tri, quad, rect, circle, ellipse, par, line cube, tet, cone, ball, tube image, coord, grid poly, setPoly background, in2out Attribute controls dim2, dim3 perspective, noPerspective fill, noFill, stroke, noStroke, dot, noDot wireframe, noWireframe blendAlpha, noBlendAlpha back, noBack pure, phong, anime rgba, depth, normal setDepth Lights ambientLight, pointLight, parallelLight clearLight, getLight Camera function aeCamera, lookAt, viewSpace Stroke details strokeWidth, strokeDivision, strokeGlobal, strokeLocal Dot details dotRadius, dotDivision, dotGlobal, dotLocal Output details smooth, noSmooth Utility tools r2d, d2r map clamp step smoothStep bezier rgb2hsl,hsl2rgb,rgb2hsv,hsv2rgb,rgb2cmy,cmy2rgb,rgb2cmyk,cmyk2rgb,cmy2cmyk,cmyk2cmy,hsl2hsv,hsv2hsl utf8ToLocal, localToUtf8 getGLInfo, getDrawRecord, getStatus getAudio Read/Write pixels functions getColor, setColor, getSize, Run code functions shadertoy, glsl, cmd, lua, runFile, txt Detailed descriptions version3 version3() function must be called in the first line. It put all functions that in the table pw3 to the global field. If you don't call it, you need to add a pw3. prefix to all the function provided by PixelsWorld. For instance, the following demonstrated function print() should be pw3.print(). On the contrary, If you call the function version3() in the first line, the pw3. prefix could be omitted. This function is designed for backward compatibility. We recommend calling version3() in the first line any time you use Lua render mode. version3.lua version3() println(\"Hello PixelsWorld! \") without_version3.lua pw3.println(\"Hello PixelsWorld! \") print print(str),print(str,brightness),print(str,r,g,b),print(str,r,g,b,a) prints message to the left top corner of your scene. print.lua version3() print(\"Hello PixelsWorld! \") str = \"Hello, I am colorful PixelsWorld! \" for i=1,#str do local c = str:sub(i,i) local phase = math.sin(i/#str*TPI + time*10) / 2 + .5 print(c,phase,1-phase,1,1) end println println(str),println(str,brightness),println(str,r,g,b),println(str,r,g,b,a) prints message to the left top corner of your scene, this function adds \\n in the end of input string. println.lua version3() println(\"Hello PixelsWorld! \") str = \"Hello, I am colorful PixelsWorld! \" for i=1,#str do local c = str:sub(i,i) local phase = math.sin(i/#str*TPI + time*10) / 2 + .5 -- println(c,phase,1-phase,1,1) print(c,phase,1-phase,1,1) end alert alert(str) prints caution message, equals to println(str,1,1,0,1) alert.lua version3() alert(\"Warning: Write your message here! \") move move(x,y),move(x,y,z)moves Paintbrush. All transforms are done basing on the Paintbrush coordinate. Example: move.md version3() coord() -- show Paintbrush coordinate move(100,0) coord() -- show Paintbrush coordinate move(0,100) coord() -- show Paintbrush coordinate Finally, the Paintbrush is located at (100,100,0). scale scale(ratio),scale(x,y),scale(x,y,z)scales the Paintbrush coordinate. All transforms are done basing on the Paintbrush coordinate. rotate rotateX rotateY rotateZ rotate(theta)rotates Paintbrush with theta radians. rotateX(theta) rotates Paintbrush along X axis. rotate(theta) equals to rotateZ(theta). All transforms are done basing on the Paintbrush coordinate. If you are not familiar with radians, use d2r(degree) to convert a degree to a radian. For example：rotate(d2r(90)) means rotate 90 degrees. twirl twirl(theta,x,y,z) rotates Paintbrush along (x,y,z) axis with theta radians. For example, above-mentioned rotateX(theta) equals to twirl(theta,1,0,0). All transforms are done basing on the Paintbrush coordinate. twirl is an matrix implementation of quaternion rotation. beginGroup endGroup beginGroup(),endGroup() creates a children transformation group. Transformations(move,scale,rotate,twirl) between beginGroup() and endGroup() will be canceled after calling endGroup(). beginGroup(mat) pushes mat as a children transformation group (Use getTransformMatrix to get the transform matrix). It equals to pushMatrix() and popMatrix() in Processing. Example: The following two code are equivalent. group.lua version3() for i = 1,10 do beginGroup() move(i*100,i*100) rotate(d2r(45*i)) rect(50) endGroup() end without_group.lua version3() for i = 1,10 do move(i*100,i*100) rotate(d2r(45*i)) rect(50) rotate(d2r(-45*i)) move(-i*100,-i*100) end beginGlobal endGlobal Draw functions between beginGlobal and endGlobal will draw shapes in global coordinates. beginGlobal.lua version3() move(100,100) fill(0,1,0) -- green rect(50) -- Dran on (100,100,0) beginGlobal() fill(1,0,0) -- red rect(50) -- Draw on (0,0,0) endGlobal() move(100,100) fill(0,0,1) -- blue rect(50) -- Draw on (200,200,0) global2local global2local(x,y,z) converts a global point to a local point. Returns 3 doubles. local2global local2global(x,y,z) converts a local point to a global point. Returns 3 doubles. global2screen global2screen(x,y,z) converts a global point to a screen point. Returns 3 doubles. The result is affected by perspective mode. screen2global screen2global(x,y,z) converts a screen point to a global point. Returns 3 doubles. The result is affected by perspective mode. getTransformMatrix getTransformMatrix() returns a column major 4x4 transform matrix. mat[i][j] returns the entry in ith column jth row. (i,jrange: 1~4) matrix.lua version3() dim3() beginGroup() move(width/3,height/3) twirl(QPI*time,1,1,1) cubetransform = getTransformMatrix() endGroup() beginGroup(cubetransform) cube() endGroup() tri tri(radius) draws a regular triangle with radius radius, and the triangle will point to the positive direction of Y axis. tri() equals to tri(100) tri(w,h)draws a triangle with base length w and height h. tri(p1x,p1y,p2x,p2y,p3x,p3y) draws a triangle basing on 3 points p1,p2,p3. tri(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z) draws a triangle basing on 3 points p1,p2,p3. Add dim3() after version3(), and add a camera layer to your Ae comp to view the 3D triangle. The first 3 functions set normals to (0,0,-1) basing on the current Paintbrush coordinate. The last 2 functions calculate normals with formula: cross(p1-p2,p3-p2). tri is an abbreviation of triangle tri1.lua version3() move(width/2,height/2) tri(100) tri5.lua version3() dim3() move(width/2,height/2) tri(0,0,100,50,0,0,0,50,0) quad quad(p1x,p1y,p2x,p2y,p3x,p3y,p4x,p4y) quad(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z,p4x,p4y,p4z) Draws 2 triangles with order: p1,p2,p3,then p1,p3,p4. rect rect(size) draws a square with size. rect() equals to rect(100) rect(width,height) draws a rectangle with width width and height height. The intersection point of rectangle is at the origin of Paintbrush coordinate. rect is an abbreviation of rectangle. circle circle(radius) draws a circle with radius radius. circle() equals to circle(100) circle(radius, div) draws a circle with radius radius, and subdivision div. Default subdivision: 128 ellipse ellipse(radiusx,radiusy)draws an ellipse with x radiusradiusx, y radius radiusy. ellipse() equals to ellipse(100,100) ellipse(radiusx,radiusy,div) draws an ellipse with x radiusradiusx, y radius radiusy and subdivision div. Default subdivision: 128 line line(p1x,p1y,p2x,p2y) draws a line. line(p1x,p1y,p1z,p2x,p2y,p2z) draws a 3d line. line() equals to line(0,0,0,100,100,100) Use stroke(r,g,b) to change the color. UsestrokeWidth(width) to change the width. Use noStroke() to turn off line render, stroke() to turn on line render. par par(x) draws a point at(x,0,0). par(x,y) draws a point at(x,y,0). par(x,y,z) draws a point at(x,y,z). par() equals to par(0,0,0) By default, the point render is turned off, use dot() to turn it on. You can call noDot() to turn it off again. dotRadius(radius) controls point radius. dot(r,g,b) controls point color. dotGlobal() makes point be avoid to be squeezed by scale. By default, points are rendered with dotLocal(). cube cube(size) draws a cube with size size cube(sizex,sizey,sizez) draws a cuboid with dimension sizex,sizey,sizez. cube() equals to cube(100) cube() Negative inputs or negative scale() would cause wrong normals. tet tet(radius) draws a regular tetrahedron with radius radius. tet() equals to tet(50) tet(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z,p4x,p4y,p4z) draws tetrahedron basing on 4 points p1,p2,p3,p4. The 3rd function generates normals basing on tri function and calls it with the following points order: p1,p2,p3; p2,p1,p4; p3,p2,p4; p1,p3,p4.. See also: tri. tet is an abbreviation of tetrahedron. cone cone(size) draws a cone with base circle radius size and height 2*size. cone() equals to cone(50). cone(radius,height) draws a cone with base circle radius radius and height height. cone(radius,height,div) draws a cone with base circle radius radius, height height and subdivision div. Default subdivision: 64 If sub is greater than 16, the side stroke and base point will be hidden. Negative inputs or negative scale() would cause wrong normals. ball ball(radius) draws a sphere with radius radius. ball() equals to ball(50). ball(radius,level) draw a ball with radius radius and subdivision level level. Default subdivision level 4. level must be non-negative. level 0 generates a regular octahedron. If level is greater than 2, the strokes and points will be hidden. Negative inputs or negative scale() would cause wrong normals. tube tube(size) draws a tube with base circle radius size and height 2*size. tube() equals to tube(50) tube(radius,height)draws a tube with base circle radius radius and height height. tube(radius1,radius2,height) draws a tube with close base circle radius radius1, far base circle radius radius2 and height height. tube(radius1,radius2,height,div) can change the subdivision. tube(radius1,radius2,height,div,needMesh) can change render 2 base circles or not. tube(radius1,radius2,height,div,needMesh1,needMesh2) can change render 2 base circles or not separately. Default div: 64. needMesh is true by default. If div is greater than 16, the side strokes and the base points will be hidden. Negative inputs or negative scale() would cause wrong normals. image image(id,width,height) draws an image with width width and height height. id is texture id,PARAM0~PARAM9means texture load from the layer parameters, INPUT means input image, OUTPUT means output image. If id is OUTPUT, it will be slow because we need to take a screenshot of your scene. The difference with in2out(id) is, image(id,width,height) draws a rectangle with a texture, which could interact with the depth buffers, where in2out(id) just copy pixels from one texture to another. This is also means the image that is drawn to the screen is inversed by default (The default coordinate system of Ae is Y axis downward), so you may need rotateX(PI) to fix it. (And we don't recommend calling scale(1,-1), which may cause wrong normals problem. Example: render_image.lua version3() dim3() move(width/2,height/2) beginGroup() rotateX(PI) image(INPUT,width,height) endGroup() rotateX(QPI * time) rotateY(QPI * time) cube() coord coord() draws the current Paintbrush coordinate. grid grid() draws a grid with many 100x100px squares. setPoly setPoly(obj) analyzes obj only, use poly() to draw the previous set obj to scene. It will be efficient in the case you draw a same obj for many times. See also Poly background background(brightness),background(r,g,b),background(r,g,b,a) draws a pure color rectangle to scene. Notes: This function overrides all shapes you drew before. in2out in2out(id) set the id texture to the scene. in2out() equals to in2out(INPUT) id range: PARAM0~PARAM9 or INPUT. dim2 dim2() set the scene to 2D mode. 2D mode is on by default, you usually no need to call it. In PixelsWorld, 2D scene means a 3D scene without depth test and perspective. dim3 dim3() set the scene to 3D mode. Call it immediately after version3(). Note: Use viewSpace to change the far plane dimension if your layer size is not equal to the comp size. Otherwise, the shapes in 3D mode will be rendered to an unexprected position. perspective perspective() set the scene to perspective mode, everything looks small in the distance and big on the contrary. Use viewSpace to change the camera information. Use lookAt to set the location of the camera. Perspective mode is on by default after calling dim3(). noPerspective noPerspective() set the scene to orthogonal mode. fill fill() turns on fill mode. fill(brightness),fill(r,g,b),fill(r,g,b,a) turns on fill mode and set fill color. Note: If you set Alpha smaller than 1, render far object first, or you will get wrong render results due to the depth test. (This is a feature of OpenGL render) noFill noFill() turns off the fill mode. stroke stroke() turns on the stroke mode. stroke(brightness),stroke(r,g,b),stroke(r,g,b,a) turns on stroke mode and set the stroke color. noStroke noStroke() turns off stroke mode. dot dot() turns on the dot mode. dot(brightness),dot(r,g,b),dot(r,g,b,a) turns on the dot mode and set the dot color. noDot noDot() turns off the dot mode. wireframe wireframe() turns on the wireframe mode. noWireframe noWireframe() turns off the wireframe mode. blendAlpha blendAlpha() turns on the alpha blending. noBlendAlpha noBlendAlpha turns off the alpha blending. back back() If the fill alpha is smaller than 1, back mode shows the back side of an obj. Off by default. noBack noBack() turn off back mode. pure pure() use pure color to render. On by default. anime, phong, pure are 3 dependent mode, turn on one may turn off the other two. phong phong(ambient,diffuse,specular,specularPower) turns on the phong render mode, and set the ambient strength to ambient, diffuse strength to diffuse, specular strength to specular, specular damping power to specularPower. phong() only turn on the phong render mode, it doesn't change the configs. By default, there is no light in the scene, call getLight(), ambientLight(), parallelLight(), pointLight to add lights. If you are sure there are lights in your scene but the obj is black, call normal to check if the normal is right. Default settings: ambient:1,diffuse:1,specular:1,specularPower:1. anime, phong, pure are 3 dependent mode, turn on one may turn off the other two. Call dim3() before calling this function. anime anime(ambient,diffuse,specular,specularPower,diffuseThreshold,specularThreshold) anime() turns on the anime render mode. anime render mode is based on phong, hence the first 4 arguments ambient,diffuse,specular,specularPower are same with phong render mode. diffuseThreshold configs the diffusion threshold, if diffuse lightnees in a pixel is bigger than threshold, it will be white. Otherwise it will be dark. specularThreshold is threshold of specular. The anime render mode smooth the light-dark border when you turn on the smooth settings in plugin panel. Default settings: ambient:1,diffuse:1,specular:1,specularPower:1,diffuseThreshold:0.5,specularThreshold:0.8 anime, phong, pure are 3 dependent mode, turn on one may turn off the other two. Call dim3() before calling this function. rgba rgba()RGBA output mode, on by default. rgba, depth, normal are 3 dependent mode, turn on one may turn off the other two. You can use phong(),anime() in this output mode. depth depth(blackDistance, whiteDistance) depth output mode. Set pixels at distance blackDistance to black, pixels at distance whiteDistance to white. If they are same, PixelsWorld set the pixels that nearer than the value you set to black, otherwise white. rgba, depth, normal are 3 dependent mode, turn on one may turn off the other two. phong(),anime() will be ignored in this output mode. Call dim3() before calling this function. normal normal(faceToCamera, normalize) turns the normal output mode on, and configs faceToCamera and normalize. normal(faceToCamera) turns the normal output mode on, and configs faceToCamera. normal() only turns the normal output mode on. faceToCamera is a boolean, true means the normals are calculated basing on camera location. false means the normals are calculated basing on the global coordinate. normalize is a boolean. Default settings: faceToCamera:true, normalize:true. rgba, depth, normal are 3 dependent mode, turn on one may turn off the other two. phong(),anime() will be ignored in this output mode. Call dim3() before calling this function. setDepth setDepth(id,blackDistance,whiteDistance) reads the red channel of texture id, maps color basing on blackDistance,whiteDistance to the depth test buffer in the scene. The depth sequence from other 3DCG softwares can be loaded into PixelsWorld through this function. Namely the shapes can interact with the color sequence rendered from other 3DCG softwares. Call dim3() before calling this function. Valid texture id: INPUT,PARAM0~PARAM9 ambientLight ambientLight(r,b,g,intensity) ambientLight() equals to ambientLight(1,1,1,1) ambientLight(brightness) equals to ambientLight(brightness,brightness,brightness,1) ambientLight(brightness,intensity) equals to ambientLight(brightness,brightness,brightness,intensity) ambientLight(r,g,b) equals to ambientLight(r,b,g,1) Adds a ambient light to the scene. Valid to all objs. Objs are lit up by this kind of lights even if they has wrong normals. pointLight pointLight(r,g,b,intensity,radius,smoothWidth) pointLight() equals to pointLight(1,1,1,1,1000,1000) pointLight(brightness,intensity) equals to pointLight(brightness,brightness,brightness,intensity,1000,1000) pointLight(r,g,b) equals to pointLight(r,g,b,1,1000,1000) pointLight(r,g,b,intensity) equals to pointLight(r,g,b,intensity,1000,1000) pointLight(r,g,b,intensity,radiusAndSmoothWidth) equals to pointLight(r,g,b,intensity,radiusAndSmoothWidth,radiusAndSmoothWidth) Adds a point light in the current Paintbrush coordinate. This light is affected by objs' normals. The specular and diffuse will be failed if the normals are inward, but the ambient brightness of point light still lights up the objs. radius is range radius of point light. Range from radius to radius+smoothWidth, the brightness damps. parallelLight parallelLight(r,g,b,intensity,tx,ty,tz) Adds a parallel light with direction vector (tx,ty,tz). clearLight clearLight() removes all lights in the scene. getLight getLight(matchName) getLight() equals to getLight(\"*\") Gets lights that match the name matchName. matchName rules：If matchName doesn't end up with character \"*\", it searches one Ae lights that its name is matchName, otherwise, it includes all Ae lights that begin with matchName. Supported Ae lights: ambient,point,parallel aeCamera aeCamera() sets the Ae activated camera to the scene camera of PixelsWorld. lookAt lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ,upVecX,upVecY,upVecZ) sets the location and orientation of the current scene camera. lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ) equals to lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ,0,-1,0) eyePos is the location of your eyes, objPos is the location of the object you are looking at,upVec the direction your top of head pointing to. Note: Y axis in Ae is downward by default, usually set the upVec to (0,-1,0) is enough. eyePos and objPos cannot be too close. (should be bigger than 1e-7). upVec cannot be parallel to your sight. The length of upVec cannot be too small. viewSpace viewSpace(width,height,distanceToPlane,farLevel) viewSpace(width,height,distanceToPlane) equals to viewSpace(width,height,distanceToPlane,4) width and height is the dimension of the far plane. The perpendicular distance from camera to camera far plane is distanceToPlane farLevel * distanceToPlane is the clip plane distance. Objs that farther than this distance will be clipped out. Normally it is enough to left the farLevel 4, set it to higher number if your scene is pretty vast. Note that if the farLevel is too high, the depth test precision of near objs may decline. strokeWidth strokeWidth(width) Default: 2 strokeDivision strokeDivision(level) Default: 3 strokeGlobal strokeGlobal() draw lines globally. Lines will no longer be squeezed by scale function. Default: local strokeLocal strokeLocal() draw lines locally. Lines will be squeezed by scale function. Default: local dotRadius dotRadius(radius) Default: 2 dotDivision dotDivision(level) Default: 3 Maximum: 7 dotGlobal dotGlobal() Draw points globally. Points will no longer be squeezed by scale function. Default: local dotLocal dotLocal() Draw points locally. Points will be squeezed by scale function. Default: local smooth smooth() Smooth render mode. Default: on The smooth strength can be changed in plugin panel. noSmooth noSmooth() Pixel art render mode. The priority of this function is higher than settings in plugin panel. r2d r2d(degrees) radians to degrees, return degrees. d2r d2r(radians) degrees to radians, return radians map map(value,in1,in2,out1,out2) maps value value from range in1~in2 to range out1~out2. If in1 equals to in2, if value this function returns out1, otherwise out2. clamp clamp(value,lower,upper)clamps value into range [lower,upper], returns clamped value. New in v3.2.0 Namely, if value is between lower and upper, this function returns value; If value is less than lower, it returns lower; If value is greater than upper, it returns upper. step step(value,threshold) returns 0 if value, otherwise, returns 1. New in v3.2.0 smoothStep smoothStep(value,lower,upper) returns 0 if value, returns 1 if value>higher1, otherwise, returns the smooth interpolation between lower and higher basing on value. Formula of interpolation: t:=x−lowerupper−lower\r t := \\frac{x - lower}{upper - lower}\r t:=​upper−lower​​x−lower​​ Result:=t2(3−2t)\r Result:=t^2(3 - 2t)\r Result:=t​2​​(3−2t) New in v3.2.0 bezier bezier(t,p0,p1,...,pn) returns the n times bezier interpolation basing on p0,p1,...,pn. Formula of interpolation: Result:=∑k=0nCnk⋅(1−t)n−k⋅tk⋅pk\r Result := \\sum_{k=0}^n{C_n^k\\cdot (1-t)^{n-k}\\cdot t^k\\cdot p_k}\r Result:=∑​k=0​n​​C​n​k​​⋅(1−t)​n−k​​⋅t​k​​⋅p​k​​ Cnk:=n!(n−k)!k!\r C_n^k:=\\frac{n!}{(n-k)!k!}\r C​n​k​​:=​(n−k)!k!​​n!​​ New in v3.2.0 The maximum of n is 66. Color conversion xxx2xxx allows the following color conversion: For example, if you want to convert a hsl color to rgb format, then you need to call the function hsl2rgb, both the number of input and output parameters are 3. All conversions are done in range 0~1. New in v3.2.0 utf8ToLocal utf8ToLocal(str) unicode string to local string. Call this function to translate paths while you are handling Lua's io module. localToUtf8 localToUtf8(str)local string to unicode string getGLInfo getGLInfo() gets the information of the current graphic card. getDrawRecord getDrawRecord(needStringFormat) gets current draw records. needStringFormat is a boolean, when true, returns a string, otherwise, returns a Lua table. getDrawRecord() equals to getDrawRecord(true) printDrawRecord.lua version3() move(width/2,height/2) dim3() cube() println(getDrawRecord()); getStatus getStatus(needStringFormat)gets the current Paintbrush status. needStringFormat is a boolean, when true, returns a string, otherwise, returns a Lua table. getStatus() equals to getStatus(true) getStatus.lua version3() move(width/2,height/2) dim3() cube() println(getStatus()); getAudio getAudio(startTime,duration,id,sampleRate) gets the audio samples. Returns 4 tables. The first 2 are wave sample tables(Left and Right), the last 2 are spectrum sample tables(Left and Right). getAudio(startTime,duration) equals to getAudio(startTime,duration,INPUT,44100) getAudio(startTime,duration,id) equals to getAudio(startTime,duration,id,44100) Left wave sample range: (-1~1) Right wave sample range: (-1~1) Left spectrum sample range: (0~infinity) Right spectrum sample range: (0~infinity) waveInfo.lua version3() background(0.2) local wl,wr,fl,fr = getAudio(time-0.1,0.2) local nm = math.floor(height/8); for i=1,nm do local wid =math.max(math.floor(i/nm*#wl),1) local fid = math.max(math.floor(i/nm*#fl/16),1) print(string.format(\"%8.5f\",wl[wid]),wl[wid]*4,0,-wl[wid]*4) print(\" \",0,0,0) print(string.format(\"%8.5f\",wr[wid]),wr[wid]*4,0,-wr[wid]*4) print(\" \",0.5,0.5,0.5) print(string.format(\"%8.5f\",fl[fid]),fl[fid]/math.sqrt(#fl),0,0) print(\" \",0,0,0) print(string.format(\"%8.5f\",fr[fid]),0,0,fr[fid]/math.sqrt(#fr)) println(\"\"); end getColor getColor(id,x,y) get pixel color at location (x,y) of texture id. Returns r,g,b,a 4 doubles. getColor(x,y) equals to getColor(INPUT,x,y) It is high efficient to call getColor before any draw function(Such as immediately after version3()). Otherwise, it is very low efficient since it queries pixels from the graphic card. Valid id: INPUT,OUTPUT,PARAM0~PARAM9 setColor setColor(x,y,r,g,b,a) set the pixel at location (x,y) of texture OUTPUT. It is high efficient to call setColor before any draw function getSize getSize(id) returns the size of texture id. (Two doubles, width and height) Due to the Ae's downsample (1/2,1/4) mechanism, the size you get would variating 0~4px. But this kind of variating doesn't change with time. The size is promised to be accurate in full resolution(without downsample). shadertoy shadertoy(code) runs code from shadertoy.com. Not all code on shadertoy.com is supported. glsl glsl(code) runs fragment stage shader code. cmd cmd(code) runs cmd code. This function is equivalent to the ISO C function system. It passes command to be executed by an operating system shell. Its first result is true if the command terminated successfully, or nil otherwise. After this first result the function returns a string plus a number, as follows: \"exit\": the command terminated normally; the following number is the exit status of the command. \"signal\": the command was terminated by a signal; the following number is the signal that terminated the command. lua lua(code) runs lua code. runFile runFile(utf8_path) loads local lua code and run. No need to call utf8ToLocal since it supports utf8. txt txt(utf8_path) loads local text file. Returns string. No need to call utf8ToLocal since it supports utf8. "},"contents/Lua/Poly.html":{"url":"contents/Lua/Poly.html","title":"Poly function","keywords":"","body":"Creation origin: Poly function poly(obj) analyzes the inputted obj, then draws it to the scene. Usage If you are familiar with Houdini, constructing an obj is basically to fill a SpreadSheet. Here is an example of constructing an obj of an unusual colorful triangle. PolyTest1.lua version3() background(0.95) move(width/2,height/2) dim3() dotRadius(5) obj={ point={ {p={0,0,0},color={0,1,1}}, {p={100,0,0},color={1,1,0}}, {p={0,100,0},color={1,0,1}}, {p={100,100,0},color={1,0,0}}, }, prim={ {type=\"triangle\",pref={1,2,3}}, {type=\"line\",pref={2,3,3,4,4,2}}, {type=\"point\",pref={2,4}}, } } poly(obj) Supporting primitives Assumepref={1,2,3,4,5,6}. pref means point reference. The semicolon (;) is the end mark of one primitive drawing. type name Corresponding primitive Drawing order full type name points Points 1;2;3;4;5;6; points pointd 2d point 1;2;3;4;5;6; point disc pointb 3d point 1;2;3;4;5;6; point ball line Single line 123456; single line linef Single 2d line 123456; line flat linec Single 3d line 123456; line capsule linel Loop line 1234561; line loop linelf Loop 2d line 1234561; line loop flat linelc Loop 3d line 1234561; line loop capsule lines Lines 12;34;56; lines linesf 2d lines 12;34;56; lines flat linesc 3d lines 12;34;56; lines capsule triangles Triangle meshes 123;456; triangles triangleb Bridge structure triangle meshes 123;324;345;546; triangle bridge triangler Radial structure triangle meshes 123;134;145;156; triangle radial The structure of obj The obj struction is defined by following steps: obj is a table. obj contains 4 keys: point,vertex,prim,detail. The 4 keys in obj have their own value called pointArray,vertexArray,primArray,detailList. pointArray is required. vertexArray is optional. primArray is required. detailList is optional. The above-mentioned value names that are Array suffixed holds N sub-tables, where N can be defined by users. The kth sub-table of pointArray is called point[k] or \"The kth point\". The kth sub-table of vertexArray is called vertex[k] or \"The kth child-point\". The kth sub-table of primArray is called prim[k] or \"The kth primitive\". The detailList and Points, child-points, primitives, has some unsubdividable units：the Key-value pairs. We call these keys K, and values V. K should only contains alphabets, numbers and underlines. And K shouldn't be all numbers. V has 7 types: 1D, 2D, 3D, 4D, string, texture id and index serial. For all double floating numbers x,y,z,w x or {x} is 1D V. {x,y} is 2D V. {x,y,z} is 3D V. {x,y,z,w} is 4D V. \"Hello! PixelsWorld!\" is string V. When (K ends up with \"_tex\") and (V is integer and the corresponding texture exists), it is texture id V. For integer serial a1,...,an,{a1,a2,a3,...,an} is index serial V. For all point[k], there must be a K named \"p\" to represents the location, or it is a invalid point. For all vertex[k], there must be a K named \"pref\" and its V is integer to represent the reference point id, or it is an invalid child-point. For all prim[k], there must be a K named \"type\" and its V is string to represents the type of the primitive. And there also must be a K named \"vref\"or \"pref\" and its V is index serial to represent the order of points drawing. Override priority For same K, the following override priority is defined: Same with Houdini. vertex point prim detail Example: The following obj's prim contains color attribute (Red), So we will get a red triangle. PrimColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0}}, {p={100,0,0}}, {p={0,100,0}}, }, prim={ {type=\"triangle\",pref={1,2,3},color={1,0,0}}, }, } poly(obj) This time, both prim and point contains color, and because the priority of point is higher, so the color attribute in pointwill be used, then we will get a colorful triangle. PointColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},color={0,1,1}}, {p={100,0,0},color={1,1,0}}, {p={0,100,0},color={1,0,1}}, }, prim={ {type=\"triangle\",pref={1,2,3},color={1,0,0}}, }, } poly(obj) Usage of vertex Vertex (child-point) inherits all attributes from point. VertexColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0}}, {p={100,0,0}}, {p={0,100,0}}, {p={100,100,0}}, }, vertex={ {pref=1,color={1,0,0}}, {pref=2,color={1,0,0}}, {pref=3,color={1,0,0}}, {pref=2,color={0,1,0}}, {pref=3,color={0,1,0}}, {pref=4,color={0,1,0}}, }, prim={ {type=\"triangle\",vref={1,2,3,4,5,6}}, }, } poly(obj) pref is used to defined which point to be referenced, the full name of pref is Point reference. So the vref means Vertex reference. Note: The index in Lua starts from 1 not 0. Without vertex, the triangle looks like this: NoVertex.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},color={1,0,0}}, {p={100,0,0},color={1,0,0}}, {p={0,100,0},color={1,0,0}}, {p={100,100,0},color={0,1,0}}, }, prim={ {type=\"triangle\",pref={1,2,3,2,3,4}}, }, } poly(obj) Extra shader Yes! You can even write shader in an obj. FragColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},myattribute={1,0}}, {p={100,0,0},myattribute={0,1}}, {p={0,100,0},myattribute={0,0}}, {p={100,100,0},myattribute={1,1}}, }, prim={ { type=\"triangle\", pref={1,2,3,2,3,4}, frag=[==[ #define t ]==] .. tostring(time) .. [==[ void main(){ outColor = vec4(mod(myattribute*10+vec2(t),1),0,1); } ]==], }, }, } poly(obj) Use UV texture Here is an example of how to use uv texture. The integer that its key name ends up with _tex is treated as a texture id. Using an extra shader in a prim can handle more than one textures. UVTex.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},uv={0,0}}, {p={100,0,0},uv={1,0}}, {p={0,100,0},uv={0,1}}, {p={100,100,0},uv={1,1}}, }, prim={ { type=\"triangler\", pref={1,2,4,3}, my_tex=INPUT, }, }, } poly(obj) "},"contents/Lua/TransparencyRender.html":{"url":"contents/Lua/TransparencyRender.html","title":"Transparency render","keywords":"","body":"Render transparent objects Normally, we get the following result when we are about to render a stack of transparent cubes. normalCubes.lua version3() in2out() dim3() fill(1,.5) move(width/2, height/2) for i = 1,10 do move(20,0,200) cube() end The result was wrong, because we cannot see the behind cubes. We should adjust the render order (farthest to nearest) basing on the camera distance to obtain the right blending color. sortCubes.lua version3() in2out() dim3() fill(1,.5) sortarr = {} beginGroup() move(width/2, height/2) for i = 1,10 do move(20,0,200) local x,y,z = global2screen(local2global(0,0,0)) -- Get camera distance sortarr[i] = {z,getTransformMatrix()} -- {distance, transform status} pairs end endGroup() table.sort(sortarr,function(a,b) -- Sort by z distance return a[1] > b[1] end) for i = 1,10 do beginGroup(sortarr[i][2]) -- Apply transform status cube() endGroup() end "},"contents/Lua/RunGLSL.html":{"url":"contents/Lua/RunGLSL.html","title":"Run GLSL in Lua","keywords":"","body":"Run GLSL in Lua Usage glsl.lua version3() glsl(Your_code_string_here) Note: We recommend using [==[Your_code_string_here]==] to quote your string on account of avoiding escape characters. Namely, your code should be like: glsl2.lua version3() glsl([==[ void main(){ outColor = vec4(uv,sin(time*10)/2+.5,1); } ]==]) The following function can run the code from shadertoy.com. shadertoy.lua version3() shadertoy(Your_shadertoy_code_here) "},"contents/GLSL/GLSLCode.html":{"url":"contents/GLSL/GLSLCode.html","title":"GPU Berserker GLSL","keywords":"","body":"GPU Berserker GLSL In this section, we will have a quick look at how the GLSL works in PixelsWorld. What is GLSL? GLSL is an abbreviation of OpenGL Shader Language, which is supported by OpenGL, run on GPU. How to learn it? We recommend The book of shaders Advantage of GPU render If we treat CPU as a supercar, the GPU should be more like a bus. In the case we transport little people, like one or three, the supercar would be nice. (Handle single complicated calculation) But when there are thousands of people need to be transported, it seems that the bus should be the right option. (Render thousands of data symultaneously) The language we are learning, like C/C++, Java, Python, almost are running on CPU. Languages like GLSL, is designed for GPU. When we are about to render a picture. GPU can distribute one repetitive task to a number of \"workers\". If you want to learn more about GLSL, we recommand you to go to shadertoy.com, find some interesting arts and make out why this works. Details Before the GLSL is sent to OpenGL, PixelsWorld will combine pre-defined and post-defined codes to support features of Ae. If you are beginner, you can ignore this section for the moment. PixelsWorld V3.0.0 use #version 330 core. Here are pre-defined and post-defined codes. "},"contents/GLSL/RunGLSL.html":{"url":"contents/GLSL/RunGLSL.html","title":"Run GLSL","keywords":"","body":"Run GLSL Code Make sure you are in GLSL(GPU) mode; Then edit the World rule; You will see there is already some code in the showed up panel; default.shader void main(){ outColor = getColor(uv); } This code is just send the input pixels to the output. You can change the getColor(uv) to vec4(uv,0.0,1.0) for geting a beautiful uv color pattern; uvcolor.shader void main(){ outColor = vec4(uv,0.0,1.0); } Then, press the \"Ok\" button. If everything is right, you will get something in the scene like this: "},"contents/GLSL/GetStart.html":{"url":"contents/GLSL/GetStart.html","title":"Quick start","keywords":"","body":"What it feels like to develop effects with PixelsWorld? PixelsWorld is just like Microsoft Excel. You write function, it will handle the data in the form for you. If we treat the data in form as input pixels, the calculated form as output pixels, Codes in PixelsWorld is the function in Microsoft Excel E.g. Make picture brighter To make a picture brighter, the simplest approach is just add the R,G,B by a number. If in Excel, we need to do something like this: Then we have made all pixels data \"brighter\" ! Here is what we need to write in PixelsWorld: bright_describe.shader outColor=getColor(uv)+vec4(0.2); It means: Get the input pixels (getColor) in current location (uv), and add the 4D vector RGBA by (0.2,0.2,0.2,0.2) (+vec4(0.2)). Finally, send (=) the result to the output pixel(outColor). But if we only write this single line, PixelsWorld cannot work fine. We need to add this line inside a \"shell\" to make it work. The complete version is this: bright.shader void main(){ outColor=getColor(uv)+vec4(0.2); } How to input codes Input picture (Right click to save) (Source artist) Result Add more controls! Mostly we don't just add 0.2 to the picture. We want it to be more controllable. So we can replace the 0.2 to slider[0]. In this way, we can change the value in Parameters panel to change the brightness of your picture. bright_control.shader void main(){ outColor=getColor(uv)+vec4(slider[0]); } But you can find that, if the value is negative, the picture will be transparent, we don't want this happened. Namely we need to avoid modifying the Alpha channel of the picture. bright_control.shader void main(){ vec4 inColor = getColor(uv); inColor.rgb = inColor.rgb + vec3(slider[0]); outColor = inColor; } It means: Save the input pixel into a temporary variable inColor, Add the value of slider[0] to the RGB of inColor, then send the inColor to the outColor. Add label to the parameter Save to preset Finally, we can save the code as a preset for next using. Go to the Preset management to learn more details. Congratulations! You have already mastered the most part of PixelsWorld! In addition to writing codes by yourself, you can go to the shadertoy, find some interesting code and run it in PixelsWorld. See this to learn how to use code from shadertoy. "},"contents/GLSL/Functions.html":{"url":"contents/GLSL/Functions.html","title":"Functions","keywords":"","body":"Functions This section will give a brief introduction of the functions created by us. The functions mentioned in this section could be immediately used without any declaration. "},"contents/GLSL/getColor.html":{"url":"contents/GLSL/getColor.html","title":"getColor","keywords":"","body":"getColor This function has two versions: getColor(vec2) and getColor(int ,vec2). getColor(vec2) Description : Get the color of inLayer in specified position. Parameters : vec2 : uv position. Return : vec4 : a RGBA color. getColor(int,vec2) Description : Get the color of specified layer in specified position. Parameters : int : layer id, -1 (or AE_INPUT_LAYER) means inLayer, number between 0 and 9 means the corresponding Layer Parameter in your plugin panel. (PW_TEMP_LAYER (which is -2) is provided in Lua render mode) vec2 : uv coordinates. Return : vec4 : a RGBA color. NOTE : So in other words, getColor(AE_INPUT_LAYER,uv); totally equals to getColor(uv); getColor(n,uv); can return the pixels of layer[n]. "},"contents/GLSL/uvxy.html":{"url":"contents/GLSL/uvxy.html","title":"uv2xy,xy2uv","keywords":"","body":"uv2xy,xy2uv This two functions can translate a vec2 between UV Coordinate and XY Coordinate. It just do some multiplication and division for you. uv2xy(vec2) Description : Calculate the xy position for a given uv position. Parameters : vec2 : uv position. Return : vec2 : xy position. NOTE : If your layer size is 1280 x 720. The uv2xy(vec2(0.1,0.5)); will return vec2(128.0,360.0); xy2uv(vec2) Description : Calculate the uv position for a given xy position. Parameters : vec2 : xy position. Return : vec2 : uv position. NOTE : If your layer size is 1920 x 1080. The xy2uv(vec2(192,108)); will return vec2(0.1,0.1); "},"contents/GLSL/LinkParameters.html":{"url":"contents/GLSL/LinkParameters.html","title":"Link parameters","keywords":"","body":"Link parameters The outside parameters are provided for you to do some animation. As you can see, there are 7 types of parameters are provided. Sliders Angles Points 3D Points Checkboxes Colors Layers Each of them have 10 controler for using. Example : link_slider.shader void main(){ outColor = vec4(uv,slider[0],1.0); } If you change the slider 0, the color in your scene would change. Details The parameters decleared in PixelsWorld are as below : parameters.shader uniform float slider[10]; uniform float angle[10]; uniform bool checkbox[10]; uniform vec2 point[10]; uniform vec3 point3d[10]; uniform vec4 color[10]; uniform sampler2D layer[10]; uniform sampler2D inLayer; NOTE : The \"inLayer\" means Input layer. The sampler2D is a value type provided by GLSL, you don't need to understand this value type. If you want to use the layer parameter. Please see the \"getColor\" section \"uniform\" means global value. "},"contents/GLSL/debug.html":{"url":"contents/GLSL/debug.html","title":"Debug","keywords":"","body":"Debug Check the debug checkbox in the plugin panel. If your program contains errors, it will be printed into left top corner of your screen when this is checked. "},"contents/GLSL/Advanced_settings.html":{"url":"contents/GLSL/Advanced_settings.html","title":"Advanced settings","keywords":"","body":"Advanced settings There are several advanced settings in the effect panel. Language It controls which compiler to be used. Wrap U/V sampler This will affect the result of getColor() when sampler the pixels which is outside the boundary of image. Test code (Apply PixelsWorld to a footage.): wrap_uv_sampler.shader void main(){ outColor = getColor(uv*10); } Magnify/Minify sampler This will affect the behavior of getColor() when sampler want to do the interpolation of surrounding pixels. Test code (Apply PixelsWorld to a footage.): wrap_uv_sampler.shader void main(){ outColor = getColor(uv*0.1); } If you want to build the same pixel style effect. Swith this option to Nearest pixel "},"contents/GLSL/predefined.html":{"url":"contents/GLSL/predefined.html","title":"Pre-defined code","keywords":"","body":"Predifined code Before run shader code, PixelsWorld conbine your input with some predifined code to support some features. GLSL mode only has pre-define code. shadertoy mode has both pre-define and post-define code. GLSL mode Pre-define code pre_frag_shader_glsl.frag #define gl_Position uv2xy(uv) #define gl_FragCoord uv2xy(uv) #define gl_FragColor outColor #define INPUT_LAYER_INDEX -1 #define OUTPUT_LAYER_INDEX -2 #define AE_INPUT_LAYER -1 #define PW_TEMP_LAYER -2 out vec4 outColor; in vec2 uv; uniform float slider[10]; uniform float angle[10]; uniform bool checkbox[10]; uniform vec2 point[10]; uniform vec3 point3d[10]; uniform vec4 color[10]; uniform sampler2D layer[10]; uniform vec2 layerResolution[10]; uniform sampler2D inLayer; uniform sampler2D outLayer; uniform float time; uniform float inpoint; uniform float duration; uniform float comp_time; uniform vec4 date; uniform float fps; uniform float width; uniform float height; uniform vec2 origin; uniform vec2 resolution; uniform vec2 downsample; uniform mat4 camera_matrix; uniform vec4 camera_info; // x,y: resolution, z: distance to plane, w: distance to focus. uniform bool camera_perspective; uniform sampler1D inWaveL; uniform sampler1D inWaveR; uniform float inWaveN; uniform float inWaveS; uniform sampler1D inSpecL; uniform sampler1D inSpecR; uniform float inSpecN; vec4 getColor(int layerId,vec2 coord) { if(layerId==AE_INPUT_LAYER) return texture(inLayer,coord); if(layerId==PW_TEMP_LAYER) return texture(outLayer,coord); else if(layerId>=0 && layerId shadertoy mode Pre-define code pre_frag_shader_shadertoy.frag #define gl_Position (_PixelsWorld_uv * iResolution.xy) #define gl_FragCoord (_PixelsWorld_uv * iResolution.xy) #define gl_FragColor _PixelsWorld_outColor uniform vec3 iResolution; uniform float iTime; uniform float iTimeDelta; uniform int iFrame; // uniform float iChannelTime[4]; uniform vec4 iMouse; uniform vec4 iDate; uniform sampler2D iChannel0; uniform sampler2D iChannel1; uniform sampler2D iChannel2; uniform sampler2D iChannel3; uniform vec3 iChannelResolution[4]; #define INPUT_LAYER_INDEX -1 #define OUTPUT_LAYER_INDEX -2 uniform float _PixelsWorld_slider[10]; uniform float _PixelsWorld_angle[10]; uniform bool _PixelsWorld_checkbox[10]; uniform vec2 _PixelsWorld_point[10]; uniform vec3 _PixelsWorld_point3d[10]; uniform vec4 _PixelsWorld_color[10]; uniform sampler2D _PixelsWorld_layer[10]; uniform vec2 _PixelsWorld_layerResolution[10]; uniform sampler2D _PixelsWorld_inLayer; uniform sampler2D _PixelsWorld_outLayer; uniform float _PixelsWorld_time; uniform float _PixelsWorld_inpoint; uniform float _PixelsWorld_duration; uniform float _PixelsWorld_comp_time; uniform vec4 _PixelsWorld_date; uniform float _PixelsWorld_fps; uniform float _PixelsWorld_width; uniform float _PixelsWorld_height; uniform vec2 _PixelsWorld_origin; uniform vec2 _PixelsWorld_resolution; uniform vec2 _PixelsWorld_downsample; uniform mat4 _PixelsWorld_camera_matrix; uniform vec4 _PixelsWorld_camera_info; uniform bool _PixelsWorld_camera_perspective; uniform sampler1D _PixelsWorld_inWaveL; uniform sampler1D _PixelsWorld_inWaveR; uniform float _PixelsWorld_inWaveN; uniform float _PixelsWorld_inWaveS; uniform sampler1D _PixelsWorld_inSpecL; uniform sampler1D _PixelsWorld_inSpecR; uniform float _PixelsWorld_inSpecN; in vec2 _PixelsWorld_uv; out vec4 _PixelsWorld_outColor; Post-define code post_frag_shader_shadertoy.frag void main(){ mainImage(_PixelsWorld_outColor, _PixelsWorld_uv * iResolution.xy); } "},"contents/GLSL/shadertoy.html":{"url":"contents/GLSL/shadertoy.html","title":"Template Zone shadertoy","keywords":"","body":"Template Zone shadertoy Usage On shadertoy mode, you can run codes from shadertoy.com. Note It doesn't mean all code from shadertoy can be support perfectly in PixelsWorld. Some like \"VR\", \"Loop buffer reference\" are not support. Details Add _PixelsWorld_ prefix to use variables that exist in GLSL mode. E.g. slider[0] on GLSL mode = _PixelsWorld_slider[0] on shadertoy mode. It is not recommended to define your own _PixelsWorld_ prefixed variables. "},"contents/Lua/JavaScript.html":{"url":"contents/Lua/JavaScript.html","title":"World Outskirts JavaScript","keywords":"","body":"JavaScript Code Javascript can be executed by function js(\"Your code\") on Lua (CPU & GPU) language mode. executeJS.lua version3() js(\"alert('Hello PixelsWorld!')\"); Note: Due to the structure of Ae, running js code inside PixelsWorld is not recommended. You are supposed to use js to do some simple calculations basing on local variables. "},"contents/Lua/CMDCode.html":{"url":"contents/Lua/CMDCode.html","title":"World Bed Rocks CMD","keywords":"","body":"CMD Code CMD commands can be executed by function cmd(\"Your cmd commands\") on Lua (CPU & GPU) language mode. executeCMD.lua version3() cmd(\"echo Hello PixelsWorld! & pause\"); "},"contents/Serial/SerialAttention.html":{"url":"contents/Serial/SerialAttention.html","title":"Apointments","keywords":"","body":"Appointments One serial number contains N Register number (N >= 1) One Register number registers one PC permanently. One Register number can be shared in any version of Ae in a PC. Registering costs one Register number, deactivating recovers one Register number Only Registering and Deactivating need internet. You can use PixelsWorld offline after registering completed. You don't have to deactivate before re-installing your OS, UNLESS you changed the hardwares like CPU or mainboard. When you finished re-installing your OS, register PixelsWorld again, this kind of registration doesn't cost the Register number. Contact with us if you foget to deactivate your serial number and you have already changed your CPU and mainboard. Serial number does't bind with any personal information. You can BUT NOT RECOMMAND sell it. MiLai visual performance group is not responsible for ANY trouble that happened in this kind of deals. The default value of Register numbner is 1. If you have more than one PC and you also want to run PixelsWorld on your multiple machines at the same time. Please purchase the corresponding number of PixelsWorld, we will send you the Serial number with Register number specified by you. "},"contents/QA/EntryPointErr.html":{"url":"contents/QA/EntryPointErr.html","title":"Error: Couldn't find main entry point for PixelsWorld.aex (48::72)","keywords":"","body":"Error: Couldn't find main entry point for PixelsWorld.aex (48::72) If the next error occurred, please check these things list below: Use Creative Cloud to update your Ae to the latest version(We recommand Ae CC 2019 16.1.3+ or 2020 17.5.1+) Windows10 should be up-to-date(Windows 10 20H2 or later version is recommended) Graphic card drivers should be up-to-date Graphic card should support OpenGL 3.3 or later(You can use OpenGL Extensions Viewer tool to get the version info) There should be OpenCL.dll in C:\\Windows\\System32 "}}