{"./":{"url":"./","title":"Be the Creator of your World","keywords":"","body":"Be the Creator of your world PixelsWorld documentation version: v3.6.0 Author ZzStarSound History v2.3.1 v1.0 中文版 日本語 Slack Forum Download docs(English) Download docs(中文) Download docs(日本語) Welcome to PixelsWorld! We have compressed all essence of how to use PixelsWorld in this section. If you master it, you will be a new creator of PixelsWorld! Simply speaking PixelsWorld renders graphics basing on your code Here are some key points you have to know. PixelsWorld is like a simple Game Engine. All code provided by you will run in a Lua engine. Writing code in PixelsWorld is like writing a powerful Expression. PixelsWorld supports: Maths operations texture operations customer filters GLSL Code from shadertoy.com PixelsWorld is almost the \"Wrangle Node\" if you are familiar with Houdini. PixelsWorld can draw simple 2D/3D geometries. Details >>> Video tutorials We highly recommend starting with watching our basic tutorial. Basic >>> 2D Transform >>> Lua Example: Drawing a house Here we give a code example of drawing a house in Lua mode. DrawHouse3.lua version3() -- Use version 3, always call this in the first line. move(width/2, height/2) -- Move the Paintbrush to the center of your screen rotateX(PI) -- Rotate Paintbrush Coordinate along X axis 180 degrees fill(1,1,0) -- Apply yellow pigment (Red=1,Green=1,Blue=0) rect(100) -- Draw a 100x100px square fill(1,0,0) -- Use red pigment(Red=1,Green=0,Blue=0) move(0,50) -- Move the Paintbrush Coordinate 50px upwards tri(150,100) -- Draw a isoceles triangle in 150px of base, 100px of height. Here we want to add some extra controls to the scene like color combination controllers of our house. DrawHouse3.lua version3() -- Use version 3, this is what you always have to call in the first line. move(width/2, height/2) -- Move the Paintbrush Coordinate to the center rotateX(PI) -- Rotate Paintbrush Coordinate along X axis 180 degrees fill(color(0)) -- Use color #0 rect(100) -- Draw a 100x100px square fill(color(1)) -- Use color #1 move(0,50) -- Move the Paintbrush Coordinate 50px upwards tri(150,100) -- Draw a isoceles triangle in 150px of base, 100px of height. Then click the Ok button, the house will... disappear! Indeed, our house is still drawn onto the layer, but because the default color of the color controller is black, so as a result, the house seems to disappear. To fix it, open the Parameter list, find the first 2 Color controllers, change them to whatever you want. Mayor is me! Draw more houses One tremendous advantage of code is the capability of handling repetitive operations. Needless to say, Lua language allows you to write looping code. DrawHouse3.lua version3() -- Use version 3, this is what you always have to call in the first line. move(width/2, height/2) -- Move the Paintbrush Coordinate to the center rotateX(PI) -- Rotate Paintbrush Coordinate along X axis 180 degrees for i=1,3 do -- Begin repeat (3 times) fill(color(0)) -- Use color #0 rect(100) -- Draw a 100x100px square fill(color(1)) -- Use color #1 move(0,50) -- Move the Paintbrush Coordinate 50px upwards tri(150,100) -- Draw a isoceles triangle in 150px of base, 100px of height. move(0,-50) -- Move the Paintbrush Coordinate back move(175,0) -- Move the Paintbrush Coordinate 175px rightward end -- End repeat If you don't want to write functions like \"move back\". Write in this way: DrawHouse3_1.lua version3() -- Use version 3, this is what you always have to call in the first line. move(width/2, height/2) -- Move the Paintbrush Coordinate to the center rotateX(PI) -- Rotate Paintbrush Coordinate along X axis 180 degrees for i=1,3 do -- Begin loop (3 times) fill(color(0)) -- Use color #0 rect(100) -- Draw a 100x100px square fill(color(1)) -- Use color #1 beginGroup() -- NEW LINE! Begin to record transformations of Paintbrush Coordinate move(0,50) -- Move the Paintbrush Coordinate 50px upwards tri(150,100) -- Draw a isoceles triangle in 150px of base, 100px of height. endGroup() -- NEW LINE! This line will automatically calls 'move(0,-50)' move(175,0) -- Move the Paintbrush Coordinate 175px rightward end -- End loop Finally, we want to give the controllers names: Save code as a preset. Note: The Administrator mode is required in this step if you installed Ae into the disc where your system files are (like C:\\). First of all, add a new Preset column into the popup list: Then, save your preset into the newly created Preset column: Apply preset Select the preset you want to apply, click the Replace button in Presets review area. Congratulations! You have already mastered almost all of PixelsWorld. >>> Next step: Go to the lua chapter for more details >>> Next step: Open the Pandora's Box of shader PixelsWorld structure PixelsWorld ability "},"contents/HowTo.html":{"url":"contents/HowTo.html","title":"Get/Try/Purchase","keywords":"","body":"Get/Try/Purchase Download Purchase/Download PixelsWorld Note: Some presets are under non-commercial license. Put the \"MiLai\" folder into (Your AE root folder)/Support Files/Plug-ins/ Usage Open Adobe After Effects. \"Ctrl + N\"(or \"Command + N\") to create a comp. Create a solid layer. Select the solid you created. Right click it => Effects => MiLai => PixelsWrold. Click \"Edit\" to change \"World formula\". There will be a World formula editor showed up. Find \"Preset list\" and select a column that is interesting to you, select a preset in that column Click the \"Replace\" button. Click the \"Ok\" button. "},"contents/Editor/ScriptWindow.html":{"url":"contents/Editor/ScriptWindow.html","title":"World formula editor","keywords":"","body":"World formula editor Open the formula editor Click the \"Edit\" button in the plugin panel. For demonstrating purpose, we highlight different areas with colored rectangles. ◆Code area Input your creative code here. Language in this panel overrides the Language setting in your plugin panel. (default) selection means current language. ◆Reference list Reference code that would help you to remind some frequently-used functions are listed here, this list is read-only currently. ◆Parameter settings Here you can see the labels, the default value of parameters, and the language settings. Click the Parameter manager button to manage them. See also Parameter manager Parameter settings are saved with code into preset. ◆Preset list The pop-up menu contains all preset files in your local disc. Some definitions about presets: A preset is a file with .pwp postfix, JSON format and located beside plugin. It is represented as a Preset column in PixelsWorld. Preset's file name is equal to the column name. One Preset column contains several Presets Presets contained in a Preset column are listed below the pop-up menu. ◆Formula preview Formula preview is where you can preview the code in the preset you selected. Click Replace button to apply preset code. NOTE: Code in Code area will be overwritten. By default, click Replace button will also apply parameter settings. If this is not expected, uncheck Apply when replace in Parameter settings preview area. If you want to joint the preset code in front of your current code, click button. If you want to joint the preset code behind your current code, click Bottom>> button. ◆Parameter settings preview Parameter settings preview is where you can preview the parameter settings of the selected Preset. Click Apply button to override the current parameter settings. Apply when replace means weather or not applies parameter settings when you click the Replace button in the Formula preview area. "},"contents/Editor/ParameterWindow.html":{"url":"contents/Editor/ParameterWindow.html","title":"Parameter manager","keywords":"","body":"Parameter manager Click the Parameter manager button on the World rule editor to start Parameter manager. This is the Parameter manager window: Rule Type the labels into the first input area, the default values into the following input area. (Decimal number 0~1) Clear names button clears label names. Clear all names button clears all label names. Reset names button resets label names to default. Reset all names button resets all label names to default. Reset values button resets values. Reset all value button resets all values. Notice: The ranges of the points and the 3d points are 0~1. If the size of the layer is 1280x720, 0.5, 0.5 of default point value means 640x360 in the plugin panel. Encoding PixelsWorld supports utf-8. Some not supported characters are converted to ? in the plugin panel. If you work with international authors. We recommand using ASCII characters for all labels. "},"contents/Editor/SavePresets.html":{"url":"contents/Editor/SavePresets.html","title":"Preset management","keywords":"","body":"Preset management Save preset In World formula editor, you can click the Save as preset button to save your code as a preset. Note: Identical name incurs overriding. Override save In World formula editor, click the Save as preset button, and type the existing name to override the previous preset. Note All operation in the editor is not undoable. Rename presets Double click the preset to rename a preset. Use name EXCEPTREMOVE and SORT. Sort presets Double click one preset and type in SORT. Remove presets Double click the preset you want to remove and type in REMOVE. Add preset column Click Add button in the Preset list Note: Name must be unique. If failed, you might need to re-open Ae with administrator mode. Format Format: utf-8, JSON Not encrypted. Contribute presets Send your preset to ZzStarSound@gmail.com with your name and detailed description. "},"contents/Lua/LuaCode.html":{"url":"contents/Lua/LuaCode.html","title":"World Center Lua","keywords":"","body":"Lua Code The instructions that we wrote in chapter 1 is called Lua Lua is a lightweight, high-level, multi-paradigm programming language designed primarily for embedded use in applications. ——Wiki) Version : Lua5.3 Note: Beginning PixelsWorld v3.2.0, using Lua5.4 So Lua plays the role that manages the communication between Ae and Users. It is quite similar to Ae script and expression language. Basically, you can draw highly variant scenes by remembering just a few words. For instance, if you want to draw a cube that can interact with Ae camera, just type: DrawCube.lua version3() move(width/2,height/2) dim3() cube(300) dim3() means draw shapes in 3 dimension. If you want to run GLSL code, just type: RunGlsl.lua version3() glsl([==[ void main(){ vec3 col = 0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4)); outColor = vec4(col,1.0); } ]==]) If you want to run code from shadertoy, just type: RunShadertoy.lua version3() shadertoy([==[ void mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec2 uv = fragCoord/iResolution.xy; vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)); fragColor = vec4(col,1.0); } ]==]) In Lua, you can : Get pixels data Write pixels data Run JavaScript Run GLSL Get parameters data Run outer C library (COOL!) Load outer lua module Because of the advanced features, the users who using Lua render mode should have basic programming abilities and have a primary understanding of the Lua language. If you have no idea about Lua, don't worry about it, it is pretty easy to learn. PixelsWorld structure "},"contents/Lua/RunLua.html":{"url":"contents/Lua/RunLua.html","title":"Run Lua","keywords":"","body":"Run Lua code Switch your language to Lua ( CPU & GPU ) And input the code below : hello.lua version3() a = 5+6 b = \"PixelsWorld\" c = \"is cool!\" d = time e = slider(0) f = \"5 + 6 = \" .. a .. \"\\nMessage : \" .. b .. \" \" .. c .. \"\\nCurrent time is : \" .. d .. \" (s)\\nValue of slider0 is : \" .. e print(f) a..b means combine variable a and b as string. print() reports message to your screen. slider() fetches the value of a specified parameters. You are allowed to add ; at the end of each line, but it is not indispensable. Lua regards the \\n(line break) as the end mark of one section of code. A message will show up in the left top corner of your screen. "},"contents/Lua/WriteLocalCode.html":{"url":"contents/Lua/WriteLocalCode.html","title":"Load local code","keywords":"","body":"Load local Lua code If you don't prefer to use PixelsWorld's editor, PixelsWorld can read txt file from the local disc. So you can write the file with the IDE you like. Don't put the file to system disc(C:\\ disc). loadTxt.lua version3() runFile([[d:\\mycode.txt]]) -- Replace to your path The reason we use [[d:\\mycode.txt]] but not \"d:\\mycode.txt\" is that the latter's \\ will cause escape problem. You can use any postfix you want(*.lua, *.code, *.magic) as long as its contents are texts. Use the following code to read the code file beside your Ae project file. loadTxt.lua version3() runFile( projectFolder .. [[mycode.txt]]) -- Replace to your file name Note: You should save your Ae project to a local disc or the projectFolder is just an empty string. It is not over! Don't forget to refresh PixelsWorld If you saved your code file, PixelsWorld cannot read it immediately. You should then hold Ctrl + Alt, click the logo image, this will trigger the rerender of PixelsWorld, then your new code will be read by PixelsWorld. The logo images here appear with a constant probability distribution. We have designed lots of beautiful logo images putting here for those who like collecting them. "},"contents/Lua/LinkParameters.html":{"url":"contents/Lua/LinkParameters.html","title":"Link parameters","keywords":"","body":"Link parameters parameters.lua slider(id) -- return 1 double angle(id) -- return 1 double point(id) -- return 2 double point3d(id) -- return 3 double checkbox(id) -- return 1 boolean color(id) -- return 3 double layer(id,x,y) -- return 4 double If there are more than one values returned, the corresponding number of variables need be declared to catch the values. For instance, the point() function: point.lua version3() x,y = point(0) -- Declear two variables x and y println('x is ' .. x) println('y is ' .. y) "},"contents/Lua/globals.html":{"url":"contents/Lua/globals.html","title":"Globals","keywords":"","body":"Globals Global constants Here are some global constants in PixelsWorld: const.lua PI -- the Circular constant pi TPI -- two pi HPI -- half pi QPI -- quarter pi E -- the Natural number e PHI -- the Golden ratio phi R2 -- square root 2 R3 -- square root 3 R5 -- square root 5 R7 -- square root 7 INPUT -- Index of input image -1 TEMP -- Index of temp image -2 OUTPUT -- Index of output image -3 PARAM0 -- Index of the #0 layer parameter 0 PARAM1 -- Index of the #1 layer parameter 1 PARAM2 -- Index of the #2 layer parameter 2 PARAM3 -- Index of the #3 layer parameter 3 PARAM4 -- Index of the #4 layer parameter 4 PARAM5 -- Index of the #5 layer parameter 5 PARAM6 -- Index of the #6 layer parameter 6 PARAM7 -- Index of the #7 layer parameter 7 PARAM8 -- Index of the #8 layer parameter 8 PARAM9 -- Index of the #9 layer parameter 9 platform -- Windows == 0, no other platforms. host -- Ae == 0, no other hosts. Global variables Here are some global variables in PixelsWorld: globalvars.lua depth -- Dpc: 8,16,32 width -- Width input image height -- Height input image time -- Current time(s) duration -- Duration of current layer(s) inpoint -- Inpoint of current layer(s) compTime -- Comp current time(s) pluginFolder -- The plugin folder(utf8) projectName -- Project name(utf8) projectPath -- Project path(utf8) projectFolder -- Project folder(utf8) ds_width -- Width of downsampled input image ds_height -- Height of downsampled input image origin_x -- The X coordinate of left top corner of input image in the layer coordinate. origin_y -- The Y coordinate of left top corner of input image in the layer coordinate. Print the globals Globals can be printed by using following code: printGlobals.lua version3() in2out() for k, v in pairs(_G) do print(k) print(\" \" .. type(v) , .5,.5,.5) print(\" \".. tostring(_G[k]),0,1,1) println(\"\") end "},"contents/Lua/FuncList.html":{"url":"contents/Lua/FuncList.html","title":"Function list","keywords":"","body":"Function List This page covers all functions provided in Lua render mode. Required functions version3 Parameter link functions slider, angle, point, point3d, checkbox, color, layer Print message functions print, println, alert Transform functions move, scale, rotate, rotateX, rotateY, rotateZ, twirl beginGroup, endGroup, beginGlobal, endGlobal global2local, local2global, global2screen, screen2global getTransformMatrix Draw functions Primitives tri, quad, rect, circle, ellipse, par, line cube, tet, cone, ball, tube image, imageAlign, imageAnchor text, textSize, textFont, textAlign, textAnchor, textAlignOuter, textInterval, textAdvanceScale coord, grid poly, setPoly background, in2out Attribute controls dim2, dim3 perspective, noPerspective fill, noFill, stroke, noStroke, dot, noDot wireframe, noWireframe blendAlpha, noBlendAlpha back, noBack pure, phong, anime rgba, depth, normal setDepth Lights ambientLight, pointLight, parallelLight clearLight, getLight Camera function aeCamera, lookAt, viewSpace Stroke details strokeWidth, strokeDivision, strokeGlobal, strokeLocal Dot details dotRadius, dotDivision, dotGlobal, dotLocal Output details smooth, noSmooth Texture operations newTex, delTex, getSize, swapTex, drawTo, castTex, blendTex, copyTex, savePNG, loadPNG, saveEXR, loadEXR, rotateTex, flipTex, resizeTex, trimTex Utility tools r2d, d2r map clamp step smoothStep bezier rgb2hsl,hsl2rgb,rgb2hsv,hsv2rgb,rgb2cmy,cmy2rgb,rgb2cmyk,cmyk2rgb,cmy2cmyk,cmyk2cmy,hsl2hsv,hsv2hsl utf8ToLocal, localToUtf8 getGLInfo, getDrawRecord, getStatus getAudio loadString saveString Read/Write pixels functions getColor, setColor, getSize, Run code functions shadertoy, glsl, cmd, lua, runFile, txt Detailed descriptions version3 version3() function must be called in the first line. It put all functions in the table pw3 to the global field. If you don't call it, you need to add a pw3. prefix to all the functions provided by PixelsWorld. For instance, the following demonstrated function print() should be pw3.print(). On the contrary, If you call the function version3() in the first line, the pw3. prefix could be omitted. This function is designed for backward compatibility. We recommend calling version3() in the first line any time you use Lua render mode. version3.lua version3() println(\"Hello PixelsWorld! \") without_version3.lua pw3.println(\"Hello PixelsWorld! \") print print(str),print(str,brightness),print(str,r,g,b),print(str,r,g,b,a) prints message to the left top corner of your scene. print.lua version3() print(\"Hello PixelsWorld! \") str = \"Hello, I am colorful PixelsWorld! \" for i=1,#str do local c = str:sub(i,i) local phase = math.sin(i/#str*TPI + time*10) / 2 + .5 print(c,phase,1-phase,1,1) end println println(str),println(str,brightness),println(str,r,g,b),println(str,r,g,b,a) prints message to the left top corner of your scene, this function adds \\n in the end of input string. println.lua version3() println(\"Hello PixelsWorld! \") str = \"Hello, I am colorful PixelsWorld! \" for i=1,#str do local c = str:sub(i,i) local phase = math.sin(i/#str*TPI + time*10) / 2 + .5 -- println(c,phase,1-phase,1,1) print(c,phase,1-phase,1,1) end alert alert(str) prints caution message, equals to println(str,1,1,0,1) alert.lua version3() alert(\"Warning: Write your message here! \") move move(x,y),move(x,y,z)moves Paintbrush. All transforms are done basing on the Paintbrush coordinate. Example: move.md version3() coord() -- show Paintbrush coordinate move(100,0) coord() -- show Paintbrush coordinate move(0,100) coord() -- show Paintbrush coordinate Finally, the Paintbrush is located at (100,100,0). scale scale(ratio),scale(x,y),scale(x,y,z)scales the Paintbrush coordinate. All transforms are done basing on the Paintbrush coordinate. scale.lua version3() move(100,100) scale(2) rect(50,25) no_scale.lua version3() move(100,100) --scale(2) rect(50,25) rotate rotateX rotateY rotateZ rotate(theta)rotates Paintbrush with theta radians. rotateX(theta) rotates Paintbrush along X axis. rotate(theta) equals to rotateZ(theta). All transforms are done basing on the Paintbrush coordinate. If you are not familiar with radians, use d2r(degree) to convert a degree to a radian. For example：rotate(d2r(90)) means rotate 90 degrees. rotate_degree.lua version3() move(100,100) rotate(d2r(45)) rect(50,25) rotate_radian.lua version3() move(100,100) rotate(PI/4) rect(50,25) rotateX.lua version3() dim3() move(100,100) grid() coord() rotateX(d2r(45)) cube(50,25,10) rotateY.lua version3() dim3() move(100,100) grid() coord() rotateY(d2r(45)) cube(50,25,10) rotateZ.lua version3() dim3() move(100,100) grid() coord() rotateZ(d2r(45)) cube(50,25,10) twirl twirl(theta,x,y,z) rotates Paintbrush along (x,y,z) axis with theta radians. For example, above-mentioned rotateX(theta) equals to twirl(theta,1,0,0). All transforms are done basing on the Paintbrush coordinate. twirl is an matrix implementation of quaternion rotation. twirl.lua version3() dim3() move(100,100) grid() coord() stroke(1,1,0) line(-50,-50,-50,50,50,50) stroke(0,0,0) twirl(d2r(90),1,1,1) cube(50,25,10) beginGroup endGroup beginGroup(),endGroup() creates a children transformation group. Transformations(move,scale,rotate,twirl) between beginGroup() and endGroup() will be canceled after calling endGroup(). beginGroup(mat) pushes mat as a children transformation group (Use getTransformMatrix to get the transform matrix). It equals to pushMatrix() and popMatrix() in Processing. Example: The following two code are equivalent. group.lua version3() for i = 1,6 do beginGroup() move(i*25,i*25) rotate(d2r(15*i)) rect(25) endGroup() end without_group.lua version3() for i = 1,6 do move(i*25,i*25) rotate(d2r(15*i)) rect(25) rotate(d2r(-15*i)) move(-i*25,-i*25) end beginGlobal endGlobal Draw functions between beginGlobal and endGlobal will draw shapes in global coordinates. beginGlobal.lua version3() move(100,100) fill(0,1,0) -- green rect(50) -- Dran on (100,100,0) beginGlobal() fill(1,0,0) -- red rect(50) -- Draw on (0,0,0) endGlobal() move(100,100) fill(0,0,1) -- blue rect(50) -- Draw on (200,200,0) global2local global2local(x,y,z) converts a global point to a local point. Returns 3 doubles. global2local.lua version3() move(100,100) rect(25) move(0,50) rotate(d2r(30)) coord() x,y,z=global2local(100,100,0) println(\"The local coordinate of the rectangle is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") local2global local2global(x,y,z) converts a local point to a global point. Returns 3 doubles. local2global.lua version3() move(100,100) move(0,50) rotate(d2r(30)) coord() move(25,50) rect(25) x,y,z=local2global(0,0,0) println(\"The global coordinate of the rectangle is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") global2screen global2screen(x,y,z) converts a global point to a screen point. Returns 3 doubles. The result is affected by perspective mode. global2screen.lua version3() dim3() move(100,100,0) move(0,50,0) rotateZ(d2r(30)) coord() move(25,50,0) cube(25) x,y,z=global2screen(local2global(0,0,0)) println(\"The screen coordinate of the rectangle is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") screen2global screen2global(x,y,z) converts a screen point to a global point. Returns 3 doubles. The result is affected by perspective mode. screen2global.lua version3() dim3() x,y,z=screen2global(0,0,0) println(\"The global coordinate of the camera is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") getTransformMatrix getTransformMatrix() returns a column major 4x4 transform matrix. mat[i][j] returns the entry in ith column jth row. (i,jrange: 1~4) matrix.lua version3() dim3() beginGroup() move(width/3,height/3) twirl(d2r(30),1,1,1) cubetransform = getTransformMatrix() endGroup() beginGroup(cubetransform) cube(50) endGroup() tri tri(radius) draws a regular triangle with radius radius, and the triangle will point to the positive direction of the Y-axis. tri() equals to tri(100) tri(w,h)draws a triangle with base length w and height h. tri(p1x,p1y,p2x,p2y,p3x,p3y) draws a triangle basing on 3 points p1,p2,p3. tri(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z) draws a triangle basing on 3 points p1,p2,p3. Add dim3() after version3(), and add a camera layer to your Ae comp to view the 3D triangle. The first 3 functions set normals to (0,0,-1) basing on the current Paintbrush coordinate. The last 2 functions calculate normals with formula: cross(p1-p2,p3-p2). tri is an abbreviation of triangle tri1.lua version3() move(width/2,height/2) tri(100) tri5.lua version3() dim3() move(width/2,height/2) tri(0,0,100,50,0,0,0,50,0) quad quad(p1x,p1y,p2x,p2y,p3x,p3y,p4x,p4y) quad(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z,p4x,p4y,p4z) Draws 2 triangles with order: p1,p2,p3,then p1,p3,p4. quad.lua version3() move(200,100) quad(0,0,75,0,50,40,0,15) rect rect(size) draws a square with size. rect() equals to rect(100) rect(width,height) draws a rectangle with width width and height height. The intersection point of the rectangle is at the origin of the Paintbrush coordinate. rect is an abbreviation of rectangle. rect.lua version3() move(200,100) rect(100,75) circle circle(radius) draws a circle with radius radius. circle() equals to circle(100) circle(radius, div) draws a circle with radius radius, and subdivision div. Default subdivision: 128 circle.lua version3() move(100,100) fill(1,0,0) circle(25) move(100,0) fill(0,1,0) circle(25,10) move(100,0) fill(0,0,1) circle(25,3) ellipse ellipse(radiusx,radiusy)draws an ellipse with x radiusradiusx, y radius radiusy. ellipse() equals to ellipse(100,100) ellipse(radiusx,radiusy,div) draws an ellipse with x radiusradiusx, y radius radiusy and subdivision div. Default subdivision: 128 ellipse.lua version3() move(100,100) fill(1,0,0) ellipse(25,15) move(100,0) fill(0,1,0) ellipse(25,15,10) move(100,0) fill(0,0,1) ellipse(25,15,4) line line(p1x,p1y,p2x,p2y) draws a line. line(p1x,p1y,p1z,p2x,p2y,p2z) draws a 3d line. line() equals to line(0,0,0,100,100,100) Use stroke(r,g,b) to change the color. UsestrokeWidth(width) to change the width. Use noStroke() to turn off line render, stroke() to turn on line render. line.lua version3() move(200,100,0) stroke(1,0,0) line(0,0,0,50) move(100,0,0) stroke(0,1,0) line(0,0,0,50) move(100,0,0) stroke(0,0,1) line(0,0,0,50) line_circle.lua version3() math.randomseed(1) num = 32 move(width/2,height/2) for i=1,num do beginGroup() rotateZ(d2r(360/num*i)) strokeWidth(math.random()*3) line(0,0,100,0) endGroup() end par par(x) draws a point at(x,0,0). par(x,y) draws a point at(x,y,0). par(x,y,z) draws a point at(x,y,z). par() equals to par(0,0,0) By default, the point rendering is turned off, use dot() to turn it on. You can call noDot() to turn it off again. dotRadius(radius) controls point radius. dot(r,g,b) controls point color. dotGlobal() makes point be avoid to be squeezed by scale. By default, points are rendered with dotLocal(). par.lua version3() dot() dotRadius(3) move(200,100) par() dot(1,0,0) dotRadius(7) move(100,0) par() cube cube(size) draws a cube with size size cube(sizex,sizey,sizez) draws a cuboid with dimension sizex,sizey,sizez. cube() equals to cube(100) cube() Negative inputs or negative scale() would cause wrong normals. cube.lua version3() dim3() move(200,100,0) rotateY(d2r(30)) rotateX(d2r(30)) cube(40,25,10) tet tet(radius) draws a regular tetrahedron with radius radius. tet() equals to tet(50) tet(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z,p4x,p4y,p4z) draws tetrahedron basing on 4 points p1,p2,p3,p4. The 3rd function generates normals basing on tri function and calls it with the following points order: p1,p2,p3; p2,p1,p4; p3,p2,p4; p1,p3,p4.. See also: tri. tet is an abbreviation of tetrahedron. tet.lua version3() dim3() move(200,100,0) tet(0,0,0, 100,0,0, 0,100,0, 30,20,-50 ) cone cone(size) draws a cone with base circle radius size and height 2*size. cone() equals to cone(50). cone(radius,height) draws a cone with base circle radius radius and height height. cone(radius,height,div) draws a cone with base circle radius radius, height height and subdivision div. Default subdivision: 64 If sub is greater than 16, the sidestroke and base point will be hidden. Negative inputs or negative scale() would cause wrong normals. cone.lua version3() dim3() move(100,100,0) beginGroup() rotateY(d2r(60)) cone(25) endGroup() move(100,0,0) beginGroup() rotateY(d2r(60)) noStroke() cone(25) endGroup() move(100,0,0) beginGroup() rotateY(d2r(60)) stroke(1,0,0) dot(1,1,0) dotRadius(3) cone(30,100,12) endGroup() ball ball(radius) draws a sphere with radius radius. ball() equals to ball(50). ball(radius,level) draw a ball with radius radius and subdivision level level. Default subdivision level 4. level must be non-negative. level 0 generates a regular octahedron. If level is greater than 2, the strokes and points will be hidden. Negative inputs or negative scale() would cause wrong normals. ball.lua version3() dim3() move(200,100,0) beginGroup() rotateY(d2r(60)) ball(25) endGroup() move(100,0,0) beginGroup() rotateY(d2r(60)) stroke(0,0.25,0.5) dot(0,0.5,1) dotRadius(3) ball(30,2) endGroup() tube tube(size) draws a tube with base circle radius size and height 2*size. tube() equals to tube(50) tube(radius,height)draws a tube with base circle radius radius and height height. tube(radius1,radius2,height) draws a tube with close base circle radius radius1, far base circle radius radius2 and height height. tube(radius1,radius2,height,div) can change the subdivision. tube(radius1,radius2,height,div,needMesh) can change render 2 base circles or not. tube(radius1,radius2,height,div,needMesh1,needMesh2) can change render 2 base circles or not separately. Default div: 64. needMesh is true by default. If div is greater than 16, the side strokes and the base points will be hidden. Negative inputs or negative scale() would cause wrong normals. tube.lua version3() dim3() move(200,100,0) beginGroup() rotateY(d2r(60)) tube(25) endGroup() move(100,0,0) beginGroup() rotateY(d2r(60)) stroke(1,0.25,0.5) dot(0,0,1) dotRadius(3) tube(30,25,50,8) endGroup() image image(id,width,height) draws an image with width width and height height. id is texture id,PARAM0~PARAM9means texture load from the layer parameters, INPUT means input image, OUTPUT means output image. If id is OUTPUT, it will be slow because we need to take a screenshot of your scene. The difference with in2out(id) is, image(id, width, height) draws a rectangle with a texture, which could interact with the depth buffers, where in2out(id) just copy pixels from one texture to another. This also means the image that is drawn to the screen is inverted by default (The default coordinate system of Ae is Y axis downward), so you may need rotateX(PI) to fix it. (And we don't recommend calling scale(1,-1), which may cause wrong normals problem. Example: render_image.lua version3() dim3() move(width/2,height/2) twirl(d2r(45),-1,1,0) beginGroup() rotateX(d2r(180)) image(INPUT,width,height) endGroup() twirl(d2r(60),1,1,1) cube() imageAlign New in v3.3.0 imageAlign(rule) changes the image orientation rendered by image function. The syntax of rule is as follows rule is a 4-length-string. 1st char should be + or - 2nd char should be one of x,y,z 3rd char should be + or - 4th char should be one of x,y,z rule represents which painter coordinates the texture UV coordinate (the origin is left bottom corner) should align with. By default, the rule is \"+x+y\", it represents u aligns with positive x, v aligns with positive y. imageAlign.lua version3() dim3() move(100,100,0) coord() image(PARAM0,128,128) move(150,0,0) coord() imageAlign(\"+x-y\") image(PARAM0,128,128) move(150,0,0) coord() imageAlign(\"+z-y\") image(PARAM0,128,128) imageAnchor New in v3.5.0. imageAnchor(u,v) specifies the uv position of the anchor point of the image. imageAnchor(a) is a shortcut of imageAnchor(a,a) text New in v3.5.0 text(str) renders text onto the screen. text.lua version3() move(width/2,height/2) textAlign(\"+x-y\") text(\"Hello PixelsWorld!\") By the way, the following functions can control the style of the text. Fill color: fill(r,g,b) Stroke color: stroke(r,g,b) Fill off: noFill() Stroke offnoStroke() Stroke width: strokeWidth(width) Font: textFont(fontFileName) Size of text: textSize(size) Intervals of text: textInterval(dx,dy) Advance scaling: textAdvanceScale(rx,ry) textSize New in v3.5.0 textSize(size,resolution) set the text size to be rendered. size controls the size of the text, resolution controls the resolution of the text. textSize(size) equals to textSize(size,size) textSize.lua version3() textAlign(\"+x-y\") textAnchor(0,1) for i=1,13 do local sz = i + 8 textSize(sz) text(\"~MiLai visual performance group~\") move(0,sz + 4) end textFont New in v3.5.0 textFont(fontFileName) set the font of the text to be rendered. fontFileName is the font-file's name located in C:\\Windows\\Fonts. (Right click the file, click Properties, you would see the font-file's name. E.g.: textFont(\"arial.ttf\"))。 You can also use the full path of a font. Yes, you can load font files in everywhere. (textFont([[D:\\MyFolder\\arial.ttf]])) textFont.lua version3() textAlign(\"+x-y\") textAnchor(0,1) textSize(20) font_list={ {\"arial.ttf\",\"The quick brown fox jumps over the lazy dog. \"}, {\"MATURASC.TTF\",\"The quick brown fox jumps over the lazy dog. \"}, {\"KUNSTLER.TTF\",\"The quick brown fox jumps over the lazy dog. \"}, {\"msmincho.ttc\",\"色は匂へど　散りぬるを\"}, {\"UDDigiKyokashoN-R.ttc\",\"我が世誰ぞ　常ならむ\"}, {\"STXINGKA.TTF\",\"人生得意须尽欢 莫使金樽空对月\"}, {\"msjh.ttc\",\"山氣日夕佳 飛鳥相與還\"}, {\"simsun.ttc\",\"吥葽 莣記莪、伱知道 莪 拿起伱 就 倣吥丅。\"}, {\"STZHONGS.TTF\",\"○●対沵倾注ㄋ珴所侑旳温柔︶ㄣ\"}, } for i=1,#font_list do textFont(font_list[i][1]) text(font_list[i][2]) move(0,28) end textAlign New in v3.5.0 textAlign(rule) sets the alignment rule of the text. See also imageAlign>>> textAnchor New in v3.5.0 textAnchor(x,y) sets the anchor point of the text. See also imageAnchor>>> textAlignOuter New in v3.5.0 textAlignOuter(flag) set if we align text with outer boundary of the text. flag is a bool. textInterval New in v3.5.0 textInterval(x,y) set the intervals of the text texture. Default: x:0, y:0 textAdvanceScale New in v3.5.0 textAdvanceScale(rx,ry) set the scale of advances. Default: rx:1, ry:1 coord coord() draws the current Paintbrush coordinate. coord.lua version3() move(100,100) coord() move(150,0) coord() rotate(d2r(30)) move(50,0) scale(2,1) coord() grid grid() draws a grid with many 100x100px squares. grid.lua version3() move(width/2,height/2) rotate(d2r(30)) grid() setPoly setPoly(obj) analyzes obj only, use poly() to draw the previous set obj to scene. It will be efficient in the case you draw the same obj for many times. See also Poly background background(brightness),background(r,g,b),background(r,g,b,a) draws a pure color rectangle to scene. Notes: This function overrides all shapes you drew before. background.lua version3() background(1,1,0) in2out in2out(id) set the id texture to the scene. in2out() equals to in2out(INPUT) id range: PARAM0~PARAM9 or INPUT. dim2 dim2() set the scene to 2D mode. The 2D mode is on by default, you usually no need to call it. In PixelsWorld, a 2D scene means a 3D scene without depth test and perspective. dim3 dim3() set the scene to 3D mode. Call it immediately after version3(). Note: Use viewSpace to change the far plane dimension if your layer size is not equal to the comp size. Otherwise, the shapes in 3D mode will be rendered to an unexpected position. perspective perspective() set the scene to perspective mode, everything looks small in the distance and big on the contrary. Use viewSpace to change the camera information. Use lookAt to set the location of the camera. Perspective mode is on by default after calling dim3(). noPerspective noPerspective() set the scene to orthogonal mode. noPerspective.lua version3() dim3() n = 20 move(100,100,0) beginGroup() rotateX(d2r(85)) for i=1,n do move(0,300,0) fill(i/n,1-i/n,1) cube(50) end endGroup() move(300,0,0) noPerspective() beginGroup() rotateX(d2r(85)) for i=1,n do move(0,300,0) fill(i/n,1-i/n,1) cube(50) end endGroup() fill fill() turns on fill mode. fill(brightness),fill(r,g,b),fill(r,g,b,a) turns on fill mode and set fill color. Note: If you set Alpha smaller than 1, render far object first, or you will get wrong render results due to the depth test. (This is a feature of OpenGL render) noFill noFill() turns off the fill mode. fill.lua version3() move(200,100,0) fill(1,0,0) rect(50) move(100,0,0) fill(1,1,0) rect(50) move(100,0,0) noFill() rect(50) stroke stroke() turns on the stroke mode. stroke(brightness),stroke(r,g,b),stroke(r,g,b,a) turns on stroke mode and set the stroke color. noStroke noStroke() turns off stroke mode. stroke.lua version3() fill(0) move(200,100,0) stroke(1,0,0) rect(50) move(100,0,0) stroke(1,1,0) rect(50) move(100,0,0) noStroke() rect(50) dot dot() turns on the dot mode. dot(brightness),dot(r,g,b),dot(r,g,b,a) turns on the dot mode and set the dot color. noDot noDot() turns off the dot mode. dot.lua version3() fill(1) move(200,100,0) stroke(1,0,0) rect(50) move(100,0,0) dot(1,1,0) rect(50) move(100,0,0) noDot() rect(50) wireframe wireframe() turns on the wireframe mode. noWireframe noWireframe() turns off the wireframe mode. wireframe.lua version3() n=8 dim3() move(width/2, height/2) for i=1,n do if i>n//2 then wireframe() else noWireframe() end beginGroup() rotateZ(d2r(i*360/n)) move(100,0,0) fill(i/n,1-i/n,1) ball(30,1) endGroup() end blendAlpha blendAlpha() turns on the alpha blending. noBlendAlpha noBlendAlpha turns off the alpha blending. blendAlpha.lua version3() castTex(OUTPUT,INPUT) move(200,100,0) fill(1,0,0,0.2) rect(80) move(100,0,0) noBlendAlpha() fill(1,0,0,0.2) rect(80) back back() If the fill alpha is smaller than 1, back mode shows the backside of an obj. Off by default. noBack noBack() turn off back mode. back.lua version3() dim3() fill(1,0,0,0.2) rotateX(d2r(30)) rotateY(d2r(-15)) move(200,180,0) cube(80) move(150,0,0) back() cube(80) pure pure() use pure color to render. On by default. anime, phong, pure are 3 dependent mode, turn on one may turn off the other two. phong phong(ambient,diffuse,specular,specularPower) turns on the phong render mode, and set the ambient strength to ambient, diffuse strength to diffuse, specular strength to specular, specular damping power to specularPower. phong() only turn on the phong render mode, it doesn't change the configs. By default, there is no light in the scene, call getLight(), ambientLight(), parallelLight(), pointLight to add lights. If you are sure there are lights in your scene but the obj is black, call normal to check if the normal is right. Default settings: ambient:1,diffuse:1,specular:1,specularPower:1. anime, phong, pure are 3 dependent mode, turn on one may turn off the other two. Call dim3() before calling this function. phong.lua version3() dim3() move(width/2,height/2,0) grid() coord() n=10 beginGroup() move(0,0,-100) pointLight() endGroup() for i=1,n do beginGroup() rotateZ(d2r(i*360/n)) move(100,0,0) fill(i/n,1-i/n,1) if(i anime anime(ambient,diffuse,specular,specularPower,diffuseThreshold,specularThreshold) anime() turns on the anime render mode. anime render mode is based on phong, hence the first 4 arguments ambient,diffuse,specular,specularPower are same with phong render mode. diffuseThreshold configs the diffusion threshold, if diffuse lightnees in a pixel is bigger than threshold, it will be white. Otherwise it will be dark. specularThreshold is threshold of specular. The anime render mode smooth the light-dark border when you turn on the smooth settings in plugin panel. Default settings: ambient:1,diffuse:1,specular:1,specularPower:1,diffuseThreshold:0.5,specularThreshold:0.8 anime, phong, pure are 3 dependent mode, turn on one may turn off the other two. Call dim3() before calling this function. anime.lua version3() dim3() move(width/2,height/2,0) grid() coord() n=10 beginGroup() move(0,0,-100) pointLight() endGroup() for i=1,n do beginGroup() rotateZ(d2r(i*360/n)) move(100,0,0) fill(i/n,1-i/n,1) if(i rgba rgba()RGBA output mode, on by default. rgba, depth, normal are 3 dependent mode, turn on one may turn off the other two. You can use phong(),anime() in this output mode. rgba.lua version3() dim3() background(1) move(width/2,height/2,0) n=10 beginGroup() move(0,0,-100) pointLight() endGroup() rgba() -- depth() -- normal() noStroke() for x=1,n do for y=1,n do for z=1,n do beginGroup() fill(x/n,y/n,z/n) move(map(x,1,n,-n/2,n/2)*50,map(y,1,n,-n/2,n/2)*50,map(z,1,n,-n/2,n/2)*200) ball(10,2) endGroup() end end end depth depth(blackDistance, whiteDistance) depth output mode. Set pixels at distance blackDistance to black, pixels at distance whiteDistance to white. If they are the same, PixelsWorld sets the pixels nearer than the value you set to black, otherwise white. rgba, depth, normal are 3 dependent modes, turn on one may turn off the other two. phong(),anime() will be ignored in this output mode. Call dim3() before calling this function. depth.lua version3() dim3() background(1) move(width/2,height/2,0) n=10 beginGroup() move(0,0,-100) pointLight() endGroup() -- rgba() depth() -- normal() noStroke() for x=1,n do for y=1,n do for z=1,n do beginGroup() fill(x/n,y/n,z/n) move(map(x,1,n,-n/2,n/2)*50,map(y,1,n,-n/2,n/2)*50,map(z,1,n,-n/2,n/2)*200) ball(10,2) endGroup() end end end normal normal(faceToCamera, normalize) turns the normal output mode on, and configs faceToCamera and normalize. normal(faceToCamera) turns the normal output mode on, and configs faceToCamera. normal() only turns the normal output mode on. faceToCamera is a boolean, true means the normals are calculated based on camera location. false means the normals are calculated based on the global coordinate. normalize is a boolean. Default settings: faceToCamera:true, normalize:true. rgba, depth, normal are 3 dependent modes, turn on one may turn off the other two. phong(),anime() will be ignored in this output mode. Call dim3() before calling this function. normal.lua version3() dim3() background(.5,.5,1) move(width/2,height/2,0) n=10 beginGroup() move(0,0,-100) pointLight() endGroup() -- rgba() -- depth() normal() noStroke() for x=1,n do for y=1,n do for z=1,n do beginGroup() fill(x/n,y/n,z/n) move(map(x,1,n,-n/2,n/2)*50,map(y,1,n,-n/2,n/2)*50,map(z,1,n,-n/2,n/2)*200) ball(10,2) endGroup() end end end setDepth setDepth(id,blackDistance,whiteDistance) reads the red channel of texture id, maps color basing on blackDistance,whiteDistance to the depth test buffer in the scene. The depth sequence from other 3DCG software can be loaded into PixelsWorld through this function. Namely, the shapes can interact with the color sequence rendered from other 3DCG software. Call dim3() before calling this function. Valid texture id: INPUT,PARAM0~PARAM9 ambientLight ambientLight(r,b,g,intensity) ambientLight() equals to ambientLight(1,1,1,1) ambientLight(brightness) equals to ambientLight(brightness,brightness,brightness,1) ambientLight(brightness,intensity) equals to ambientLight(brightness,brightness,brightness,intensity) ambientLight(r,g,b) equals to ambientLight(r,b,g,1) Adds ambient light to the scene. Valid to all objs. Objs are lit up by this kind of light even if they have wrong normals. al.lua version3() dim3() move(width/2,height/2,0) n=4 phong() ambientLight(1,0.5,0.2,10) noStroke() for r=1,n do local ra = r*50 local cn = math.floor(ra*TPI/40) for i=1,cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn,0.5,0.5)) move(ra,0,0) ball(15,3) endGroup() end end pointLight pointLight(r,g,b,intensity,radius,smoothWidth) pointLight() equals to pointLight(1,1,1,1,1000,1000) pointLight(brightness,intensity) equals to pointLight(brightness,brightness,brightness,intensity,1000,1000) pointLight(r,g,b) equals to pointLight(r,g,b,1,1000,1000) pointLight(r,g,b,intensity) equals to pointLight(r,g,b,intensity,1000,1000) pointLight(r,g,b,intensity,radiusAndSmoothWidth) equals to pointLight(r,g,b,intensity,radiusAndSmoothWidth,radiusAndSmoothWidth) Adds a point light in the current Paintbrush coordinate. This light is affected by objs' normals. The specular and diffuse will be failed if the normals are inward, but the ambient brightness of point light still lights up the objs. radius is range radius of point light. Range from radius to radius+smoothWidth, the brightness damps. pl.lua version3() dim3() move(width/2,height/2,0) n=4 phong() ambientLight(0.2,0.5,1,2) beginGroup() move(0,0,-100) pointLight(1,0.5,0.2,2,500,100) endGroup() noStroke() for r=1,n do local ra = r*50 local cn = math.floor(ra*TPI/40) for i=1,cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn,0.5,0.5)) move(ra,0,0) ball(15,3) endGroup() end end parallelLight parallelLight(r,g,b,intensity,tx,ty,tz) Adds a parallel light with direction vector (tx,ty,tz). pll.lua version3() dim3() move(width/2,height/2,0) n=4 phong() ambientLight(0.2,0.5,1,2) parallelLight(1,0.5,0.2,2,1,-1,1) noStroke() for r=1,n do local ra = r*50 local cn = math.floor(ra*TPI/40) for i=1,cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn,0.5,0.5)) move(ra,0,0) ball(15,3) endGroup() end end light_effects.lua version3() dim3() background(0.1,0.2,0.3) move(width/2,height/2,0) math.randomseed(1) n=5 ambientLight(0.2,0.5,1,1) parallelLight(1,0.5,0.2,0.1,1,-1,1) beginGroup() move(200,0,-100) pointLight(1,0.5,0.2,1,200,100) endGroup() beginGroup() move(-30,200,-100) pointLight(0,1,1,1,200,100) endGroup() beginGroup() move(-30,-200,-100) pointLight(0,1,1,1,200,100) endGroup() noStroke() for r=1,n do local ra = r*50 local cn = math.floor(ra*TPI/40) for i=1,cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn,r/n,0.6)) move(ra,0,0) if math.random() clearLight clearLight() removes all lights in the scene. getLight getLight(matchName) getLight() equals to getLight(\"*\") Gets lights that match the name matchName. matchName rules：If matchName doesn't end up with character \"*\", it searches one Ae lights that its name is matchName, otherwise, it includes all Ae lights that begin with matchName. Supported Ae lights: ambient,point,parallel aeCamera aeCamera() sets the Ae activated camera to the scene camera of PixelsWorld. lookAt lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ,upVecX,upVecY,upVecZ) sets the location and orientation of the current scene camera. lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ) equals to lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ,0,-1,0) eyePos is the location of your eyes, objPos is the location of the object you are looking at,upVec the direction the top of your head pointing to. Note: The Y-axis in Ae is downward by default, usually set the upVec to (0,-1,0) is enough. eyePos and objPos cannot be too close. (should be bigger than 1e-7). upVec cannot be parallel to your sight. The length of upVec cannot be too small. viewSpace viewSpace(width,height,distanceToPlane,farLevel) viewSpace(width,height,distanceToPlane) equals to viewSpace(width,height,distanceToPlane,4) width and height is the dimension of the far plane. The perpendicular distance from the camera to the camera's far plane is distanceToPlane farLevel * distanceToPlane is the clip plane distance. Objs that farther than this distance will be clipped out. Normally it is enough to leave the farLevel 4, set it to a higher number if your scene is pretty vast. Note that if the farLevel is too high, the depth test precision of near objs may decline. strokeWidth strokeWidth(width) Default: 2 strokeDivision strokeDivision(level) Default: 3 strokeGlobal strokeGlobal() draw lines globally. Lines will no longer be squeezed by scale function. Default: local strokeLocal strokeLocal() draw lines locally. Lines will be squeezed by scale function. Default: local dotRadius dotRadius(radius) Default: 2 dotRadius.lua version3() background(1) fill(0,1,1) dot(1,0,0) move(100,100) for i=1,7 do dotRadius(i/2) rect(40) move(50,0) end dotDivision dotDivision(level) Default: 3 Maximum: 7 dotDivision.lua version3() background(1) fill(0,1,1) dot(1,0,0) dotRadius(10) move(100,100) for i=0,4 do dotDivision(i) rect(40) move(70,0) end dotGlobal dotGlobal() Draw points globally. Points will no longer be squeezed by scale function. Default: local dotGlobal.lua version3() dot(1,0,0) dotGlobal() move(50,100) beginGroup() for i=1,13 do beginGroup() scale(1/i) rect(50) endGroup() move(50/i+20,0) end endGroup() dotLocal dotLocal() Draw points locally. Points will be squeezed by scale function. Default: local dotLocal.lua version3() dot(1,0,0) dotLocal() move(50,100) beginGroup() for i=1,13 do beginGroup() scale(1/i) rect(50) endGroup() move(50/i+20,0) end endGroup() smooth smooth() Smooth render mode. Default: on The smooth strength can be changed in the plugin panel. noSmooth noSmooth() Pixel art render mode. The priority of this function is higher than the settings in the plugin panel. r2d r2d(degrees) radians to degrees, return degrees. d2r d2r(radians) degrees to radians, return radians map map(value,in1,in2,out1,out2) maps value value from range in1~in2 to range out1~out2. If in1 equals to in2, if value this function returns out1, otherwise out2. clamp clamp(value,lower,upper)clamps value into range [lower,upper], returns clamped value. New in v3.2.0 Namely, if value is between lower and upper, this function returns value; If value is less than lower, it returns lower; If value is greater than upper, it returns upper. step step(value,threshold) returns 0 if value, otherwise, returns 1. New in v3.2.0 smoothStep smoothStep(value,lower,upper) returns 0 if value, returns 1 if value>higher1, otherwise, returns the smooth interpolation between lower and higher basing on value. Formula of interpolation: t:=x−lowerupper−lower\r t := \\frac{x - lower}{upper - lower}\r t:=​upper−lower​​x−lower​​ Result:=t2(3−2t)\r Result:=t^2(3 - 2t)\r Result:=t​2​​(3−2t) New in v3.2.0 bezier bezier(t,p0,p1,...,pn) returns the n times bezier interpolation basing on p0,p1,...,pn. The formula of interpolation: Result:=∑k=0nCnk⋅(1−t)n−k⋅tk⋅pk\r Result := \\sum_{k=0}^n{C_n^k\\cdot (1-t)^{n-k}\\cdot t^k\\cdot p_k}\r Result:=∑​k=0​n​​C​n​k​​⋅(1−t)​n−k​​⋅t​k​​⋅p​k​​ Cnk:=n!(n−k)!k!\r C_n^k:=\\frac{n!}{(n-k)!k!}\r C​n​k​​:=​(n−k)!k!​​n!​​ New in v3.2.0 The maximum of n is 66. Color conversion xxx2xxx allows the following color conversion: For example, if you want to convert a hsl color to rgb format, then you need to call the function hsl2rgb, both the number of input and output parameters are 3. All conversions are done in the range 0~1. New in v3.2.0 color_convert.lua version3() dim3() strokeWidth(0.5) stroke(0) move(width/2,height/2,0) for x = -5,5 do for y =-5,5 do for z=-5,5 do beginGroup() move(x*15,y*15,z*15) fill(cmy2rgb(x/10+.5,y/10+.5,z/10+.5)) cube(12) endGroup() end end end utf8ToLocal utf8ToLocal(str) unicode string to local string. Call this function to translate paths while you are handling Lua's io module. localToUtf8 localToUtf8(str)local string to unicode string getGLInfo getGLInfo() gets the information of the current graphics card. getDrawRecord getDrawRecord(needStringFormat) gets current draw records. needStringFormat is a boolean, when true, returns a string, otherwise, returns a Lua table. getDrawRecord() equals to getDrawRecord(true) printDrawRecord.lua version3() move(width/2,height/2) dim3() cube() println(getDrawRecord()); getStatus getStatus(needStringFormat)gets the current Paintbrush status. needStringFormat is a boolean, when true, returns a string, otherwise, returns a Lua table. getStatus() equals to getStatus(true) getAudio Make sure you have PixelsWorld v3.4.0+ getAudio([startTime,duration[,id[,sampleRate,startFrequency,endFrequency[,resolution]]]]) fetches the audio data. Returns 6 tables. The first 2 are wave sample tables(Left and Right), the next 2 are fft result tables(Left and Right), the last 2 are spectrum tables(Left and Right). Left wave sample range: (-1~1) Right wave sample range: (-1~1) Left FFT range: (0~infinity) Right FFT range: (0~infinity) Left spectrum sample range: (0~infinity) Right spectrum sample range: (0~infinity) waveInfo.lua version3() castTex(OUTPUT,INPUT) local wl,wr,ftl,ftr,specl,specr = getAudio() local nm = math.floor(height/8); for i=1,nm do local wid =math.max(math.floor(i/nm*#wl),1) local fid = math.max(math.floor(i/nm*#specl),1) print(string.format(\"%8.5f\",wl[wid]),wl[wid]*4,0,-wl[wid]*4) print(\" \",1,0,0,0) print(string.format(\"%8.5f\",wr[wid]),wr[wid]*4,0,-wr[wid]*4) print(\" \",0.5,0.5,0.5) print(string.format(\"%8.5f\",specl[fid]),specl[fid],0,0) print(\" \",1,0,0,0) print(string.format(\"%8.5f\",specr[fid]),0,0,specr[fid]) println(\"\"); end saveString saveString(utf8_path,string) saves string to local path. loadString loadString(utf8_path) reads local txt file then returns string. getColor getColor(id,x,y) get pixel color at location (x,y) of texture id. Returns r,g,b,a 4 doubles. getColor(x,y) equals to getColor(INPUT,x,y) It is highly efficient to call getColor before any draw function(Such as immediately after version3()). Otherwise, it is very low efficient since it queries pixels from the graphic card. Valid id: INPUT,OUTPUT,PARAM0~PARAM9 setColor setColor(x,y,r,g,b,a) set the pixel at location (x,y) of texture OUTPUT. It is highly efficient to call setColor before any draw function getSize getSize(id) returns the size of texture id. (Two doubles, width, and height) Due to the Ae's downsample (1/2,1/4) mechanism, the size you get would variating 0~4px. But this kind of variating doesn't change with time. The size is promised to be accurate in full resolution(without downsample). shadertoy shadertoy(code) runs code from shadertoy.com. Not all code on shadertoy.com is supported. glsl glsl(code) runs fragment stage shader code. cmd cmd(code) runs cmd code. This function is equivalent to the ISO C function system. It passes a command to be executed by an operating system shell. Its first result is true if the command terminated successfully, or nil otherwise. After this first result the function returns a string plus a number, as follows: \"exit\": the command terminated normally; the following number is the exit status of the command. \"signal\": the command was terminated by a signal; the following number is the signal that terminated the command. lua lua(code) runs lua code. runFile runFile(utf8_path) loads local lua code and run. No need to call utf8ToLocal since it supports utf8. txt txt(utf8_path) loads local text file. Returns string. No need to call utf8ToLocal since it supports utf8. "},"contents/Lua/Texture.html":{"url":"contents/Lua/Texture.html","title":"Texture system","keywords":"","body":"Texture system Make sure your PixelsWorld version is v3.3.0+ This section gives a detailed introduction of Texture system in PixelsWorld. newTex delTex getSize swapTex drawTo castTex blendTex copyTex fetchTex savePNG,loadPNG,saveEXR,loadEXR,saveRAW,loadRAW rotateTex,flipTex,resizeTex,trimTex Texture id In PixelsWorld, every texture is represented as an integer. It is called texId. The basic texIds provided by PixelsWorld are as followed. texId Globals in Lua Globals in GLSL Globals Shadertoy Description -3 OUTPUT Inaccessible Inaccessible Output texture -2 TEMP PW_TEMP_LAYER _PixelsWorld_PW_TEMP_LAYER Cache texture -1 INPUT AE_INPUT_LAYER _PixelsWorld_AE_INPUT_LAYER Input texture 0 PARAM0 0 0 Layer parameter 0 texture 1 PARAM1 1 1 Layer parameter 1 texture ... PARAM... ... ... ... 9 PARAM9 9 9 Layer parameter 9 texture You can also create your texId. The method will be covered below. How they work Normally, Ae sends a picture to PixelsWorld to process. PixelsWorld loads it to the INPUT texId, writes the result to OUTPUT texId. Finally blits all pixels to Ae. What is TEMP texId Because OpenGL doesn't support read and write to the same texture at the same time. PixelsWorld provides TEMP texId to hold the last shading results (Means the TEMP texId only makes sense in Lua mode and you called glsl function twice or more). You can use getColor(PW_TEMP_LAYER,uv); in glsl code to sample colors in TEMP texId. Create texture Use newTex(width,height) to create a texture. Returns a texId. (a random integer) Delete texture Use delTex(id) to delete a texture. In most cases, you don't have to delete texture by yourself. PixelsWorld will release all texture memory at the end of each frame. Size of texture Use getSize(id) to get the size of a texture. getSize.lua version3() mytex = newTex(512,256) w,h = getSize(mytex) println(\"Width of mytex is: \" .. w) println(\"Height of mytex is: \" .. h) Swap textures Use swapTex(id1,id2) to swap the pixels data of id1 and id2. swapTex.lua version3() tex1 = newTex(128,128) tex2 = newTex(256,256) w,h = getSize(tex1) println(\"tex1 size: \" .. w .. \", \".. h) swapTex(tex1,tex2) w,h = getSize(tex1) println(\"tex1 size after swapped: \" .. w .. \", \".. h) Set drawTo Use drawTo(id) to set the texture the objs would be drawn. The default drawTo texId is OUTPUT. Note that PixelsWorld only blits pixels in OUTPUT to Ae, no matter what the drawTo texId is. Here are 3 approaches you can send pixels in other texId to OUTPUT: drawTo(OUTPUT)+image castTex swapTex Cast texture Use castTex(toTexId,fromTexId) to cast pixels data from fromTexId to toTexId. E.g. You can cast pixels in PARAM0 to OUTPUT. castTex.lua version3() castTex(OUTPUT,PARAM0) You can also specify the cast range. (The origin is left top corner) castTex(toTexId,fromTexId,to1x,to1y,to2x,to2y) castTex(toTexId,fromTexId,to1x,to1y,to2x,to2y,from1x,from1y,from2x,from2y) Cast all pixels by default. Blend textures Use blendTex(toTexId,fromTexId,blendRule) to blend fromTex to toTex by rule blendRule blendRule can be one of NORMAL,ADD,SUBTRACT,MULTIPLY,DIVIDE,MAX,MIN. blendRule can be blend rule(string). A menas input pixels of toTexId B means input pixels of fromTexId C means output pixels of toTexId E.g. you can specify your rule to blend PARAM0 and INPUT. blendRule.lua version3() castTex(OUTPUT,INPUT) -- Cast INPUT texture to OUTPUT firstly. blendTex(OUTPUT,PARAM0,\"C=A+B\") -- Blend PARAM0 to OUTPUT. Indeed, the \"C=A+B\" will be processed to the following code inside PixelsWorld. blendRuleGLSL.frag #version 330 core out vec4 outColor; in vec2 uv; in vec2 uv2; uniform sampler2D inLayerA; uniform sampler2D inLayerB; void main(){ vec4 A = texture(inLayerA,uv); vec4 B = texture(inLayerB,uv2); vec4 C = A; C=A+B // Your blend rule is combined here. ; } Same with castTex, blendTex also supports range specifying: blendTex(toTexId,fromTexId,blendRule,to1x,to1y,to2x,to2y) blendTex(toTexId,fromTexId,blendRule,to1x,to1y,to2x,to2y,from1x,from1y,from2x,from2y) Copy texture Use copyTex(refTexId) to copy texture. Returns new texId. Fetch texture at any time Use fetchTex(layerId, time) to obtain the specified layer pixels at the specified time. It returns a random texture ID. layerId: Only PARAM0~PARAM9 are accepted. time: The double layer time in seconds. Note: Use of this function would cause wrong caching. Please purge the chache while you are using this function. New in v3.4.3+. Texture IO Use savePNG(utf8Path,texId),loadPNG(utf8Path) to save or load PNG image. Use saveEXR(utf8Path,texId),loadEXR(utf8Path) to save or load EXR image. Use saveRAW(utf8Path,texId),loadRAW(utf8Path) to save or load MiLai original raw memory image. Supported image specifications are listed below. Format Library Supported compression algorithms Color format PNG cute_headers DEFLATE compliant decompressor zlib(RFC 1950) RGBA,clamped 8bit unsigned integer per channel. EXR tinyexr NONE,RLE,ZIP,ZIPS,PIZ,ZFP RGBA,HDR 32bit floating point per channel. RAW (None) MiLai original format. (See figure below) RGBA, HDR 32bit floating-point per channel. Load PNG image to scene: loadPNG.lua version3() local mypng = loadPNG([[d:\\test.png]]) -- Replace to your path. castTex(OUTPUT,mypng) -- Cast pixels from mypng to OUTPUT. Save OUTPUT texId to local: savePNG.lua version3() --Draw something to OUTPUT move(width/2,height/2) rotate(time) triangle() --End drawing. savePNG([[d:\\test.png]],OUTPUT) -- Save OUTPUT as PNG to local disc. Replace to your path here. Change PNG to EXR to read/write EXR file. Some local paths might need running Ae under the Administrator mode. Edit texture Use rotateTex(texId,times) to rotate texture 90*timesdegrees, rotateTex(texId) equals to rotateTex(texId,1) Use flipTex(texId,flipV) to mirror flip a image. flipV is a boolean. When flipV is true, flip the image vertically, and horizontally otherwise. Use resizeTex(texId,width,height) to resize texture. Use trimTex(texId,p1x,p1y,p2x,p2y) to trim texture. The origin of p1x,p1y,p2x,p2y is left top corner. "},"contents/Lua/Filter.html":{"url":"contents/Lua/Filter.html","title":"Filter system","keywords":"","body":"Filter system Before reading, please make sure you update PixelsWorld to v3.6.0+ Filter system is a kind of encapsulation of quad shader, it allows you to build post-processing shader fast. By reading this section, you will learn how to use Filter system in PixelsWorld. newFilter runFilter delFilter setFilterUniform setFilterDrawto newFilterModule Advanced application Create a filter Call newFilter(glslCode) to create a filter program. Return: a random integer that represents the filter. (filterID) glslCode will be inserted into the following context: glslcode_context.glsl #version 330 core in vec2 uv; out vec4 outColor; // Your glslCode here! Example Note: In lua, we use [[...]] to quote a multiple-line-string. newFilter.lua version3() filterID = newFilter([[ void main(){ outColor = vec4(uv,0,1); } ]]) Run a filter Call runFilter(filterID) to run a filter program. Example runFilter.lua version3() filterID = newFilter([[ void main(){ outColor = vec4(uv,0,1); } ]]) runFilter(filterID) Delete a filter Call delFilter(filterID) to delete a filter. Normally, you don't have to delete filters. PixelsWorld deletes all filters at the end of every frame automatically. However, it's still a nice habit to delete filters by hand when it's not in used. Example delFilter.lua version3() filterID = newFilter([[ void main(){ outColor = vec4(uv,0,1); } ]]) delFilter(filterID) Set uniforms of filter Call setFilterUniform(filterID, uniformType, uniformName, data0, data1, data2, ...) to set the value of uniform data. filterID: Id of the filter. uniformType: A string that represents the data type. It can be 1d-data (\"int\",\"float\",\"bool\"), vectors (\"vec2\",\"vec3\",\"vec4\",\"ivec2\"...), matrices (\"mat2, mat4x3, ...\"), or texture (\"sampler2D\") uniformName: Name of the data you want to set. data0,data1,...: Float data. (See example) Example setFilterUniform.lua version3() filterID = newFilter([[ uniform float myfloat; uniform vec2 myvec; uniform mat3x2 mymat; uniform sampler2D mytex1; void main(){ outColor = vec4(myfloat,myvec[0],mymat[0][1],1) + texture(mytex1,uv); } ]]) setFilterUniform(filterID, \"float\", \"myfloat\", math.sin(time)*0.5 + 0.5) setFilterUniform(filterID, \"vec2\", \"myvec\", 1,2) -- Column major, namely mymat[0][0]==1, mymat[0][1]==slider(0), mymat[0][2]==2, mymat[1][0]==3, ... setFilterUniform(filterID, \"mat3x2\", \"mymat\", 1, slider(0), 2, 3, 4, 5) -- Use INPUT texture as mytex1 setFilterUniform(filterID, \"sampler2D\", \"mytex1\", INPUT) -- ** You can also set the texture you created as mytex1 ** -- myInputTexID = newTex(512,256) -- setFilterUniform(filterID, \"sampler2D\", \"mytex1\", myInputTexID) runFilter(filterID) Set output texture Call setFilterDrawto(filterID, texID) to specify the output texture the result will be written. About texID, see also: Texture system The default Drawto is OUTPUT You can even apply a filter iteratively to a texture. See also: Advanced application Create a filter module Call newFilterModule(glslCode) to create a filter module. Return: A table contains filterID and some utility functions. The main usage of the filter module is to simplify your code. Normally, if you don't use the filter module, you should create and apply a filter in this way: no_module.lua version3() filterID = newFilter([[ uniform float myfloat; void main(){ outColor = vec4(myfloat,0,0,1); } ]]) setFilterUniform(filterID, \"float\", \"myfloat\", math.sin(time)*0.5 + 0.5) setFilterDrawto(filterID, OUTPUT) runFilter(filterID) delFilter(filterID) Things will be easier if you use the filter module. no_module.lua version3() filter = newFilterModule([[ uniform float myfloat; void main(){ outColor = vec4(myfloat,0,0,1); } ]]) filter.set(\"float\", \"myfloat\", math.sin(time)*0.5 + 0.5) filter.drawto(OUTPUT) filter.run() filter.del() Advanced application Here is a example of the famous channel blur effect. slider 0: Blur intensity. layer 0: Blur mask layer. iterateFilter.lua version3() -- Create a temp texture tempTexID = newTex(width,height) -- Copy input to temp texture castTex(tempTexID, INPUT) -- Blur code blurGLSLCode = [[ uniform sampler2D in_tex; uniform mat3 kernel; uniform vec2 resolution; void main() { vec2 xy = resolution * uv; vec4 res = vec4(0,0,0,0); for(int x = 0; x "},"contents/Lua/Simulation.html":{"url":"contents/Lua/Simulation.html","title":"Physics simulation","keywords":"","body":"Physics simulation The following gif is a result of Chimera's Breath -by nimitz running in PixelsWorld. See full-resolution video You will learn how to cache data to a local disc in this section. Note: This manual should be strictly followed for caching data in a right way Make sure you have updated PixelsWorld to v3.3.3+ This section is written in a style that assumed the readers are familiar with Ae and PixelsWorld. Cache data Cache textures Cache data example: The three body problem Cache textures example: Conway's Game of Life Cache textures example: Fluid simulation Cache data To cache data, the following steps should be followed: Code logic: Set cache path and cache name Caculate frameId=time*fps Caculate lastFrameId=frameId-1 If lastFrameId Initialize data, go to 7 Read the data file saved by the last frame, throw an error if the file not exists, go to 7 otherwise. Calculate data Save current data file to local. Operating logic: Put code that satisfies the above logic to PixelsWorld. Put the Time indicator to the first frame of the current layer. Purge Ae cache(Edit->Purge->All Memory & Disk Cache... see the screenshot below) Hold Ctrl+Alt and click the LOGO image in the plugin panel. (This step is optional) Press the Space key to render(DON'T skip frames while rendering) Note: If something goes wrong (errors, flickers, etc.), redo steps 2~5. Cache textures Code logic: If downsampled(1/2, 1/4 render mode), throw an error. Set cache path and cache name Caculate frameId=time*fps Caculate lastFrameId=frameId-1 If lastFrameId Initialize texture, go to 7 Read texture file saved by the last frame, throw an error if file not exists, go to 7 otherwise. Render texture file Save the current texture file to local. See Texture section to learn how to work with texture. Operating logic: Put code that satisfies the above logic to PixelsWorld. Change PixelsWorld settings Advanced->Internal texture format to Floating point 32bit x RGBA (HDR) Put the Time indicator to the first frame of the current layer. Purge Ae cache(Edit->Purge->All Memory & Disk Cache... see the screenshot above) Hold Ctrl+Alt and click the LOGO image in the plugin panel. (This step is optional) Press Space key to render(DON'T skip frames while rendering) Cache data example: The three-body problem the_three_body_problem.lua version3() -- Include vector library require(\"veclib\") -- Set cache file name local cacheFileName = \"A\" -- Add checking if file exists function(Refer: https://stackoverflow.com/questions/4990990/check-if-a-file-exists-with-lua) function file_exists(name) local f=io.open(name,\"r\") if f~=nil then io.close(f) return true else return false end end -- Calculate current frame index then round it to integer. local frameId = math.floor(time * fps + .5) -- Calculate last frame index local lastFrameId = frameId -1 -- Frame id should not be negative. assert(frameId >= 0, \"FrameId not support\") -- Print it out. (This line can be removed) println(\"Frame ID: \" .. frameId) -- Set cache folder. (Here I used the aep project folder, don't forget to save your project before use projectFolder) local cachePath = projectFolder .. \"cache\\\\\" -- Print it out. (This line can be removed) println(\"Cache path: \" .. cachePath) -- If frameId == 0 (Namely lastFrameId Cache textures example: Conway's Game of Life game_of_life.lua version3() -- Check downsample settings. assert(width == ds_width and height == ds_height , \"Downsample not support\" ) -- Add checking if file exists function(Refer: https://stackoverflow.com/questions/4990990/check-if-a-file-exists-with-lua) function file_exists(name) local f=io.open(name,\"r\") if f~=nil then io.close(f) return true else return false end end -- Calculate current frame index then round it to integer. local frameId = math.floor(time * fps + .5) -- Calculate last frame index local lastFrameId = frameId -1 -- Frame id should not be negative. assert(frameId >= 0, \"FrameId not support\") -- Print it out. (This line can be removed) println(\"Frame ID: \" .. frameId) -- Set cache folder. local cachePath = projectFolder .. \"cache\\\\\" -- Print it out. (This line can be removed) println(\"Cache path: \" .. cachePath) -- Check if it is frame 0 if(lastFrameId = res.x || iuv.x =res.y || iuv.y.5; } // From https://thebookofshaders.com/10/ float random (vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123); } void main(){ if(time == 0.) { outColor = vec4(random(uv)>.5); }else{ bool curstatus = fetchStatus(0,0); int roundCount = 0; for(int i = 0;i 3) outColor = vec4(0); else outColor = vec4(curstatus); } else { if(roundCount == 3) outColor = vec4(1); else outColor = vec4(0); } } } ]==] -- Put the last frame texture to PARAM0, so that you can read the last frame texture via layer[0] swapTex(PARAM0,lastTexA) -- Render texture glsl(fragCode) -- Put the last frame texture back to its original position. swapTex(PARAM0,lastTexA) -- Save texture to local saveRAW(cachePath .. \"A_\" .. tostring(frameId) .. \".raw\",OUTPUT) Cache textures example: Fluid simulation Note: According to the code license declared by original author, the following code should only be used for study purpose. Don't forget to set the Internal texture format to Floating point 32 bit x RGBA (HDR) in plugin panel. Please make sure you have read the simulation manual before doing it. Go to manual>>> Setting Mipmap filter to NONE could speed up render. fluid_simulation.lua version3() assert(width == ds_width and height == ds_height , \"Downsample not support\" ) function file_exists(name) local f=io.open(name,\"r\") if f~=nil then io.close(f) return true else return false end end local frameId = math.floor(time * fps + .5) local lastFrameId = frameId -1 assert(frameId >= 0, \"FrameId not support\") println(\"Frame ID: \" .. frameId) local cachepath = projectFolder .. \"cache\\\\\" println(\"Cache path: \" .. cachepath) if(lastFrameId "},"contents/Lua/Poly.html":{"url":"contents/Lua/Poly.html","title":"Poly function","keywords":"","body":"Creation origin: Poly function poly(obj) analyzes the inputted obj, then draws it to the scene. Usage If you are familiar with Houdini, constructing an obj is basically to fill a SpreadSheet. Here is an example of constructing an obj of an unusual colorful triangle. PolyTest1.lua version3() background(0.95) move(width/2,height/2) dim3() dotRadius(5) obj={ point={ {p={0,0,0},color={0,1,1}}, {p={100,0,0},color={1,1,0}}, {p={0,100,0},color={1,0,1}}, {p={100,100,0},color={1,0,0}}, }, prim={ {type=\"triangle\",pref={1,2,3}}, {type=\"line\",pref={2,3,3,4,4,2}}, {type=\"point\",pref={2,4}}, } } poly(obj) Supporting primitives Assumepref={1,2,3,4,5,6}. pref means point reference. The semicolon (;) is the end mark of one primitive drawing. type name Corresponding primitive Drawing order full type name points Points 1;2;3;4;5;6; points pointd 2d point 1;2;3;4;5;6; point disc pointb 3d point 1;2;3;4;5;6; point ball line Single line 123456; single line linef Single 2d line 123456; line flat linec Single 3d line 123456; line capsule linel Loop line 1234561; line loop linelf Loop 2d line 1234561; line loop flat linelc Loop 3d line 1234561; line loop capsule lines Lines 12;34;56; lines linesf 2d lines 12;34;56; lines flat linesc 3d lines 12;34;56; lines capsule triangles Triangle meshes 123;456; triangles triangleb Bridge structure triangle meshes 123;324;345;546; triangle bridge triangler Radial structure triangle meshes 123;134;145;156; triangle radial The structure of obj The obj structure is defined by the following steps: obj is a table. obj contains 4 keys: point,vertex,prim,detail. The 4 keys in obj have their value called pointArray, vertexArray, primArray, detailList. pointArray is required. vertexArray is optional. primArray is required. detailList is optional. The above-mentioned value names that are Array suffixed holds N sub-tables, where N can be defined by users. The kth sub-table of pointArray is called point[k] or \"The kth point\". The kth sub-table of vertexArray is called vertex[k] or \"The kth child-point\". The kth sub-table of primArray is called prim[k] or \"The kth primitive\". The detailList and Points, child-points, primitives, have some non-subdividable units：the Key-value pairs. We call these keys K, and values V. K should only contain alphabets, numbers, and underlines. And K shouldn't be all numbers. V has 7 types: 1D, 2D, 3D, 4D, string, texture id and index serial. For all double floating numbers x,y,z,w x or {x} is 1D V. {x,y} is 2D V. {x,y,z} is 3D V. {x,y,z,w} is 4D V. \"Hello! PixelsWorld!\" is string V. When (K ends up with \"_tex\") and (V is an integer and the corresponding texture exists), it is texture id V. For integer serial a1,...,an,{a1,a2,a3,...,an} is index serial V. For all point[k], there must be a K named \"p\" to represents the location, or it is an invalid point. For all vertex[k], there must be a K named \"pref\" and its V is an integer to represent the reference point id, or it is an invalid child-point. For all prim[k], there must be a K named \"type\" and its V is string to represents the type of the primitive. And there also must be a K named \"vref\"or \"pref\" and its V is index serial to represent the order of points drawing. Override priority For same K, the following override priority is defined: Same with Houdini. vertex point prim detail Example: The following obj's prim contains a color attribute (Red), So we will get a red triangle. PrimColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0}}, {p={100,0,0}}, {p={0,100,0}}, }, prim={ {type=\"triangle\",pref={1,2,3},color={1,0,0}}, }, } poly(obj) This time, both prim and point contain color, and because the priority of point is higher, so the color attribute in point will be used, then we will get a colorful triangle. PointColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},color={0,1,1}}, {p={100,0,0},color={1,1,0}}, {p={0,100,0},color={1,0,1}}, }, prim={ {type=\"triangle\",pref={1,2,3},color={1,0,0}}, }, } poly(obj) Usage of vertex Vertex (child-point) inherits all attributes from point. VertexColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0}}, {p={100,0,0}}, {p={0,100,0}}, {p={100,100,0}}, }, vertex={ {pref=1,color={1,0,0}}, {pref=2,color={1,0,0}}, {pref=3,color={1,0,0}}, {pref=2,color={0,1,0}}, {pref=3,color={0,1,0}}, {pref=4,color={0,1,0}}, }, prim={ {type=\"triangle\",vref={1,2,3,4,5,6}}, }, } poly(obj) pref is used to define which point to be referenced, the full name of pref is Point reference. So the vref means Vertex reference. Note: The index in Lua starts from 1, not 0. Without vertex, the triangle looks like this: NoVertex.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},color={1,0,0}}, {p={100,0,0},color={1,0,0}}, {p={0,100,0},color={1,0,0}}, {p={100,100,0},color={0,1,0}}, }, prim={ {type=\"triangle\",pref={1,2,3,2,3,4}}, }, } poly(obj) Extra shader Yes! You can even write a shader to an obj. FragColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},myattribute={1,0}}, {p={100,0,0},myattribute={0,1}}, {p={0,100,0},myattribute={0,0}}, {p={100,100,0},myattribute={1,1}}, }, prim={ { type=\"triangle\", pref={1,2,3,2,3,4}, frag=[==[ #define t ]==] .. tostring(time) .. [==[ void main(){ outColor = vec4(mod(myattribute*10+vec2(t),1),0,1); } ]==], }, }, } poly(obj) Use texture Here is an example of how to use texture. The integer that its key name ends up with _tex is treated as a texture id. Using an extra shader in a prim can handle more than one texture. More information about texture... UVTex.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},uv={0,0}}, {p={100,0,0},uv={1,0}}, {p={0,100,0},uv={0,1}}, {p={100,100,0},uv={1,1}}, }, prim={ { type=\"triangler\", pref={1,2,4,3}, my_tex=INPUT, }, }, } poly(obj) "},"contents/Lua/TransparencyRender.html":{"url":"contents/Lua/TransparencyRender.html","title":"Transparency render","keywords":"","body":"Render transparent objects Normally, we get the following result when we are about to render a stack of transparent cubes. normalCubes.lua version3() in2out() dim3() fill(1,.5) move(width/2, height/2) for i = 1,10 do move(20,0,200) cube() end The result was wrong because we cannot see the behind cubes. We should adjust the render order (farthest to nearest) basing on the camera distance to obtain the right blending color. sortCubes.lua version3() in2out() dim3() fill(1,.5) sortarr = {} beginGroup() move(width/2, height/2) for i = 1,10 do move(20,0,200) local x,y,z = global2screen(local2global(0,0,0)) -- Get camera distance sortarr[i] = {z,getTransformMatrix()} -- {distance, transform status} pairs end endGroup() table.sort( sortarr, function(a,b) return a[1] > b[1] end -- Sort by z distance ) for i = 1,10 do beginGroup(sortarr[i][2]) -- Apply transform status cube() endGroup() end "},"contents/Lua/RunGLSL.html":{"url":"contents/Lua/RunGLSL.html","title":"Run GLSL in Lua","keywords":"","body":"Run GLSL in Lua Usage glsl.lua version3() glsl(Your_code_string_here) Note: We recommend using [==[Your_code_string_here]==] to quote your string on account of avoiding escape characters. Namely, your code should be like: glsl2.lua version3() glsl([==[ void main(){ outColor = vec4(uv,sin(time*10)/2+.5,1); } ]==]) The following function can run the code from shadertoy.com. shadertoy.lua version3() shadertoy(Your_shadertoy_code_here) "},"contents/GLSL/GLSLCode.html":{"url":"contents/GLSL/GLSLCode.html","title":"GPU Berserker GLSL","keywords":"","body":"GPU Berserker GLSL In this section, we will have a quick look at how the GLSL works in PixelsWorld. What is GLSL? GLSL is an abbreviation of OpenGL Shader Language, which is supported by OpenGL, run on GPU. How to learn it? We recommend The book of shaders Advantage of GPU render If we treat the CPU as a supercar, the GPU should be more like a bus. In the case we transport a few people, one or three, a supercar is adequate. (Handle single complicated calculation) When it comes to thousands of people, a bus could be helpful. (Render thousands of data simultaneously) Languages like C/C++, Java, Python, etc., are almost designed to run on CPU. Languages like GLSL are designed for GPU. When we want to render a picture. GPU distributes your code to many \"workers\" to repetitively calculate the result for each pixel. If you want to learn more about GLSL, we recommend you to go to shadertoy.com, find some interesting arts, and make out why this works. Details Before the GLSL is sent to OpenGL, PixelsWorld will combine pre-defined and post-defined codes to support features of Ae. If you are a beginner, you can ignore this section for the moment. PixelsWorld V3.0.0 use #version 330 core. Here are pre-defined and post-defined codes. "},"contents/GLSL/RunGLSL.html":{"url":"contents/GLSL/RunGLSL.html","title":"Run GLSL","keywords":"","body":"Run GLSL Code Make sure you are in GLSL(GPU) mode; Then edit the World rule; You will see there is already some code in the showed up panel; default.shader void main(){ outColor = getColor(uv); } This code means that send the input pixels to the output. You can change the getColor(uv) to vec4(uv,0.0,1.0) for geting a beautiful uv color pattern; uvcolor.shader void main(){ outColor = vec4(uv,0.0,1.0); } Then, press the \"Ok\" button. If everything is right, you will get something in the scene like this: "},"contents/GLSL/GetStart.html":{"url":"contents/GLSL/GetStart.html","title":"Quick start","keywords":"","body":"Shader code? Shader is like The Function of Microsoft Excel. You write a function, it will handle the form-data for you. If we treat the data in the form as input pixels, the calculated form as output pixels, Codes in PixelsWorld is the function in Microsoft Excel E.g. Make picture brighter To make a picture brighter, the simplest approach is just to add the R, G, B by a number. If in Excel, we need to do something like this: Then we have made all pixels data \"brighter\"! Here is what we need to write in PixelsWorld: bright_describe.shader outColor=getColor(uv)+vec4(0.2); It means: Get the input pixels (getColor) in current location (uv), and add the 4D vector RGBA by (0.2,0.2,0.2,0.2) (+vec4(0.2)). Finally, send (=) the result to the output pixel(outColor). But if we only write this single line, PixelsWorld cannot work fine. We need to add this line inside a \"shell\" to make it work. The complete version is this: bright.shader void main(){ outColor=getColor(uv)+vec4(0.2); } How to input codes Input picture (Right-click to save) (Source artist) Result Add more controls! Mostly we don't just add 0.2 to the picture. We want it to be more controllable. So we can replace the 0.2 with slider[0]. In this way, we can change the value in the Parameters panel to change the brightness of your picture. bright_control.shader void main(){ outColor=getColor(uv)+vec4(slider[0]); } But you can find that, if the value is negative, the picture will be transparent, we don't want this to happen. Namely, we need to avoid modifying the Alpha channel of the picture. bright_control.shader void main(){ vec4 inColor = getColor(uv); inColor.rgb = inColor.rgb + vec3(slider[0]); outColor = inColor; } It means: Save the input pixel into a temporary variable inColor, Add the value of slider[0] to the RGB of inColor, then send the inColor to the outColor. Add label to the parameter Save to preset Finally, we can save the code as a preset for the next use. Go to the Preset management to learn more details. Congratulations! You have already mastered most of PixelsWorld! In addition to writing codes by yourself, you can go to the shadertoy, find some interesting code, and run it in PixelsWorld. See this to learn how to use code from shadertoy. "},"contents/GLSL/Functions.html":{"url":"contents/GLSL/Functions.html","title":"Functions","keywords":"","body":"Functions This section will give a brief introduction to the functions created by us. The functions mentioned in this section could be immediately used without any declaration. "},"contents/GLSL/getColor.html":{"url":"contents/GLSL/getColor.html","title":"getColor","keywords":"","body":"getColor This function has two versions: getColor(vec2) and getColor(int ,vec2). getColor(vec2) Description : Get the color of inLayer in specified position. Parameters : vec2 : uv position. Return : vec4 : a RGBA color. getColor(int,vec2) Description : Get the color of specified layer in specified position. Parameters : int: layer id, -1 (or AE_INPUT_LAYER) means inLayer, a number between 0 and 9 means the corresponding Layer Parameter in your plugin panel. (PW_TEMP_LAYER (which is -2) is provided in Lua render mode) vec2 : uv coordinates. Return : vec4 : a RGBA color. NOTE : So in other words, getColor(AE_INPUT_LAYER,uv); totally equals to getColor(uv); getColor(n,uv); can return the pixels of layer[n]. "},"contents/GLSL/uvxy.html":{"url":"contents/GLSL/uvxy.html","title":"uv2xy,xy2uv","keywords":"","body":"uv2xy,xy2uv These two functions can translate a vec2 between UV Coordinate and XY Coordinate. It just do some multiplication and division for you. uv2xy(vec2) Description : Calculate the xy position for a given uv position. Parameters : vec2 : uv position. Return : vec2 : xy position. NOTE : If your layer size is 1280 x 720. The uv2xy(vec2(0.1,0.5)); will return vec2(128.0,360.0); xy2uv(vec2) Description : Calculate the uv position for a given xy position. Parameters : vec2 : xy position. Return : vec2 : uv position. NOTE : If your layer size is 1920 x 1080. The xy2uv(vec2(192,108)); will return vec2(0.1,0.1); "},"contents/GLSL/LinkParameters.html":{"url":"contents/GLSL/LinkParameters.html","title":"Link parameters","keywords":"","body":"Link parameters The outside parameters are provided for you to do some animation. As you can see, there are 7 types of parameters are provided. Sliders Angles Points 3D Points Checkboxes Colors Layers Each of them has 10 controllers to use. Example : link_slider.shader void main(){ outColor = vec4(uv,slider[0],1.0); } If you change the slider 0, the color in your scene would change. Details The parameters decleared in PixelsWorld are as below : parameters.shader uniform float slider[10]; uniform float angle[10]; uniform bool checkbox[10]; uniform vec2 point[10]; uniform vec3 point3d[10]; uniform vec4 color[10]; uniform sampler2D layer[10]; uniform sampler2D inLayer; NOTE : The \"inLayer\" means Input layer. The sampler2D is a value type provided by GLSL, you don't need to understand this value type. If you want to use the layer parameter. Please see the \"getColor\" section \"uniform\" means global value. "},"contents/GLSL/debug.html":{"url":"contents/GLSL/debug.html","title":"Debug","keywords":"","body":"Debug Check the debug checkbox in the plugin panel. If your program contains errors, it will be printed into the left top corner of your screen when this is checked. "},"contents/GLSL/Advanced_settings.html":{"url":"contents/GLSL/Advanced_settings.html","title":"Advanced settings","keywords":"","body":"Advanced settings There are several advanced settings in the effect panel. Language It controls which compiler to be used. Wrap U/V sampler This will affect the result of getColor() when sampler the pixels which are outside the boundary of the image. Test code (Apply PixelsWorld to a footage.): wrap_uv_sampler.shader void main(){ outColor = getColor(uv*10); } Magnify/Minify sampler This will affect the behavior of getColor() when the sampler wants to do the interpolation of surrounding pixels. Test code (Apply PixelsWorld to footage.): wrap_uv_sampler.shader void main(){ outColor = getColor(uv*0.1); } If you want to build the same pixel style effect. Switch this option to Nearest pixel Mipmap Specify how the sampler sample color while the texture is scaled down. wrap_uv_sampler.shader void main(){ outColor = getColor(uv*10); } "},"contents/GLSL/predefined.html":{"url":"contents/GLSL/predefined.html","title":"Pre-defined code","keywords":"","body":"Predifined code Before run shader code, PixelsWorld combines your input with some predefined code to support some features. GLSL mode only has pre-define code. shadertoy mode has both pre-define and post-define codes. GLSL mode Pre-define code pre_frag_shader_glsl.frag #define gl_Position uv2xy(uv) #define gl_FragCoord uv2xy(uv) #define gl_FragColor outColor #define INPUT_LAYER_INDEX -1 #define OUTPUT_LAYER_INDEX -2 #define AE_INPUT_LAYER -1 #define PW_TEMP_LAYER -2 out vec4 outColor; in vec2 uv; uniform float slider[10]; uniform float angle[10]; uniform bool checkbox[10]; uniform vec2 point[10]; uniform vec3 point3d[10]; uniform vec4 color[10]; uniform sampler2D layer[10]; uniform vec2 layerResolution[10]; uniform sampler2D inLayer; uniform sampler2D outLayer; uniform float time; uniform float inpoint; uniform float duration; uniform float comp_time; uniform vec4 date; // vec4(year,month,day,hour*3600 + minute*60 + second + millisecond/1000.) uniform float fps; uniform float width; uniform float height; uniform vec2 origin; uniform vec2 resolution; uniform vec2 downsample; uniform mat4 camera_matrix; uniform vec4 camera_info; // x,y: resolution, z: distance to plane, w: distance to focus. uniform bool camera_perspective; uniform sampler1D inWaveL; // Left wave samples uniform sampler1D inWaveR; // Right wave samples uniform float inWaveN; // Wave sample number uniform float inWaveS; // Sample rate, settings in plugin panel. Default: 44100. uniform vec2 inWaveT; // vec2(sampleStartTime, sampleEndTime), unit: second. New in v3.4.0 uniform sampler1D inSpecL; // Left spectrum samples uniform sampler1D inSpecR; // Right spectrum samples uniform float inSpecN; // Spectrum sample number uniform vec2 inSpecF; // vec2(spectrumStartFrequency, spectrumEndFrequency), unit: hz. New in v3.4.0 vec4 getColor(int layerId,vec2 coord) { if(layerId==AE_INPUT_LAYER) return texture(inLayer,coord); if(layerId==PW_TEMP_LAYER) return texture(outLayer,coord); else if(layerId>=0 && layerId shadertoy mode Pre-define code pre_frag_shader_shadertoy.frag #define gl_Position (_PixelsWorld_uv * iResolution.xy) #define gl_FragCoord (_PixelsWorld_uv * iResolution.xy) #define gl_FragColor _PixelsWorld_outColor #define _PixelsWorld_INPUT_LAYER_INDEX -1 #define _PixelsWorld_OUTPUT_LAYER_INDEX -2 #define _PixelsWorld_AE_INPUT_LAYER -1 #define _PixelsWorld_PW_TEMP_LAYER -2 uniform vec3 iResolution; uniform float iTime; uniform float iTimeDelta; uniform int iFrame; // uniform float iChannelTime[4]; uniform vec4 iMouse; uniform vec4 iDate; uniform sampler2D iChannel0; uniform sampler2D iChannel1; uniform sampler2D iChannel2; uniform sampler2D iChannel3; uniform vec3 iChannelResolution[4]; uniform float _PixelsWorld_slider[10]; uniform float _PixelsWorld_angle[10]; uniform bool _PixelsWorld_checkbox[10]; uniform vec2 _PixelsWorld_point[10]; uniform vec3 _PixelsWorld_point3d[10]; uniform vec4 _PixelsWorld_color[10]; uniform sampler2D _PixelsWorld_layer[10]; uniform vec2 _PixelsWorld_layerResolution[10]; uniform sampler2D _PixelsWorld_inLayer; uniform sampler2D _PixelsWorld_outLayer; uniform float _PixelsWorld_time; uniform float _PixelsWorld_inpoint; uniform float _PixelsWorld_duration; uniform float _PixelsWorld_comp_time; uniform vec4 _PixelsWorld_date; uniform float _PixelsWorld_fps; uniform float _PixelsWorld_width; uniform float _PixelsWorld_height; uniform vec2 _PixelsWorld_origin; uniform vec2 _PixelsWorld_resolution; uniform vec2 _PixelsWorld_downsample; uniform mat4 _PixelsWorld_camera_matrix; uniform vec4 _PixelsWorld_camera_info; uniform bool _PixelsWorld_camera_perspective; uniform sampler1D _PixelsWorld_inWaveL; uniform sampler1D _PixelsWorld_inWaveR; uniform float _PixelsWorld_inWaveN; uniform float _PixelsWorld_inWaveS; uniform vec2 _PixelsWorld_inWaveT; uniform sampler1D _PixelsWorld_inSpecL; uniform sampler1D _PixelsWorld_inSpecR; uniform float _PixelsWorld_inSpecN; uniform vec2 _PixelsWorld_inSpecF; in vec2 _PixelsWorld_uv; out vec4 _PixelsWorld_outColor; vec4 _PixelsWorld_getColor(int layerId,vec2 coord) { if(layerId==_PixelsWorld_AE_INPUT_LAYER) return texture(_PixelsWorld_inLayer,coord); if(layerId==_PixelsWorld_PW_TEMP_LAYER) return texture(_PixelsWorld_outLayer,coord); else if(layerId>=0 && layerId Post-define code post_frag_shader_shadertoy.frag void main(){ mainImage(_PixelsWorld_outColor, _PixelsWorld_uv * iResolution.xy); } "},"contents/GLSL/shadertoy.html":{"url":"contents/GLSL/shadertoy.html","title":"Template Zone shadertoy","keywords":"","body":"Template Zone Shadertoy Usage On the Shadertoy mode, you can run codes from shadertoy.com. Note It doesn't mean all code from the Shadertoy can be seamlessly transferred into PixelsWorld. Some like \"VR\", \"Loop buffer reference\" are not supported. Details Add _PixelsWorld_ prefix to use variables that exist in GLSL mode. E.g. slider[0] on GLSL mode = _PixelsWorld_slider[0] on shadertoy mode. Refer to this page to learn more global definitions in the Shadertoy mode. It is not recommended to define your own _PixelsWorld_ prefixed variables. Use Buffers Shadertoy has 4 Buffers (or iChannels), which can be also applied into PixelsWorld. No-loop-ref Buffers If the effect you want to apply doesn't involve loop references (like the bottom part of the figure above). Then the effect is \"no-loop-ref\". You can apply the effect via the code template below. (Also need the Lua render mode) E.g.: An effect from https://www.shadertoy.com/view/4dVGRW This effect uses the BufferA, so A is set to true at the 4th line of the code below. BufferA is bound to the iChannel0 of the Main image. So AtoMain is set to 0 at the 15th line. Then, copy-paste the code of BufferA and Main to the corresponding variables. Finally, to make sure the result is right, set Advanced->Internal texture format to Floating point 32 bit x RGBA (HDR) to prevent PixelsWorld to clamp the value of the Alpha color channel. Also don't forget to check if the PixelsWorld is on the Lua render mode. rotatingCubes.lua version3() enable = { A=true, B=false, C=false, D=false, -- '-1': disable -- '0~3': which iChannel to set AtoB = -1, AtoC = -1, AtoD = -1, AtoMain = 0, BtoC = -1, BtoD = -1, BtoMain = -1, CtoD = -1, CtoMain = -1, DtoMain = -1, } mainCode = [==[ // Paste the main code here. mat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) { vec3 rr = vec3(sin(roll), cos(roll), 0.0); vec3 ww = normalize(target - origin); vec3 uu = normalize(cross(ww, rr)); vec3 vv = normalize(cross(uu, ww)); return mat3(uu, vv, ww); } vec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) { mat3 camMat = calcLookAtMatrix(origin, target, 0.0); return normalize(camMat * vec3(screenPos, lensLength)); } vec2 squareFrame(vec2 screenSize, vec2 coord) { vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0; position.x *= screenSize.x / screenSize.y; return position; } vec2 getDeltas(sampler2D buffer, vec2 uv) { vec2 pixel = vec2(1. / iResolution.xy); vec3 pole = vec3(-1, 0, +1); float dpos = 0.0; float dnor = 0.0; vec4 s0 = texture(iChannel0, uv + pixel.xy * pole.xx); // x1, y1 vec4 s1 = texture(iChannel0, uv + pixel.xy * pole.yx); // x2, y1 vec4 s2 = texture(iChannel0, uv + pixel.xy * pole.zx); // x3, y1 vec4 s3 = texture(iChannel0, uv + pixel.xy * pole.xy); // x1, y2 vec4 s4 = texture(iChannel0, uv + pixel.xy * pole.yy); // x2, y2 vec4 s5 = texture(iChannel0, uv + pixel.xy * pole.zy); // x3, y2 vec4 s6 = texture(iChannel0, uv + pixel.xy * pole.xz); // x1, y3 vec4 s7 = texture(iChannel0, uv + pixel.xy * pole.yz); // x2, y3 vec4 s8 = texture(iChannel0, uv + pixel.xy * pole.zz); // x3, y3 dpos = ( abs(s1.a - s7.a) + abs(s5.a - s3.a) + abs(s0.a - s8.a) + abs(s2.a - s6.a) ) * 0.5; dpos += ( max(0.0, 1.0 - dot(s1.rgb, s7.rgb)) + max(0.0, 1.0 - dot(s5.rgb, s3.rgb)) + max(0.0, 1.0 - dot(s0.rgb, s8.rgb)) + max(0.0, 1.0 - dot(s2.rgb, s6.rgb)) ); dpos = pow(max(dpos - 0.5, 0.0), 5.0); return vec2(dpos, dnor); } void mainImage(out vec4 fragColor, in vec2 fragCoord) { vec3 ro = vec3(sin(iTime * 0.2), 1.5, cos(iTime * 0.2)) * 5.; vec3 ta = vec3(0, 0, 0); vec3 rd = getRay(ro, ta, squareFrame(iResolution.xy, fragCoord.xy), 2.0); vec2 uv = fragCoord.xy / iResolution.xy; vec4 buf = texture(iChannel0, fragCoord.xy / iResolution.xy); float t = buf.a; vec3 nor = buf.rgb; vec3 pos = ro + rd * t; vec3 col = vec3(0.5, 0.8, 1); vec2 deltas = getDeltas(iChannel0, uv); if (t > -0.5) { col = vec3(1.0); col *= max(0.3, 0.3 + dot(nor, normalize(vec3(0, 1, 0.5)))); col *= vec3(1, 0.8, 0.35); } col.r = smoothstep(0.1, 1.0, col.r); col.g = smoothstep(0.1, 1.1, col.g); col.b = smoothstep(-0.1, 1.0, col.b); col = pow(col, vec3(1.1)); col -= deltas.x - deltas.y; fragColor = vec4(col, 1); } ]==]; commonCode = [==[ // Paste the common code here. ]==] bufferACode = [==[ // Paste the Buffer A code here. float sdBox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); } vec2 mirror(vec2 p, float v) { float hv = v * 0.5; vec2 fl = mod(floor(p / v + 0.5), 2.0) * 2.0 - 1.0; vec2 mp = mod(p + hv, v) - hv; return fl * mp; } vec2 rotate2D(vec2 p, float a) { return p * mat2(cos(a), -sin(a), sin(a), cos(a)); } float map(vec3 p) { float r = iMouse.z > 0.0 ? iMouse.x / 100.0 : iTime * 0.9; p.xz = mirror(p.xz, 4.); p.xz = rotate2D(p.xz, r); float d = sdBox(p, vec3(1)); d = min(d, sdBox(p, vec3(0.1, 0.1, 3))); d = min(d, sdBox(p, vec3(3, 0.1, 0.1))); return d; } mat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) { vec3 rr = vec3(sin(roll), cos(roll), 0.0); vec3 ww = normalize(target - origin); vec3 uu = normalize(cross(ww, rr)); vec3 vv = normalize(cross(uu, ww)); return mat3(uu, vv, ww); } vec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) { mat3 camMat = calcLookAtMatrix(origin, target, 0.0); return normalize(camMat * vec3(screenPos, lensLength)); } float calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) { float latest = precis * 2.0; float dist = +0.0; float type = -1.0; float res = -1.0; for (int i = 0; i maxd) break; float result = map(rayOrigin + rayDir * dist); latest = result; dist += latest; } if (dist = 0 and sch Loop-ref Buffer Um...We really don't recommend applying the Loop-ref Buffer. (But there still a way to do it. You should get ready to fight with Ae and PixelsWorld for a long night. I'm ready to go>>>) "},"contents/Lua/JavaScript.html":{"url":"contents/Lua/JavaScript.html","title":"World Outskirts JavaScript","keywords":"","body":"JavaScript Code Javascript can be executed by function js(\"Your code\") on Lua (CPU & GPU) language mode. executeJS.lua version3() js(\"alert('Hello PixelsWorld!')\"); Note: Due to the structure of Ae, running js code inside PixelsWorld is not recommended. You are supposed to use js to do some simple calculations based on local variables. "},"contents/Lua/CMDCode.html":{"url":"contents/Lua/CMDCode.html","title":"World Bed Rocks CMD","keywords":"","body":"CMD Code CMD commands can be executed by function cmd(\"Your cmd commands\") on Lua (CPU & GPU) language mode. executeCMD.lua version3() cmd(\"echo Hello PixelsWorld! & pause\"); "},"contents/Serial/SerialAttention.html":{"url":"contents/Serial/SerialAttention.html","title":"Apointments","keywords":"","body":"Appointments One serial number contains N Register number (N >= 1) One Register number registers one PC permanently. One Register number can be shared in any version of Ae on a PC. Registering costs one Register number, deactivating recovers one Register number Only Registering and Deactivating need internet. You can use PixelsWorld offline after registering is completed. You don't have to deactivate before re-installing your OS, UNLESS you changed the hardware like CPU or mainboard. When you finished re-installing your OS, register PixelsWorld again, this kind of registration doesn't cost the Register number. Contact us if you forget to deactivate your serial number and you have already changed your CPU and mainboard. Serial number doesn't bind with any personal information. You can BUT NOT RECOMMEND sell it. MiLai visual performance group is not responsible for ANY trouble that happened in this kind of deal. The default value of Register number is 1. If you have more than one PC and you also want to run PixelsWorld on your multiple machines at the same time. Please purchase the corresponding number of PixelsWorld, we will send you the Serial number with Register number specified by you. "},"contents/QA/EntryPointErr.html":{"url":"contents/QA/EntryPointErr.html","title":"Error: Couldn't find main entry point for PixelsWorld.aex (48::72)","keywords":"","body":"Error: Couldn't find main entry point for PixelsWorld.aex (48::72) If the next error occurred, please check these things list below: Use Creative Cloud to update your Ae to the latest version(We recommend Ae CC 2019 16.1.3+ or 2020 17.5.1+) Windows10 should be up-to-date(Windows 10 20H2 or later version is recommended) Graphic card drivers should be up-to-date Graphic card should support OpenGL 3.3 or later(You can use OpenGL Extensions Viewer tool to get the version info) There should be OpenCL.dll in C:\\Windows\\System32 "}}