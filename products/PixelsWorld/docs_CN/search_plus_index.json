{"./":{"url":"./","title":"成为创世神","keywords":"","body":"成为创世神 PixelsWorld 文档版本 : v3.6.0 作者：中梓星音 协助：月离 历史版本 v2.3.1 v2.0 v1.0 English version 日本語 Slack 讨论社区 国内服务器文档>>> 原档>>> 下载文档(中文) 下载文档(English) 下载文档(日本語) 欢迎进入像素世界！ 我们把像素世界中最精华的部分都压缩在这一页的内容里。若掌握了本页内容，您就会成为像素世界新的创世神！ 简单来说 像素世界是一款通过代码来渲染图像的插件 您可以直接使用其他艺术家写好的代码来渲染场景。 您可以通过学习简单的绘图代码，用像素世界程序化绘制图形。 您可以通过学习硬核的GLSL代码，用像素世界写特效。 在像素世界中写代码是什么感觉？ 简单来说，像素世界就是一个绘画机器人，您把需要绘制的图案、绘制的地点按照绘制顺序告诉它，它会依次帮您绘制场景。 例如您想在屏幕正中间绘制一个小房子，而拿着画笔的是您的好朋友（并且TA不知道您想要绘制的场景），思考一下您应该如何和TA一起完成这幅作品。 通常，您可能会这么说： DrawHouse.myBro 在画布中间绘制一个房子 当然这么说是ok的，但是如果加上“我们只能告诉TA画的位置和基本图形及颜色，不能直接告诉TA答案”这样的限制的话，我们大概需要这么说： DrawHouse2.myBro 把画笔移到正中间 给画笔沾上黄色涂料 以画笔为中心绘制一个10cm的正方形 把画笔向上移动5cm 给画笔沾上红色颜料 绘制一个底边15cm，高10cm的等腰三角形 至此，您就和您的朋友完成了房子的绘制！ 其实上面您发出的指令正是要填入PixelsWorld中的代码，把它整理一下大概需要写成下面的形式： DrawHouse3.lua version3() -- 使用版本3（每次绘制开始必须加的代码） move(width/2, height/2) -- 画笔移至中央 rotateX(PI) -- 朝上 fill(1,1,0) -- 黄色涂料（Red=1,Green=1,Blue=0） rect(100) -- 100像素尺寸的正方形 fill(1,0,0) -- 红色颜料（Red=1,Green=0,Blue=0） move(0,50) -- 向上移动 tri(150,100) -- 绘制150底100高的等腰三角形 这里有一个技术细节是，我们在指令中没有提到rotateX(PI)，因为Ae中坐标默认是朝下是Y轴正方向，我们需要沿着X轴把Y轴转180度，如果去掉这一行，move(0,50)将会把画笔向下移动50像素单位。 开天辟地，制作您的第一幅作品 为了使用像素世界，首先需要把它放到一个固态层上。 确保语言(Language)选项切换到Lua模式后，点击Edit按钮。（如下图所示）点击Ok按钮后，就能看到由您指导绘制的小房子了。 当然，只是这样的话未免有些无聊，我们需要给这个小房子加入一些可控性。比如，我们想自由控制房子的配色，这里需要做如下修改： DrawHouse4.lua version3() -- 使用版本3（每次绘制开始必须加的代码） move(width/2, height/2) -- 画笔移至中央 rotateX(PI) -- 朝上 fill(color(0)) -- 涂上0号颜色 rect(100) -- 100像素尺寸的正方形 fill(color(1)) -- 涂上1号颜色 move(0,50) -- 向上移动 tri(150,100) -- 绘制150底100高的等腰三角形 当你点击Ok的时候，会发现场景中的房子消失了！ 其实房子没消失，只是因为我们的颜色控制器都是黑色的。 打开Colors列表，找到前两个控制器，调成你想要的颜色即可。 村长就是我！创建更多的房子 使用代码的一个甜头就是可以做重复性极高的动作。 我们使用的代码语言（Lua）中，有重复一段代码的功能。 RepeatHouse.lua version3() -- 使用版本3（每次绘制开始必须加的代码） move(width/2, height/2) -- 画笔移至中央 rotateX(PI) -- 朝上 for i=1,3 do -- 重复段开始标志（共重复3次） fill(color(0)) -- 涂上0号颜色 rect(100) -- 100像素尺寸的正方形 fill(color(1)) -- 涂上1号颜色 move(0,50) -- 向上移动50单位 tri(150,100) -- 绘制150底100高的等腰三角形 move(0,-50) -- 向下移动回50单位 move(175,0) -- 画笔朝右移动175单位 end -- 重复段结束标志 最后我们想让颜色控制器附上自己的名字，方便我们之后使用，我们可以在参数编辑器里修改参数名称： 保存指令，回收利用 注意，这一步需要Ae开启管理员模式，请确保以管理员模式打开Ae。 首先，先新建一个自己的预设栏目： 然后在自己的预设栏目下，保存自己的预设： 使用预设 选中您想要的预设，点击右面的Replace按钮即可。 恭喜您！ 您已经掌握了像素世界的大体使用流程！ >>>下一步：前往Lua章节来了解更多的绘制代码 >>>下一步：开启GPU着色器的潘多拉魔盒 PixelsWorld结构 PixelsWorld能力范围 "},"contents/HowTo.html":{"url":"contents/HowTo.html","title":"获得与使用","keywords":"","body":"获得与使用 下载 购买/下载PixelsWorld 请注意： 部分测试预设在非商业许可证下，使用前请留意源码中的许可证书。 把“MiLai”文件夹放在 : AE安装目录/Support Files/Plug-ins/ 插件位于 : AE安装目录/Support Files/Plug-ins/MiLai/PixelsWorld.aex 如何使用 打开 Adobe After Effects. \"Ctrl + N\"(或 \"Command + N\") 新建合成。 新建一个纯色层 选择刚添加的图层 右键 => 效果 => MiLai => PixelsWrold 单击\"Edit\" 来改变 \"世界规则\"。 此时会弹出菜单 。 在右上处的\"Preset list\"一个您喜欢的效果栏目，并在下面的列表中选择一个预设。 点击Replace按钮。 单击 \"Ok\"。 "},"contents/gotoForum.html":{"url":"contents/gotoForum.html","title":"前往论坛","keywords":"","body":"前往未来视觉演绎组官方论坛 我们为像素世界建立了一个官方论坛，您可以 前往官方公告论坛 前往答疑论坛 论坛内容 像素世界的各大版本更新介绍 像素世界相关文章 像素世界序列号相关信息 像素世界预设博物馆 "},"contents/Editor/ScriptWindow.html":{"url":"contents/Editor/ScriptWindow.html","title":"世界法则编辑器","keywords":"","body":"世界法则编辑器 打开方法 点击\"World formula\"旁的\"Edit\"按钮即可打开世界法则编辑器。以下是世界法则编辑器打开后的样子。 注意，这里随版本升级可能实际样式会稍有不同。 为了方便说明，我们用不同的颜色框出不同的功能区，如下图： ◆代码区 可以在该区域编写您富有创造力的渲染代码。 Language处的选项会在您完成编辑后自动更改插件面板上的语言类型。该设定会在保存预设的时候被记录在预设文件中。(default)选项将不会对您的语言做修改。 ◆参照表 这里提供一些便捷代码供您复制使用。这里的文档目前是只读模式，无法修改。 ◆参数设定 这里将显示参数面板的名称和默认值、以及语言设定。如果您想修改参数名称或默认值，可通过点击下面的Parameter manager即可进入参数管理器。 参数设定将在保存预设时一同被记录进预设文件。 ◆预设列表 上方的下拉列表会显示所有预设栏目。我们对预设进行如下定义： 一个带有.pwp后缀、并放置于插件旁边的JSON格式文件将被视为一个预设栏目。其栏目名称即为文件名称。 一个预设栏目里存放着数个预设数据 一个栏目的所有预设数据将被列在下拉栏下方的列表中。 ◆预设法则预览 用户在列表中选择的预设数据的代码数据将被显示在这里。如果您确定这个预设是您想要的，点击Replace按钮来替换编辑窗的代码。 如果您只想替换文字部分。可以取消选择预设参数设定预览区域中的Apply when replace。 如果您想在目前编辑的代码前面添加预设代码，可以点击按钮；若是想添加到后方，则可以点击Bottom>>按钮。 ◆预设参数设定预览 用户在列表中选择的预设数据的参数设定数据将被显示在这里。如果您确定要使用当前参数，点击Apply按钮。 Apply when replace选项框将决定是否在您点击上方Replace按钮时自动应用当前预设上的参数设定。 "},"contents/Editor/ParameterWindow.html":{"url":"contents/Editor/ParameterWindow.html","title":"参数编辑器","keywords":"","body":"参数编辑器 通过点击世界法则编辑器上的Parameter manager按钮来启动参数编辑器。打开后如下图所示： 规则 长框输入名称，短框输入默认值（十进制数字）。 Clear names按钮会清除各区域名称。最下方的Clear all names按钮则会清除所有区域的名称。 Reset names按钮会重置各个区域的名称为默认名称，最下方的Reset all names按钮则会重置所有区域的名称为默认名称。 Reset value按钮会重置各个区域的数值，最下方的Reset all names按钮则会重置所有区域的数值。 注意：point和3dpoint的范围应当为0~1，例如在1280x720的图层上，使用0.5, 0.5作为point的默认值时，PixelsWorld会自动换算为640x360到插件面板UI上的point控件上。 参数名称编码语言 像素世界对utf-8和本地编码做了支持，参数名称理论上支持大部分Unicode字符。但是因为Ae编码支持问题，预设中的名称数据在不同区域的系统中，不受支持的字符有可能被翻译成?（←问号）（这种情况并非乱码）。 如果您是个人艺术创作者，命名语言可以任意安排。 如果您是有附属团队的艺术创作者，尤其是附属在含国际交流的艺术创作团队时我们推荐您使用ASCII（一般是由英文字母、数字、下划线组成）中的可显示字符组成的参数名称。 "},"contents/Editor/SavePresets.html":{"url":"contents/Editor/SavePresets.html","title":"预设管理","keywords":"","body":"预设管理 保存预设 在世界法则编辑器中，可以通过点击Save as preset按钮并输入名称来保存预设。 注意：若使用预设列表中已存在的预设名称，会发生覆盖。 覆盖保存预设 在世界法则编辑器中，可以通过点击Save as preset按钮并输入列表中已有预设的名称来覆盖原有预设。 注意： 该操作不可逆，请注意备份。 不同预设栏目的预设名称不会相互干扰。 重命名预设 双击预设列表中的想要重命名的预设，在输入框中输入除了REMOVE和SORT的名称。 排序预设列表 双击预设列表中的任意预设，在输入框中输入SORT。 删除预设 双击列表中的想要删掉的预设，在输入框中输入REMOVE。 添加预设栏目 点击Preset list面板中的下拉列表旁的Add按钮来添加预设栏目。 注意： 无法把已有的栏目名作为新栏目名使用。 添加栏目等同于在插件旁边创建一个预设文件。如果创建失败或者第二次打开Ae时预设文件消失请为Ae开启管理员模式来允许像素世界对您的磁盘进行读/写。 预设格式/预设文件 预设采用utf-8（小字序）编码下的JSON格式储存信息。 预设文件使用明文储存，我们不对预设做任何加密。 预设文件可以使用第三方JSON编辑工具修改。但有破坏预设结构的风险，不推荐。 预设投稿 如果您有意愿通过官方渠道公开您的预设，欢迎投稿您的预设至邮箱：rly_pxx_123@sina.com。 我们会定期整合收到的预设，并把投稿人员的名单公开在插件的About按钮处。 "},"contents/Lua/LuaCode.html":{"url":"contents/Lua/LuaCode.html","title":"世界的中心Lua","keywords":"","body":"世界的中心Lua 在第一章中给大家介绍的语言叫做Lua * Lua是一种轻量级，高级，多范式编程语言，主要用于嵌入式应用程序中. ——Wiki) 版本 : Lua5.3（点击查看中文完全技术文档） 注意：PixelsWorld v3.2.0起使用Lua5.4 Lua是一种十份类似表达式和Ae脚本的语言，是像素世界的中心，连接了所有模块。基本上你只要记住几个操作的英文单词，就可以让像素世界按部就班的为您绘制图形。 像素世界的所有渲染指令都可以通过Lua这个中枢发出。比如您想绘制可以和Ae摄像机互动的立方体，只需要输入 DrawCube.lua version3() move(width/2,height/2) dim3() cube(300) dim3()是使用三维模式绘图的函数 比如您想渲染GLSL代码，只需要输入 RunGlsl.lua version3() glsl([==[ void main(){ vec3 col = 0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4)); outColor = vec4(col,1.0); } ]==]) 并在中间输入GLSL代码即可； 如果您想执行shadertoy的代码，只需要输入 RunShadertoy.lua version3() shadertoy([==[ void mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec2 uv = fragCoord/iResolution.xy; vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)); fragColor = vec4(col,1.0); } ]==]) 并在中间输入来自shadertoy的代码即可。 我们在这里列出Lua的能力范畴： 获取像素数据 编写像素数据 运行 JavaScript 运行 GLSL 获取参数数据 运行外置C语言库 加载Lua模块 同时Lua与JavaScript非常相似，因为JavaScript是非常易学的语言，所以即使您没有编程基础也会在短时间内迅速掌握它。 PixelsWorld结构 "},"contents/Lua/RunLua.html":{"url":"contents/Lua/RunLua.html","title":"运行Lua","keywords":"","body":"运行Lua代码 切换语言为Lua ( CPU & GPU ) 导入代码： hello.lua version3() a = 5+6 b = \"PixelsWorld\" c = \"is cool!\" d = time e = slider(0) f = \"5 + 6 = \" .. a .. \"\\nMessage : \" .. b .. \" \" .. c .. \"\\nCurrent time is : \" .. d .. \" (s)\\nValue of slider0 is : \" .. e print(f) a..b 将变量a与b合并为字符串。 print() 在屏幕上渲染信息。 slider() 获取指定参数值。 您可以在每行的末尾添加 ; 非必须。Lua会将\\ n（换行符）视为一段代码的结束标记。 您最终会在屏幕的左上角看到输出信息。 "},"contents/Lua/WriteLocalCode.html":{"url":"contents/Lua/WriteLocalCode.html","title":"读取本地代码","keywords":"","body":"在本地写代码 如果您不喜欢像素世界自带的编辑器，您可以在本地创建txt文档，并用如下代码导入像素世界中。 不要把代码文件放在系统盘(C:\\盘)里。 loadTxt.lua version3() runFile([[d:\\mycode.txt]]) -- Replace to your path 这里使用[[d:\\mycode.txt]]而不是\"d:\\mycode.txt\"的原因是，后者的\\会发生转译。 您可以使用任何后缀名(*.lua, *.code, *.magic)，只要文件内容是文本即可。 如果您想把代码放到工程文件旁边，可以用如下代码。 loadTxt.lua version3() runFile( projectFolder .. [[mycode.txt]]) -- Replace to your file name 注意，使用projectFolder的前提是你的工程已保存在本地。 事情没完！别忘记刷新代码 当你在本地敲完代码保存后，像素世界并不会立刻响应到场景中，您需要按住Ctrl + Alt，鼠标点击插件面板上的LOGO图片，像素世界就会去读取您写好的新的代码。 这里的LOGO图片会按照一定的概率分布随机轮播。为了照顾有收集喜好的艺术家，我们设计了很多精美的LOGO放在这里。 "},"contents/Lua/LinkParameters.html":{"url":"contents/Lua/LinkParameters.html","title":"链接参数","keywords":"","body":"链接参数 使用下面的函数调用插件面板上的参数。 parameters.lua slider(id) -- 返回1个double angle(id) -- 返回1个double point(id) -- 返回2个double point3d(id) -- 返回3个double checkbox(id) -- 返回1个boolean color(id) -- 返回3个double layer(id,x,y) -- 返回4个double 当有多个变量返回的时候，您需要声明多个变量来接住返回值，例如point()函数 point.lua version3() x,y = point(0) println('x is ' .. x) println('y is ' .. y) "},"contents/Lua/globals.html":{"url":"contents/Lua/globals.html","title":"全局参数","keywords":"","body":"全局变量 全局常量 PixelsWorld提供以下几个全局常量供用户使用： const.lua PI -- 圆周率 pi TPI -- 二倍圆周率 two pi HPI -- 圆周率一半 half pi QPI -- 圆周率四分之一 quarter pi E -- 自然数 e PHI -- 黄金分割数 phi R2 -- 根号2 root 2 R3 -- 根号3 root 3 R5 -- 根号5 root 5 R7 -- 根号7 root 7 INPUT -- 输入材质编号 -1 TEMP -- 缓存材质编号 -2 OUTPUT -- 输出材质编号 -3 PARAM0 -- 第0号图层材质 0 PARAM1 -- 第1号图层材质 1 PARAM2 -- 第2号图层材质 2 PARAM3 -- 第3号图层材质 3 PARAM4 -- 第4号图层材质 4 PARAM5 -- 第5号图层材质 5 PARAM6 -- 第6号图层材质 6 PARAM7 -- 第7号图层材质 7 PARAM8 -- 第8号图层材质 8 PARAM9 -- 第9号图层材质 9 platform -- 平台：Windows10: 0 目前不支持其它平台 host -- 宿主程序：Ae: 0，目前不支持其它宿主 全局变量 PixelsWorld提供以下几个Ae中获取的变量供用户使用： globalvars.lua depth -- 颜色深度，8，16，32 width -- 输入层宽度 height -- 输入层高度 time -- 当前时间(s) duration -- 所在图层持续时间(s) inpoint -- 所在图层入点时间(s) compTime -- 合成时间(s) pluginFolder -- 插件所在目录(utf8) projectName -- 工程名(utf8) projectPath -- 工程路径(utf8) projectFolder -- 工程所在文件夹的路径(utf8) ds_width -- 降采样后合成宽度 ds_height -- 降采样后合成高度 origin_x -- 输入层左上角在图层坐标系的X坐标 origin_y -- 输入层左上角在图层坐标系的Y坐标 打印全局变量 在Lua模式运行下面的代码来打印全局变量（包括全局函数） printGlobals.lua version3() in2out() for k, v in pairs(_G) do print(k) print(\" \" .. type(v) , .5,.5,.5) print(\" \".. tostring(_G[k]),0,1,1) println(\"\") end "},"contents/Lua/FuncList.html":{"url":"contents/Lua/FuncList.html","title":"函数列表","keywords":"","body":"函数列表 以下是定义在PixelsWorld中Lua模式的所有函数。 必须声明函数 version3 获取参数函数 slider, angle, point, point3d, checkbox, color, layer 输出信息函数 print, println, alert 变换函数 move, scale, rotate, rotateX, rotateY, rotateZ, twirl beginGroup, endGroup, beginGlobal, endGlobal global2local, local2global, global2screen, screen2global getTransformMatrix 绘制函数 图元 tri, quad, rect, circle, ellipse, par, line cube, tet, cone, ball, tube image, imageAlign, imageAnchor text, textSize, textFont, textAlign, textAnchor, textAlignOuter, textInterval, textAdvanceScale coord, grid poly, setPoly background, in2out 绘制属性控制 dim2, dim3 perspective, noPerspective fill, noFill, stroke, noStroke, dot, noDot wireframe, noWireframe blendAlpha, noBlendAlpha back, noBack pure, phong, anime rgba, depth, normal setDepth 灯光 ambientLight, pointLight, parallelLight clearLight, getLight 摄像机 aeCamera, lookAt, viewSpace 描边细节 strokeWidth, strokeDivision, strokeGlobal, strokeLocal 点渲染细节 dotRadius, dotDivision, dotGlobal, dotLocal 输出细节 smooth, noSmooth 贴图操作 newTex, delTex, getSize, swapTex, drawTo, castTex, blendTex, copyTex, savePNG, loadPNG, saveEXR, loadEXR, rotateTex, flipTex, resizeTex, trimTex 工具 r2d, d2r map clamp step smoothStep bezier rgb2hsl,hsl2rgb,rgb2hsv,hsv2rgb,rgb2cmy,cmy2rgb,rgb2cmyk,cmyk2rgb,cmy2cmyk,cmyk2cmy,hsl2hsv,hsv2hsl utf8ToLocal, localToUtf8 getGLInfo, getDrawRecord, getStatus getAudio loadString saveString 读写像素函数 getColor, setColor, getSize, 执行代码函数 shadertoy, glsl, cmd, lua, runFile, txt 详细介绍 version3 version3() 函数是Lua模式必须在第一行声明的函数。它的作用是把pw3这个表下的所有函数放到全局域中，如果没有这一行，您需要把所有PixelsWorld提供的函数前面加入pw3.前缀，比如之后会介绍的println()函数则需要写成pw3.println()。相反，如果您在第一行调用了version3()函数，则不需要写pw3.前缀。这是为了让您的代码能向后兼容而设计的函数。我们推荐（Lua渲染模式下的）任何情况下都在第一行加入version3()的调用。 version3.lua version3() println(\"Hello PixelsWorld! \") without_version3.lua pw3.println(\"Hello PixelsWorld! \") print print(str),print(str,brightness),print(str,r,g,b),print(str,r,g,b,a)是在屏幕左上角输出信息的函数。 print.lua version3() print(\"Hello PixelsWorld! \") str = \"Hello, I am colorful PixelsWorld! \" for i=1,#str do local c = str:sub(i,i) local phase = math.sin(i/#str*TPI + time*10) / 2 + .5 print(c,phase,1-phase,1,1) end println println(str),println(str,brightness),println(str,r,g,b),println(str,r,g,b,a)是在屏幕左上角输出信息的函数。并在每次输出信息后换行。 println.lua version3() println(\"Hello PixelsWorld! \") str = \"Hello, I am colorful PixelsWorld! \" for i=1,#str do local c = str:sub(i,i) local phase = math.sin(i/#str*TPI + time*10) / 2 + .5 -- println(c,phase,1-phase,1,1) print(c,phase,1-phase,1,1) end alert alert(str)是在屏幕左上角输出警示信息的函数。它目前等价于println(str,1,1,0,1) alert.lua version3() alert(\"Warning: Write your message here! \") move move(x,y),move(x,y,z)是平移画笔坐标的函数。 所有变换都是以当前画笔坐标为基准进行的。 例如下面这个例子： move.lua version3() coord() -- 显示变换前的画笔位置 move(100,0) coord() -- 显示第1次变换后的画笔位置 move(0,100) coord() -- 显示第2次变换后的画笔位置 最终画笔会在(100,100,0)位置处。 scale scale(ratio),scale(x,y),scale(x,y,z)是缩放画笔坐标的函数。 所有变换都是以当前画笔坐标为基准进行的。 scale.lua version3() move(100,100) scale(2) rect(50,25) no_scale.lua version3() move(100,100) --scale(2) rect(50,25) rotate rotateX rotateY rotateZ rotate(theta)是把画笔坐标旋转theta弧度的函数，rotateX(theta)则是把画笔坐标沿着其X轴旋转的函数，rotate(theta)本质等价于rotateZ(theta)。 所有变换都是以当前画笔坐标为基准进行的。 如果您不熟悉弧度，可以用函数d2r(degree)来把角度转成弧度。例如：rotate(d2r(90))则是旋转九十度。 rotate_degree.lua version3() move(100,100) rotate(d2r(45)) rect(50,25) rotate_radian.lua version3() move(100,100) rotate(PI/4) rect(50,25) rotateX.lua version3() dim3() move(100,100) grid() coord() rotateX(d2r(45)) cube(50,25,10) rotateY.lua version3() dim3() move(100,100) grid() coord() rotateY(d2r(45)) cube(50,25,10) rotateZ.lua version3() dim3() move(100,100) grid() coord() rotateZ(d2r(45)) cube(50,25,10) twirl twirl(theta,x,y,z)是沿着(x,y,z)轴旋转theta弧度画笔的函数。比如，上面的rotateX(theta)则等价于这里的twirl(theta,1,0,0)。 所有变换都是以当前画笔坐标为基准进行的。 twirl是对四元数旋转的一种矩阵实现。 twirl.lua version3() dim3() move(100,100) grid() coord() stroke(1,1,0) line(-50,-50,-50,50,50,50) stroke(0,0,0) twirl(d2r(90),1,1,1) cube(50,25,10) beginGroup endGroup beginGroup(),endGroup()是创建父子级关系的函数。beginGroup()到endGroup()之间的变换(move,scale,rotate,twirl)在endGroup()之后会被撤销掉。 beginGroup(mat)创建父子级关系并把4x4矩阵mat推入场景。（可以用getTransformMatrix来获得变换矩阵。） 它等价于Processing中的pushMatrix()和popMatrix() 例如：下面两块代码是等价的 group.lua version3() for i = 1,6 do beginGroup() move(i*25,i*25) rotate(d2r(15*i)) rect(25) endGroup() end without_group.lua version3() for i = 1,6 do move(i*25,i*25) rotate(d2r(15*i)) rect(25) rotate(d2r(-15*i)) move(-i*25,-i*25) end beginGlobal endGlobal 夹在beginGlobal,endGlobal之间的绘图函数 将暂时以全局坐标系绘制 beginGlobal.lua version3() move(100,100) fill(0,1,0) -- green rect(50) -- Dran on (100,100,0) beginGlobal() fill(1,0,0) -- red rect(50) -- Draw on (0,0,0) endGlobal() move(100,100) fill(0,0,1) -- blue rect(50) -- Draw on (200,200,0) global2local global2local(x,y,z)将全局坐标转为局部坐标。返回三个double。 global2local.lua version3() move(100,100) rect(25) move(0,50) rotate(d2r(30)) coord() x,y,z=global2local(100,100,0) println(\"The local coordinate of the rectangle is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") local2global local2global(x,y,z)将局部坐标转为全局坐标。返回三个double。 local2global.lua version3() move(100,100) move(0,50) rotate(d2r(30)) coord() move(25,50) rect(25) x,y,z=local2global(0,0,0) println(\"The global coordinate of the rectangle is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") global2screen global2screen(x,y,z)将全局坐标转为屏幕坐标。返回三个double。 此转换受透视与否影响 global2screen.lua version3() dim3() move(100,100,0) move(0,50,0) rotateZ(d2r(30)) coord() move(25,50,0) cube(25) x,y,z=global2screen(local2global(0,0,0)) println(\"The screen coordinate of the rectangle is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") screen2global screen2global(x,y,z)将屏幕坐标转为全局坐标。返回三个double。 此转换受透视与否影响 screen2global.lua version3() dim3() x,y,z=screen2global(0,0,0) println(\"The global coordinate of the camera is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") getTransformMatrix getTransformMatrix()将返回一个列主体的4x4变换矩阵。这个变换矩阵可以应用在beginGroup(mat)里。 mat[i][j]可以访问第i列第j行元素。(i,j范围1~4) 例子： matrix.lua version3() dim3() beginGroup() move(width/3,height/3) twirl(d2r(30),1,1,1) cubetransform = getTransformMatrix() endGroup() beginGroup(cubetransform) cube(50) endGroup() tri tri(radius)以半径为radius的圆做一个内接正三角形，并指向画笔坐标y轴正方向。 tri()等价于tri(100) tri(w,h)以底边为w高为h做一个等腰三角形。 tri(p1x,p1y,p2x,p2y,p3x,p3y)以p1,p2,p32个二维点为顶点做三角形 tri(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z)以p1,p2,p33个三维点为顶点做三角形 如果想要观察三维三角形，请在version3()函数后加入dim3()，并在Ae图层中建立摄像机观测。 前3种方式构造的三角形的法线默认为画笔坐标z轴负方向，后2种方式构造的三角形则以cross(p1-p2,p3-p2)定几何法线。 函数名为triangle的缩写 tri1.lua version3() move(width/2,height/2) tri(100) tri5.lua version3() dim3() move(width/2,height/2) tri(0,0,100,50,0,0,0,50,0) quad quad(p1x,p1y,p2x,p2y,p3x,p3y,p4x,p4y) quad(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z,p4x,p4y,p4z) 以p1,p2,p3的顺序绘制第一个三角形，以p1,p3,p4的顺序绘制第二个三角形。 quad.lua version3() move(200,100) quad(0,0,75,0,50,40,0,15) rect rect(size)绘制size尺寸的正方形 rect()等价于rect(100) rect(width,height)绘制长width高height的长方形 长方形将以画笔坐标中心为对角线交点生成。 函数名为rectangle的缩写 rect.lua version3() move(200,100) rect(100,75) circle circle(radius)绘制一个半径为radius的圆 circle()等价于circle(100) circle(radius, div)绘制一个半径为radius，分段数为div的圆。 默认分段为128 circle.lua version3() move(100,100) fill(1,0,0) circle(25) move(100,0) fill(0,1,0) circle(25,10) move(100,0) fill(0,0,1) circle(25,3) ellipse ellipse(radiusx,radiusy)绘制一个x半径为radiusx，y半径为radiusy的椭圆 ellipse()等价于ellipse(100,100) ellipse(radiusx,radiusy,div)绘制一个x半径为radiusx，y半径为radiusy分段div的椭圆 默认分段为128 ellipse.lua version3() move(100,100) fill(1,0,0) ellipse(25,15) move(100,0) fill(0,1,0) ellipse(25,15,10) move(100,0) fill(0,0,1) ellipse(25,15,4) line line(p1x,p1y,p2x,p2y)绘制一条线段 line(p1x,p1y,p1z,p2x,p2y,p2z)绘制一条三维线段 line()等价于line(0,0,0,100,100,100) 线的颜色是由stroke(r,g,b)控制的。 线的粗细是由strokeWidth(width)控制的 线默认是被渲染出来的，屏蔽线渲染请使用noStroke()，开启线渲染则用stroke() line.lua version3() move(200,100,0) stroke(1,0,0) line(0,0,0,50) move(100,0,0) stroke(0,1,0) line(0,0,0,50) move(100,0,0) stroke(0,0,1) line(0,0,0,50) line_circle.lua version3() math.randomseed(1) num = 32 move(width/2,height/2) for i=1,num do beginGroup() rotateZ(d2r(360/num*i)) strokeWidth(math.random()*3) line(0,0,100,0) endGroup() end par par(x) 绘制一个位置为(x,0,0)的点 par(x,y) 绘制一个位置为(x,y,0)的点 par(x,y,z) 绘制一个位置为(x,y,z)的点 par()等价于par(0,0,0) 点渲染默认是关闭的，请使用dot()打开。并且您随时可以调用noDot()关闭它 点的半径由dotRadius(radius)控制 点的颜色由dot(r,g,b)控制 如果您不想让点被变换压扁或者缩小，使用dotGlobal()。默认情况下点是在dotLocal()模式下渲染的。 par.lua version3() dot() dotRadius(3) move(200,100) par() dot(1,0,0) dotRadius(7) move(100,0) par() cube cube(size)绘制一个边长为size的正方体 cube(sizex,sizey,sizez)绘制一个长宽高sizex,sizey,sizez的长方体 cube()等价于cube(100) cube() 长方体的法线默认是朝外的，如果输入负数长度、或者使用了带负号的scale()函数会导致法线向内 cube.lua version3() dim3() move(200,100,0) rotateY(d2r(30)) rotateX(d2r(30)) cube(40,25,10) tet tet(radius)以radius为球面半径绘制一个内接正四面体 tet()等价于tet(50) tet(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z,p4x,p4y,p4z)以p1,p2,p3,p4为顶点绘制一个四面体 第三项绘制的四面体的法线根据绘制顺序而定，具体为：p1,p2,p3;p2,p1,p4;p3,p2,p4;p1,p3,p4.的顺序依次绘制四个三角面。关于三角面的法线方向请参考tri 函数名为tetrahedron的缩写 tet.lua version3() dim3() move(200,100,0) tet(0,0,0, 100,0,0, 0,100,0, 30,20,-50 ) cone cone(size)以size为底边半径，2*size为高，绘制一个圆锥 cone()等价于cone(50) cone(radius,height)以radius为半径，height为高绘制一个圆锥 cone(radius,height,div)以radius为半径，height为高绘制一个分段为div的圆锥 圆锥默认分段为64 当分段大于16时会隐藏锥面描边和底边顶点 负数的输入值或带负号的scale()有可能导致法线向内 cone.lua version3() dim3() move(100,100,0) beginGroup() rotateY(d2r(60)) cone(25) endGroup() move(100,0,0) beginGroup() rotateY(d2r(60)) noStroke() cone(25) endGroup() move(100,0,0) beginGroup() rotateY(d2r(60)) stroke(1,0,0) dot(1,1,0) dotRadius(3) cone(30,100,12) endGroup() ball ball(radius)以半径radius绘制一个三维球体 ball()等价于ball(50) ball(radius,level)以半径radiu和level细分等级绘制一个球体 默认level为4 level必须大于等于0 level等于0时为正八面体 level大于2时将隐藏描边和顶点 负数的输入值或带负号的scale()有可能导致法线向内 ball.lua version3() dim3() move(200,100,0) beginGroup() rotateY(d2r(60)) ball(25) endGroup() move(100,0,0) beginGroup() rotateY(d2r(60)) stroke(0,0.25,0.5) dot(0,0.5,1) dotRadius(3) ball(30,2) endGroup() tube tube(size)绘制一个底面半径size、高2*size的圆柱体 tube()等价于tube(50) tube(radius,height)绘制一个半径为radius、高为height的圆柱体 tube(radius1,radius2,height)绘制一个靠近绘笔坐标原点底面半径为radius1、远离一侧底面半径为radius2、高为height的圆柱体 tube(radius1,radius2,height,div)在第4个函数基础上多了分段的控制。 tube(radius1,radius2,height,div,needMesh)在第5个函数基础上多了“是否要渲染两个圆面”的boolean tube(radius1,radius2,height,div,needMesh1,needMesh2)在第5个函数基础上，多了“是否要渲染近侧底面”的needMesh1和“是否要渲染远侧底面”的needMesh2，两者皆为boolean。 div默认值为64 needMesh默认值为true 当分段大于16时会隐藏柱面描边和两底边顶点 负数的输入值或带负号的scale()有可能导致法线向内 tube.lua version3() dim3() move(200,100,0) beginGroup() rotateY(d2r(60)) tube(25) endGroup() move(100,0,0) beginGroup() rotateY(d2r(60)) stroke(1,0.25,0.5) dot(0,0,1) dotRadius(3) tube(30,25,50,8) endGroup() image image(id,width,height)以长度为width,高为height绘制一张图片到场景上 id是材质编号，PARAM0~PARAM9是您插件面板上的图层控件获得的材质，INPUT是输入插件的输入图像，OUTPUT是输出图像。 当您指定id为OUTPUT时，因为OUTPUT是您当前正绘制的充当绘板的材质，所以会发生一次绘板的截屏行为。因此会比其它参数稍慢一些。 这个函数与in2out(id)的区别是，image(id,width,height)会根据绘笔坐标生成一个与场景深度信息互动的图片。这意味着：图片默认绘制出来是上下颠倒的，因为Ae默认的坐标系y轴向下，您需要在前面加入一行rotateX(PI)来转正（我们不推荐使用scale(1,-1),这将会导致其它后续绘制图形出现法线错误）；而in2out(id)则是忽略深度信息，直接把像素写到当前绘板中（并且没有上下颠倒问题）。 下面这个例子将演示一个与输入图片穿插交互的立方体 render_image.lua version3() dim3() move(width/2,height/2) twirl(d2r(45),-1,1,0) beginGroup() rotateX(d2r(180)) image(INPUT,width,height) endGroup() twirl(d2r(60),1,1,1) cube() imageAlign v3.3.0新函数。 imageAlign(rule)来更改image函数的图片朝向。rule遵循以下规则： rule是长度为4的字符串 第1个字符为+或- 第2个字符为x,y,z中任意一个 第3个字符为+或- 第4个字符为x,y,z中任意一个 rule代表图片的UV坐标（左下角为原点）与绘笔坐标的什么轴向对齐，默认rule为\"+x+y\"，代表u轴与正x对齐，v轴与正y对齐。 imageAlign.lua version3() dim3() move(100,100,0) coord() image(PARAM0,128,128) move(150,0,0) coord() imageAlign(\"+x-y\") image(PARAM0,128,128) move(150,0,0) coord() imageAlign(\"+z-y\") image(PARAM0,128,128) imageAnchor v3.5.0新函数。 imageAnchor(u,v) 用来指定图片锚点的位置。 imageAnchor(a)是imageAnchor(a,a)的简写版本。 text v3.5.0新函数 text(str)用来在屏幕上渲染文字。 text.lua version3() move(width/2,height/2) textAlign(\"+x-y\") text(\"Hello PixelsWorld!\") 另外可以使用下面的函数来改变文字样式 文字填充颜色：fill(r,g,b) 文字描边颜色：stroke(r,g,b) 关闭填充：noFill() 关闭描边：noStroke() 描边粗细：strokeWidth(width) 字体：textFont(fontFileName) 字体尺寸：textSize(size) 字体间距：textInterval(dx,dy) 字宽等比缩放：textAdvanceScale(rx,ry) textSize v3.5.0新函数 textSize(size,resolution)用来设置接下来绘制文字的大小，size控制文字大小，resolution控制文字分辨率。 textSize(size)等价于textSize(size,size) textSize.lua version3() textAlign(\"+x-y\") textAnchor(0,1) for i=1,13 do local sz = i + 8 textSize(sz) text(\"~MiLai visual performance group~\") move(0,sz + 4) end textFont v3.5.0新函数 textFont(fontFileName)用来设置接下来要绘制的文字的字体。fontFileName为C:\\Windows\\Fonts文件夹中字体文件的文件名（右键、属性，可查看字体文件的文件名，例如textFont(\"arial.ttf\")）。 你也可以输入字体文件的完整路径。这意味着你可以读取任意位置的字体。（例如textFont([[D:\\MyFolder\\arial.ttf]])） textFont.lua version3() textAlign(\"+x-y\") textAnchor(0,1) textSize(20) font_list={ {\"arial.ttf\",\"The quick brown fox jumps over the lazy dog. \"}, {\"MATURASC.TTF\",\"The quick brown fox jumps over the lazy dog. \"}, {\"KUNSTLER.TTF\",\"The quick brown fox jumps over the lazy dog. \"}, {\"msmincho.ttc\",\"色は匂へど　散りぬるを\"}, {\"UDDigiKyokashoN-R.ttc\",\"我が世誰ぞ　常ならむ\"}, {\"STXINGKA.TTF\",\"人生得意须尽欢 莫使金樽空对月\"}, {\"msjh.ttc\",\"山氣日夕佳 飛鳥相與還\"}, {\"simsun.ttc\",\"吥葽 莣記莪、伱知道 莪 拿起伱 就 倣吥丅。\"}, {\"STZHONGS.TTF\",\"○●対沵倾注ㄋ珴所侑旳温柔︶ㄣ\"}, } for i=1,#font_list do textFont(font_list[i][1]) text(font_list[i][2]) move(0,28) end textAlign v3.5.0新函数 textAlign(rule)可以用来设置字体的渲染朝向，rule同imageAlign(rule)中的rule。 详见imageAlign>>> textAnchor v3.5.0新函数 textAnchor(x,y)可以用来设置字体锚点位置。 详见imageAnchor>>> textAlignOuter v3.5.0新函数 textAlignOuter(flag)用来设置是否使用外轮廓来对齐文字。flag为布尔值。 textInterval v3.5.0新函数 textInterval(x,y)用来设置文字贴图间距。默认x:0, y:0 textAdvanceScale v3.5.0新函数 textAdvanceScale(rx,ry)用来控制文字贴图的前进倍率。默认rx:1, ry:1 coord coord()将把当前绘笔坐标可视化出来。 coord.lua version3() move(100,100) coord() move(150,0) coord() rotate(d2r(30)) move(50,0) scale(2,1) coord() grid grid()将把当前绘笔坐标所在的xy平面以100x100网眼大小的的网格可视化出来。 grid.lua version3() move(width/2,height/2) rotate(d2r(30)) grid() setPoly setPoly(obj)可以提前解析要绘制的物体信息，您在设置后可以调用poly()来快速绘制刚刚设置的物体。 当您在场景中绘制多次同一个obj时，使用这个函数提前设置obj会很有效。 关于obj的构造请前往Poly章节 background background(brightness),background(r,g,b),background(r,g,b,a)将当前绘板涂成对应颜色。 注意：如果您之前绘制过形状，这些形状会被覆盖。 background.lua version3() background(1,1,0) in2out in2out(id)会把第id个层参数设为背景。 in2out()等价于in2out(INPUT)，它负责把输入层当做背景。 id 范围： PARAM0~PARAM9 或者 INPUT。 dim2 dim2()将使用2D模式绘图，这一项默认是开启的，一般您无需调用。 本质PixelsWorld中的2D模式是没有深度信息的正交3D模式。 dim3 dim3()将使用3D模式绘图。我们推荐声明在紧随version3()之后的地方。 注意：如果在跟合成尺寸不同的图层上渲染3D形状时请使用viewSpace更改摄像机的远平面尺寸，否则会得到意外的位置结果。 perspective perspective()将使用透视视图渲染，物体将符合近大远小规则，您可以使用viewSpace来调整摄像机信息、使用lookAt来调整摄像机位置。 若您调用过dim3()，透视模式默认开启。 noPerspective noPerspective()将使用正交视图渲染，物体互相平行的边缘在渲染视图中也将平行。 noPerspective.lua version3() dim3() n = 20 move(100,100,0) beginGroup() rotateX(d2r(85)) for i=1,n do move(0,300,0) fill(i/n,1-i/n,1) cube(50) end endGroup() move(300,0,0) noPerspective() beginGroup() rotateX(d2r(85)) for i=1,n do move(0,300,0) fill(i/n,1-i/n,1) cube(50) end endGroup() fill fill()将开启填充。默认开启。 fill(brightness),fill(r,g,b),fill(r,g,b,a)将开启填充并设置填充色。 注意：在3D模式中，如果您将填充的透明值设为小于1的数的时候，请使用由远到近的顺序渲染物体，否则前面的透明物体会完全遮挡住后面的物体。（这是OpenGL绘图的一个特性） noFill noFill()将关闭填充。 fill.lua version3() move(200,100,0) fill(1,0,0) rect(50) move(100,0,0) fill(1,1,0) rect(50) move(100,0,0) noFill() rect(50) stroke stroke()将开启描边。默认开启。 stroke(brightness),stroke(r,g,b),stroke(r,g,b,a)将开启描边并设置描边色。 noStroke noStroke()将关闭描边。 stroke.lua version3() fill(0) move(200,100,0) stroke(1,0,0) rect(50) move(100,0,0) stroke(1,1,0) rect(50) move(100,0,0) noStroke() rect(50) dot dot()开启顶点渲染。默认关闭。 dot(brightness),dot(r,g,b),dot(r,g,b,a)将开启顶点渲染并设置顶点渲染颜色。 noDot noDot()将关闭顶点渲染。 dot.lua version3() fill(1) move(200,100,0) stroke(1,0,0) rect(50) move(100,0,0) dot(1,1,0) rect(50) move(100,0,0) noDot() rect(50) wireframe wireframe()将开启线框模式。 noWireframe noWireframe()将关闭线框模式。 wireframe.lua version3() n=8 dim3() move(width/2, height/2) for i=1,n do if i>n//2 then wireframe() else noWireframe() end beginGroup() rotateZ(d2r(i*360/n)) move(100,0,0) fill(i/n,1-i/n,1) ball(30,1) endGroup() end blendAlpha blendAlpha()将开启混色。 noBlendAlpha noBlendAlpha将关闭混色。 blendAlpha.lua version3() castTex(OUTPUT,INPUT) move(200,100,0) fill(1,0,0,0.2) rect(80) move(100,0,0) noBlendAlpha() fill(1,0,0,0.2) rect(80) back back()填充含透明色的时候，将显示物体背面。默认关闭。 noBack noBack()关闭背面渲染模式。 back.lua version3() dim3() fill(1,0,0,0.2) rotateX(d2r(30)) rotateY(d2r(-15)) move(200,180,0) cube(80) move(150,0,0) back() cube(80) pure pure()将使用纯色模式渲染场景。默认开启。 anime,phong,pure是三种不能同时应用的材质，您在打开其中一个的时候另外两种会被关掉。 phong phong(ambient,diffuse,specular,specularPower)将切换到phong模式，并把环境光反射强度设为ambient、亮面漫反射强度设为diffuse、高光强度设为specular。specularPower负责设置高光衰减量级，该项越大，高光衰减越快。 phong()将切换到phong材质模式。不改动设置。 默认场景是没有任何光源的，所以您需要使用getLight()，或ambientLight()、parallelLight()、pointLight来获取光源。 如果在有光源的前提下渲染出来的物体仍然是纯黑色，调用normal请检查法线是否正确。 每一项参数初始值为：ambient:1,diffuse:1,specular:1,specularPower:1 anime,phong,pure是三种不能同时应用的材质，您在打开其中一个的时候另外两种会被关掉。 请在使用前执行dim3() phong.lua version3() dim3() move(width/2,height/2,0) grid() coord() n=10 beginGroup() move(0,0,-100) pointLight() endGroup() for i=1,n do beginGroup() rotateZ(d2r(i*360/n)) move(100,0,0) fill(i/n,1-i/n,1) if(i anime anime(ambient,diffuse,specular,specularPower,diffuseThreshold,specularThreshold) anime()将切换到动漫材质模式。不改动设置。 anime材质是在phong的基础上做的。因此前四项参数：ambient,diffuse,specular,specularPower与phong相同，剩余两项diffuseThreshold负责设置漫反射的阈值，当漫反射亮度超过阈值时则设为亮面，低于阈值时则设置为暗面。同理，specularThreshold负责高光的阈值。 anime材质对抗锯齿进行了优化，如果您开启了抗锯齿（默认开启），那么光影过渡边缘会被抗锯齿处理。关闭插件面板的抗锯齿设置可以关闭光影边缘的抗锯齿处理。 每一项参数初始值为：ambient:1,diffuse:1,specular:1,specularPower:1,diffuseThreshold:0.5,specularThreshold:0.8 anime,phong,pure是三种不能同时应用的材质，您在打开其中一个的时候另外两种会被关掉。 请在使用前执行dim3() anime.lua version3() dim3() move(width/2,height/2,0) grid() coord() n=10 beginGroup() move(0,0,-100) pointLight() endGroup() for i=1,n do beginGroup() rotateZ(d2r(i*360/n)) move(100,0,0) fill(i/n,1-i/n,1) if(i rgba rgba()RGBA直接输出模式，默认开启。 rgba,depth,normal是三个不能同时成立的模式，您在打开其中一项的时候另外两项会被关掉。 这个模式可以使用材质。 rgba.lua version3() dim3() background(1) move(width/2,height/2,0) n=10 beginGroup() move(0,0,-100) pointLight() endGroup() rgba() -- depth() -- normal() noStroke() for x=1,n do for y=1,n do for z=1,n do beginGroup() fill(x/n,y/n,z/n) move(map(x,1,n,-n/2,n/2)*50,map(y,1,n,-n/2,n/2)*50,map(z,1,n,-n/2,n/2)*200) ball(10,2) endGroup() end end end depth depth(blackDistance, whiteDistance)是把深度当做亮度信息输出的模式。例如您想输出一张深度图，可以指定blackDistance和whiteDistance来设置距离摄像机多远的时候输出黑色或白色。对于之间的距离，像素世界会做线性插值成灰色。当您把blackDistance和whiteDistance设为同一数值时，像素世界会把您设置的数值当做阈值来输出纯黑色或纯白色。 rgba,depth,normal是三个不能同时成立的模式，您在打开其中一项的时候另外两项会被关掉。 这个模式会无视材质。 请在使用前执行dim3() depth.lua version3() dim3() background(1) move(width/2,height/2,0) n=10 beginGroup() move(0,0,-100) pointLight() endGroup() -- rgba() depth() -- normal() noStroke() for x=1,n do for y=1,n do for z=1,n do beginGroup() fill(x/n,y/n,z/n) move(map(x,1,n,-n/2,n/2)*50,map(y,1,n,-n/2,n/2)*50,map(z,1,n,-n/2,n/2)*200) ball(10,2) endGroup() end end end normal normal(faceToCamera, normalize)切换到normal模式，修改faceToCamera和normalize变量 normal(faceToCamera)切换到normal模式，只修改faceToCamera变量 normal()只负责切换到normal模式 faceToCamera是一个布尔值，用来控制normal是否以摄像机视角为基准生成。 normalize是一个布尔值，用来指定是否输出标准化(长度做成1)后的normal 初始值：faceToCamera:true, normalize:true。 rgba,depth,normal是三个不能同时成立的模式，您在打开其中一项的时候另外两项会被关掉。 这个模式会无视材质。 请在使用前执行dim3() normal.lua version3() dim3() background(.5,.5,1) move(width/2,height/2,0) n=10 beginGroup() move(0,0,-100) pointLight() endGroup() -- rgba() -- depth() normal() noStroke() for x=1,n do for y=1,n do for z=1,n do beginGroup() fill(x/n,y/n,z/n) move(map(x,1,n,-n/2,n/2)*50,map(y,1,n,-n/2,n/2)*50,map(z,1,n,-n/2,n/2)*200) ball(10,2) endGroup() end end end setDepth setDepth(id,blackDistance,whiteDistance)可以读取id上的材质的红色通道，并把通道值为0的地方设为blackDistance，通道值为1的地方设为whiteDistance，再把材质应用到深度测试材质上。 您可以把从3D软件中渲染的深度序列通过这个函数导入像素世界，这样像素世界能和其它图层做深度交互。 请在使用前执行dim3() 有效的id: INPUT,PARAM0~PARAM9 ambientLight ambientLight(r,b,g,intensity) ambientLight()等价于ambientLight(1,1,1,1) ambientLight(brightness)等价于ambientLight(brightness,brightness,brightness,1) ambientLight(brightness,intensity)等价于ambientLight(brightness,brightness,brightness,intensity) ambientLight(r,g,b)等价于ambientLight(r,b,g,1) 生成一个环境光，对场景内所有物体有效。 这个光可以无视物体法线方向，即使法线方向反向仍能照亮物体。 al.lua version3() dim3() move(width/2,height/2,0) n=4 phong() ambientLight(1,0.5,0.2,10) noStroke() for r=1,n do local ra = r*50 local cn = math.floor(ra*TPI/40) for i=1,cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn,0.5,0.5)) move(ra,0,0) ball(15,3) endGroup() end end pointLight pointLight(r,g,b,intensity,radius,smoothWidth) pointLight()等价于pointLight(1,1,1,1,1000,1000) pointLight(brightness,intensity)等价于pointLight(brightness,brightness,brightness,intensity,1000,1000) pointLight(r,g,b)等价于pointLight(r,g,b,1,1000,1000) pointLight(r,g,b,intensity)等价于pointLight(r,g,b,intensity,1000,1000) pointLight(r,g,b,intensity,radiusAndSmoothWidth)等价于pointLight(r,g,b,intensity,radiusAndSmoothWidth,radiusAndSmoothWidth) 在当前绘笔坐标原点处生成一个点光源。 这个光受物体法线方向影响，法线方向的物体不会产生漫反射和高光，但仍能接受点光源产生的环境光。 radius为点光源的光照半径，radius到radius+smoothWidth之间光照强度会衰减。 pl.lua version3() dim3() move(width/2,height/2,0) n=4 phong() ambientLight(0.2,0.5,1,2) beginGroup() move(0,0,-100) pointLight(1,0.5,0.2,2,500,100) endGroup() noStroke() for r=1,n do local ra = r*50 local cn = math.floor(ra*TPI/40) for i=1,cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn,0.5,0.5)) move(ra,0,0) ball(15,3) endGroup() end end parallelLight parallelLight(r,g,b,intensity,tx,ty,tz) 在全局范围内生成一个方向为(tx,ty,tz)的平行光。 pll.lua version3() dim3() move(width/2,height/2,0) n=4 phong() ambientLight(0.2,0.5,1,2) parallelLight(1,0.5,0.2,2,1,-1,1) noStroke() for r=1,n do local ra = r*50 local cn = math.floor(ra*TPI/40) for i=1,cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn,0.5,0.5)) move(ra,0,0) ball(15,3) endGroup() end end light_effects.lua version3() dim3() background(0.1,0.2,0.3) move(width/2,height/2,0) math.randomseed(1) n=5 ambientLight(0.2,0.5,1,1) parallelLight(1,0.5,0.2,0.1,1,-1,1) beginGroup() move(200,0,-100) pointLight(1,0.5,0.2,1,200,100) endGroup() beginGroup() move(-30,200,-100) pointLight(0,1,1,1,200,100) endGroup() beginGroup() move(-30,-200,-100) pointLight(0,1,1,1,200,100) endGroup() noStroke() for r=1,n do local ra = r*50 local cn = math.floor(ra*TPI/40) for i=1,cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn,r/n,0.6)) move(ra,0,0) if math.random() clearLight clearLight()清除场景中的所有灯光。 getLight getLight(matchName) getLight()等价于getLight(\"*\") 获取当前合成符合matchName名字的灯光。 matchName规则：当字符串末尾不含\"*\"时，会在Ae当前合成的图层中搜寻名字为matchName的灯光并加入场景中；当末尾含有\"*\"时，则会把所有开头为matchName的灯光全部加入场景中。 目前支持的Ae灯光类型：ambient,point,parallel aeCamera aeCamera()把Ae当前场景摄像机当做像素世界的场景摄像机。 lookAt lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ,upVecX,upVecY,upVecZ)用来设置摄像机位置和朝向 lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ)等价于lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ,0,-1,0) eyePos是您眼睛的位置，objPos是您想看的目标物体的位置，upVec是您头顶的指向。 注意Ae的Y轴默认是朝下的，一般您需要让upVec为(0,-1,0)。 eyePos和objPos不能太近（推荐两者距离不低于1e-7）。 upVec不能和您的视线平行。 upVec长度不能太小。 viewSpace viewSpace(width,height,distanceToPlane,farLevel) viewSpace(width,height,distanceToPlane)等价于viewSpace(width,height,distanceToPlane,4) width和height为摄像机远平面的尺寸 摄像机到摄像机远平面的垂直距离为distanceToPlane farLevel * distanceToPlane为最远平面的距离，超过这个距离的物体将不被渲染。通常farLevel设为4足够，若您的场景十分大，可以把这个数值设高一些，这个数值只会影响远处的物体是否被渲染。若您把这个数值设定的过高可能会影响近处物体的深度测试精度。 strokeWidth strokeWidth(width)来设置描边粗细 默认值：2 strokeWidth.lua version3() background(1) move(100,100) for i=1,30 do move(10,0) strokeWidth(i/8) line(0,0,0,100) end strokeDivision strokeDivision(level)来设置描边细分等级 默认值：3 strokeDivision.lua version3() background(1) strokeWidth(30) move(100,100) for i=0,3 do strokeDivision(i) line(0,0,0,100) move(75,0) end strokeGlobal strokeGlobal()以全局模式绘制线，线的粗细不受scale影响。 默认值是局部模式 strokeGlobal.lua version3() strokeWidth(4) strokeGlobal() move(50,100) beginGroup() for i=1,13 do beginGroup() scale(1/i) rect(50) endGroup() move(50/i+20,0) end endGroup() strokeLocal strokeLocal()以局部模式绘制线，线的粗细将受scale影响。 默认值是局部模式 strokeLocal.lua version3() strokeWidth(4) strokeLocal() move(50,100) beginGroup() for i=1,13 do beginGroup() scale(1/i) rect(50) endGroup() move(50/i+20,0) end endGroup() dotRadius dotRadius(radius)来设置点粗细 默认值：2 dotRadius.lua version3() background(1) fill(0,1,1) dot(1,0,0) move(100,100) for i=1,7 do dotRadius(i/2) rect(40) move(50,0) end dotDivision dotDivision(level)来设置点的细分等级。（非负整数，最大为7） 默认值：3 dotDivision.lua version3() background(1) fill(0,1,1) dot(1,0,0) dotRadius(10) move(100,100) for i=0,4 do dotDivision(i) rect(40) move(70,0) end dotGlobal dotGlobal()以全局模式绘制点，点的半径不受scale影响。 默认值是局部模式 dotGlobal.lua version3() dot(1,0,0) dotGlobal() move(50,100) beginGroup() for i=1,13 do beginGroup() scale(1/i) rect(50) endGroup() move(50/i+20,0) end endGroup() dotLocal dotLocal()以局部模式绘制点，点的半径将受scale影响。 默认值是局部模式 dotLocal.lua version3() dot(1,0,0) dotLocal() move(50,100) beginGroup() for i=1,13 do beginGroup() scale(1/i) rect(50) endGroup() move(50/i+20,0) end endGroup() smooth smooth()以抗锯齿模式绘制。 默认开启 在插件面板上可以修改抗锯齿强度 noSmooth noSmooth()以非抗锯齿模式绘制。 这个函数的优先级大于插件面板上的抗锯齿设定。 r2d r2d(radians)弧度转角度，返回角度 d2r d2r(degrees)角度转弧度，返回弧度 map map(value,in1,in2,out1,out2)将数值value从范围in1~in2映射至out1~out2。 当in1等于in2时，在value时该函数返回out1，否则返回out2。 clamp clamp(value,lower,upper)将数值value夹在范围[lower,upper]中，返回夹击后的值。 v3.2.0新函数 即，当value在lower和upper之间，返回value；若value小于lower，返回lower；若value大于upper，返回upper。 step step(value,threshold)在当value时返回0，否则返回1。 v3.2.0新函数 smoothStep smoothStep(value,lower,upper)在当value时返回0，当value>higher时返回1，否则，在lower和higher之间按照value进行平滑插值。 插值公式： t:=x−lowerupper−lower\r t := \\frac{x - lower}{upper - lower}\r t:=​upper−lower​​x−lower​​ Result:=t2(3−2t)\r Result:=t^2(3 - 2t)\r Result:=t​2​​(3−2t) v3.2.0新函数 bezier bezier(t,p0,p1,...,pn)对p0,p1,...,pn进行n次贝塞尔插值，返回插值结果。 插值公式： Result:=∑k=0nCnk⋅(1−t)n−k⋅tk⋅pk\r Result := \\sum_{k=0}^n{C_n^k\\cdot (1-t)^{n-k}\\cdot t^k\\cdot p_k}\r Result:=∑​k=0​n​​C​n​k​​⋅(1−t)​n−k​​⋅t​k​​⋅p​k​​ Cnk:=n!(n−k)!k!\r C_n^k:=\\frac{n!}{(n-k)!k!}\r C​n​k​​:=​(n−k)!k!​​n!​​ v3.2.0新函数 n的最大值为66 颜色转换 xxx2xxx允许下图中的转换 例如，如果想把hsl格式的颜色数据转换到rgb则需要使用函数：hsl2rgb，输入值和返回值各为3个。 所有颜色数据都在0~1的范围进行转换。 v3.2.0新函数 color_convert.lua version3() dim3() strokeWidth(0.5) stroke(0) move(width/2,height/2,0) for x = -5,5 do for y =-5,5 do for z=-5,5 do beginGroup() move(x*15,y*15,z*15) fill(cmy2rgb(x/10+.5,y/10+.5,z/10+.5)) cube(12) endGroup() end end end utf8ToLocal utf8ToLocal(str)把unicode字符串转为本地字符串，返回本地编码的字符串 如果您在使用Lua的io模块，发现某个路径含有utf8字符的文件读不了的话，请用这个函数转换路径编码。 localToUtf8 localToUtf8(str)把本地字符串转为unicode字符串，返回unicode编码字符串 getGLInfo getGLInfo()获取当前显卡的信息。返回string getDrawRecord getDrawRecord(needStringFormat)将输出当前场景的绘制记录信息。needStringFormat是一个布尔值，true时输出字符串，false输出一个Lua表。 getDrawRecord()等价于getDrawRecord(true) printDrawRecord.lua version3() dot(1,0,0) move(width/2,height/2) dim3() cube() println(getDrawRecord()) getStatus getStatus(needStringFormat)可以输出当前绘笔信息，needStringFormat是一个布尔值，true时输出字符串，false输出一个Lua表。 getStatus()等价于getStatus(true) getStatus.lua version3() move(width/2,height/2) dim3() cube() println(getStatus()) getAudio 确保您拥有v3.4.0+版本的PixelsWorld getAudio([startTime,duration[,id[,sampleRate,startFrequency,endFrequency[,resolution]]]])将索取音频信息，返回6个表：两个波形采样表（左右声道）、两个FFT结果表（左右声道）和两个频谱表（左右声道）。 省略项将被填充为插件面板上的音频设定数据 左声道波形 (-1~1) 右声道波形 (-1~1) 左声道FFT (0~正无穷) 右声道FFT (0~正无穷) 左声道频谱 (0~正无穷) 右声道频谱 (0~正无穷) waveInfo.lua version3() castTex(OUTPUT,INPUT) local wl,wr,ftl,ftr,specl,specr = getAudio() local nm = math.floor(height/8); for i=1,nm do local wid =math.max(math.floor(i/nm*#wl),1) local fid = math.max(math.floor(i/nm*#specl),1) print(string.format(\"%8.5f\",wl[wid]),wl[wid]*4,0,-wl[wid]*4) print(\" \",1,0,0,0) print(string.format(\"%8.5f\",wr[wid]),wr[wid]*4,0,-wr[wid]*4) print(\" \",0.5,0.5,0.5) print(string.format(\"%8.5f\",specl[fid]),specl[fid],0,0) print(\" \",1,0,0,0) print(string.format(\"%8.5f\",specr[fid]),0,0,specr[fid]) println(\"\"); end saveString saveString(utf8_path,string)把字符串以文本的格式存到本地。 loadString loadString(utf8_path)读取本地文本文件，返回字符串。 getColor getColor(id,x,y)返回id材质处的(x,y)坐标处的像素值，返回r,g,b,a四个双精度浮点数。 getColor(x,y)等价于getColor(INPUT,x,y) 在绘制一切场景前使用getColor时(即在version3()紧接着的后面)，这个函数的效率是最高的，如果您在绘制场景时使用getColor时这个函数效率十分低下，因为Lua是工作在CPU上的，绘制场景时，所有的材质都会送入您的显卡，在显卡和CPU之间通信的时间成本会很高。 有效id为INPUT,OUTPUT,PARAM0~PARAM9 setColor setColor(x,y,r,g,b,a)会设置OUTPUT材质的(x,y)坐标处的像素值。 在绘制一切场景前使用setColor时(即在version3()紧接着的后面)，这个函数的效率是最高的 getSize getSize(id)返回id材质的尺寸（两个double，宽度和高度） 当您改变场景降采样（例如二分之一，四分之一）后，返回的尺寸会有0~4像素的抖动，这是由Ae的降采样机制产生的特性。但这个抖动不会随时间变化。在降采样关闭时，这个函数保证返回正确的图层尺寸。 shadertoy shadertoy(code)执行来自shadertoy的代码。 不是所有的shadertoy代码都被支持 glsl glsl(code)执行Fragment阶段代码 cmd cmd(code)执行cmd指令 如果命令成功运行完毕，第一个返回值就是 true，否则是 nil。在第一个返回值之后，函数返回一个字符串加一个数字。如下： \"exit\": 命令正常结束； 接下来的数字是命令的退出状态码。 \"signal\": 命令被信号打断； 接下来的数字是打断该命令的信号。 lua lua(code)执行Lua代码 runFile runFile(utf8_path)把本地文件当做txt文件读取，并当做Lua代码执行。 默认支持utf8字符，您无需调用utf8ToLocal来转换。 txt txt(utf8_path)把本地文件当做txt文件读取，并返回字符串。 默认支持utf8字符，您无需调用utf8ToLocal来转换。 "},"contents/Lua/Texture.html":{"url":"contents/Lua/Texture.html","title":"贴图系统","keywords":"","body":"贴图系统 请确保您拥有v3.3.0+的PixelsWorld 通过这一章，您能快速了解并学习使用PixelsWorld的贴图系统。 newTex delTex getSize swapTex drawTo castTex blendTex copyTex fetchTex savePNG,loadPNG,saveEXR,loadEXR,saveRAW,loadRAW rotateTex,flipTex,resizeTex,trimTex 贴图id 在PixelsWorld中，贴图是用一个整数（贴图id）来表示的。PixelsWorld提供的基础贴图id如下： 贴图id Lua模式全局常量 GLSL模式全局常量 Shadertoy模式全局常量 描述 -3 OUTPUT 不可访问 不可访问 输出贴图 -2 TEMP PW_TEMP_LAYER _PixelsWorld_PW_TEMP_LAYER 缓冲贴图 -1 INPUT AE_INPUT_LAYER _PixelsWorld_AE_INPUT_LAYER 输入贴图 0 PARAM0 0 0 参数层0 1 PARAM1 1 1 参数层1 ... PARAM... ... ... ... 9 PARAM9 9 9 参数层9 您还可以自己创建贴图id，方法后述 基本流程 通常Ae送给PixelsWorld一张图片，PixelsWorld先把图片放在INPUT中，进行计算后，把结果放在OUTPUT贴图中。当一切指令结束后会把OUTPUT贴图送给Ae当作结果。 TEMP的作用 因为OpenGL不支持同时读取和写入同一个贴图，所以PixelsWorld提供了TEMP用来存储上一次glsl,shadertoy,等函数绘制的结果。你可以在着色器中使用getColor(PW_TEMP_LAYER,uv);来采样TEMP的颜色。 创建贴图 使用newTex(width,height)来创建贴图，将返回贴图id（一个随机整数值）。 删除贴图 使用delTex(id)来删除指定贴图。 通常您无需手动删除，PixelsWorld会在每一帧结束时删除所有贴图。但在不需要一个贴图的时候提前释放其占用的显存仍然是个很好的习惯。 获取尺寸 使用getSize(id)来获取贴图尺寸。 getSize.lua version3() mytex = newTex(512,256) w,h = getSize(mytex) println(\"Width of mytex is: \" .. w) println(\"Height of mytex is: \" .. h) 交换贴图 使用swapTex(id1,id2)来交换id1和id2代表的贴图。 swapTex.lua version3() tex1 = newTex(128,128) tex2 = newTex(256,256) w,h = getSize(tex1) println(\"tex1 size: \" .. w .. \", \".. h) swapTex(tex1,tex2) w,h = getSize(tex1) println(\"tex1 size after swapped: \" .. w .. \", \".. h) 设定绘制贴图 使用drawTo(id)来更改绘制贴图。绘制贴图默认为OUTPUT，注意PixelsWorld最后只会把OUTPUT当作结果送给Ae，下面三种方法可以输送其它贴图的结果至OUTPUT： drawTo(OUTPUT)+image castTex swapTex 投射贴图 使用castTex(toTexId,fromTexId)来把像素从fromTexId投射到toTexId，例如您可以把参数层0PARAM0投射到输出贴图OUTPUT上： castTex.lua version3() castTex(OUTPUT,PARAM0) 您还可以指定投射贴图的范围（以贴图左上角为原点）： castTex(toTexId,fromTexId,to1x,to1y,to2x,to2y) castTex(toTexId,fromTexId,to1x,to1y,to2x,to2y,from1x,from1y,from2x,from2y) 省略范围时默认使用整个贴图 混合贴图 使用blendTex(toTexId,fromTexId,blendRule)来使用混合规则blendRule把贴图fromTex贴到贴图toTex上。 blendRule可以为NORMAL,ADD,SUBTRACT,MULTIPLY,DIVIDE,MAX,MIN中的任意一个。 blendRule可以为字符串，规则如下： A代表toTexId输入像素 B代表fromTexId输入像素 C代表toTexId输出像素 例如：您可以使用下面的代码来把输入贴图和参数层0的图片用加法混合。 blendRule.lua version3() castTex(OUTPUT,INPUT) -- Cast INPUT texture to OUTPUT firstly. blendTex(OUTPUT,PARAM0,\"C=A+B\") -- Blend PARAM0 to OUTPUT. 实际上这里的字符串会被处理成GLSL代码，\"C=A+B\"在内部将变成下面的代码： blendRuleGLSL.frag #version 330 core out vec4 outColor; in vec2 uv; in vec2 uv2; uniform sampler2D inLayerA; uniform sampler2D inLayerB; void main(){ vec4 A = texture(inLayerA,uv); vec4 B = texture(inLayerB,uv2); vec4 C = A; C=A+B // Your blend rule is combined here. ; outColor = C; } 跟castTex一样，blendTex也支持贴图范围指定的混色： blendTex(toTexId,fromTexId,blendRule,to1x,to1y,to2x,to2y) blendTex(toTexId,fromTexId,blendRule,to1x,to1y,to2x,to2y,from1x,from1y,from2x,from2y) 拷贝贴图 使用copyTex(refTexId)来拷贝贴图，返回被拷贝的新贴图。 获取任意时间图层像素 使用fetchTex(layerId, time)来获取某时间下指定图层的贴图，返回抓取来的贴图id。 layerId: 只可以输入PARAM0~PARAM9。 time: 图层时间（浮点数，单位为秒） 注意：使用这个函数可能会造成Ae的缓存错误，请时常清理缓存。 v3.4.3+新增函数。 读取和保存贴图 使用savePNG(utf8Path,texId),loadPNG(utf8Path)来保存、读取PNG图片。 使用saveEXR(utf8Path,texId),loadEXR(utf8Path)来保存、读取EXR图片。 使用saveRAW(utf8Path,texId),loadRAW(utf8Path)来保存、读取MiLai原生的未经压缩的内存原图。 以下是受PixelsWorld支持的图片规格细节： 格式 使用的库 支持的压缩方式 图片颜色规格 PNG cute_headers DEFLATE compliant decompressor zlib(RFC 1950) RGBA,clamped 8bit unsigned integer per channel. EXR tinyexr NONE,RLE,ZIP,ZIPS,PIZ,ZFP RGBA,HDR 32bit floating point per channel. RAW (None) MiLai original format.(See figure below) RGBA,HDR 32bit floating point per channel. 读取PNG图片到场景： loadPNG.lua version3() local mypng = loadPNG([[d:\\test.png]]) -- Replace to your path. castTex(OUTPUT,mypng) -- Cast pixels from mypng to OUTPUT. 保存PNG图片到本地： savePNG.lua version3() --Draw something to OUTPUT move(width/2,height/2) rotate(time) triangle() --End drawing. savePNG([[d:\\test.png]],OUTPUT) -- Save OUTPUT as PNG to local disc. Replace to your path here. 把PNG换成EXR即可保存、读取EXR图片。 保存到某些位置需要管理员权限。 修整贴图 使用rotateTex(texId,times)来旋转90*times度贴图，rotateTex(texId)等价于rotateTex(texId,1) 使用flipTex(texId,flipV)来镜像翻转贴图，其中flipV为布尔值，flipV为true时垂直镜像，false时水平镜像。 使用resizeTex(texId,width,height)来缩放贴图。 使用trimTex(texId,p1x,p1y,p2x,p2y)来裁剪贴图。p1x,p1y,p2x,p2y是以贴图左上角为原点的坐标。 "},"contents/Lua/Filter.html":{"url":"contents/Lua/Filter.html","title":"滤镜系统","keywords":"","body":"滤镜系统 请确保您拥有v3.6.0+的PixelsWorld 滤镜系统是对矩形着色器的封装，允许您快速建立对画面整体效果的后期处理着色器。 通过这一章，您能快速了解并学习使用PixelsWorld的滤镜系统。 newFilter 创建滤镜 runFilter 运行滤镜 delFilter 删除滤镜 setFilterUniform 设置滤镜 setFilterDrawto 设置输出图像 newFilterModule 创建滤镜模组 高级应用 创建滤镜 使用newFilter(glslCode)来创建一个滤镜程序 返回：一个代表滤镜程序的随机整数（滤镜ID） glslCode将被插入下面的上下文中： glslcode_context.glsl #version 330 core in vec2 uv; out vec4 outColor; // Your glslCode here! 样例 注意：在Lua中，我们使用双重中括号[[...]]来表示分行字符串 newFilter.lua version3() filterID = newFilter([[ void main(){ outColor = vec4(uv,0,1); } ]]) 运行滤镜 使用runFilter(filterID)来运行一个滤镜程序 样例 runFilter.lua version3() filterID = newFilter([[ void main(){ outColor = vec4(uv,0,1); } ]]) runFilter(filterID) 删除滤镜 使用delFilter(filterID)来删除一个滤镜。 通常您不需要删除滤镜，在每帧结束时PixelsWorld会自动删除所有滤镜。但在不需要一个滤镜的时候删除它仍然是一个很好的习惯。 样例 delFilter.lua version3() filterID = newFilter([[ void main(){ outColor = vec4(uv,0,1); } ]]) delFilter(filterID) 设置滤镜 使用setFilterUniform(filterID, uniformType, uniformName, data0, data1, data2, ...)来设置滤镜中您定义的uniform属性。 filterID: 滤镜ID，整数。 uniformType: 代表变量类型的字符串。支持一维数据（\"int\",\"float\",\"bool\"）、向量（\"vec2\",\"vec3\",\"vec4\",\"ivec2\"...）、矩阵（\"mat2, mat4x3, ...\"）、贴图（\"sampler2D\"） uniformName：变量名称字符串。 data0,data1,...：浮点数据。（详见样例） 样例 setFilterUniform.lua version3() filterID = newFilter([[ uniform float myfloat; uniform vec2 myvec; uniform mat3x2 mymat; uniform sampler2D mytex1; void main(){ outColor = vec4(myfloat,myvec[0],mymat[0][1],1) + texture(mytex1,uv); } ]]) setFilterUniform(filterID, \"float\", \"myfloat\", math.sin(time)*0.5 + 0.5) setFilterUniform(filterID, \"vec2\", \"myvec\", 1,2) -- Column major, namely mymat[0][0]==1, mymat[0][1]==slider(0), mymat[0][2]==2, mymat[1][0]==3, ... setFilterUniform(filterID, \"mat3x2\", \"mymat\", 1, slider(0), 2, 3, 4, 5) -- Use INPUT texture as mytex1 setFilterUniform(filterID, \"sampler2D\", \"mytex1\", INPUT) -- ** You can also set the texture you created as mytex1 ** -- myInputTexID = newTex(512,256) -- setFilterUniform(filterID, \"sampler2D\", \"mytex1\", myInputTexID) runFilter(filterID) 设置输出图像 使用setFilterDrawto(filterID, texID)来指定滤镜的结果要放在哪张贴图上。关于texID请参见贴图系统 默认的输出贴图为OUTPUT 您甚至可以对一张图像进行迭代着色。 详情见高级应用 创建滤镜模组 使用newFilterModule(glslCode)来创建一个滤镜模组。 返回：含有滤镜ID和一些效用函数的表。 滤镜模组的作用是简化您的代码。 如果您不使用滤镜模组，通常需要这么写一个滤镜： no_module.lua version3() filterID = newFilter([[ uniform float myfloat; void main(){ outColor = vec4(myfloat,0,0,1); } ]]) setFilterUniform(filterID, \"float\", \"myfloat\", math.sin(time)*0.5 + 0.5) setFilterDrawto(filterID, OUTPUT) runFilter(filterID) delFilter(filterID) 使用滤镜模组后，您可以这么写： no_module.lua version3() filter = newFilterModule([[ uniform float myfloat; void main(){ outColor = vec4(myfloat,0,0,1); } ]]) filter.set(\"float\", \"myfloat\", math.sin(time)*0.5 + 0.5) filter.drawto(OUTPUT) filter.run() filter.del() 高级应用 下面是通道模糊的代码样例： slider 0：模糊力度 layer 0：模糊遮罩 iterateFilter.lua version3() -- Create a temp texture tempTexID = newTex(width,height) -- Copy input to temp texture castTex(tempTexID, INPUT) -- Blur code blurGLSLCode = [[ uniform sampler2D in_tex; uniform mat3 kernel; uniform vec2 resolution; void main() { vec2 xy = resolution * uv; vec4 res = vec4(0,0,0,0); for(int x = 0; x "},"contents/Lua/Simulation.html":{"url":"contents/Lua/Simulation.html","title":"物理模拟","keywords":"","body":"物理模拟 下图是由nimitz制作的Chimera's Breath在PixelsWorld中运行的结果。查看完整视频 本章将介绍如何在PixelsWorld中缓存数据。 注意：由于Ae功能有限，请严格遵循本手册制定的规范进行缓存。 请检查您拥有v3.3.3+版本的PixelsWorld 本篇文章认为读者拥有一定的Ae操作和PixelsWorld代码的熟练度，若您还不熟悉PixelsWorld的使用，请进入前面的章节进行学习。 缓存数据 缓存贴图 缓存数据实战——三体问题模拟 缓存贴图实战——康威生命游戏 缓存贴图实战——流体模拟 缓存数据 在PixelsWorld中缓存数据需要遵循以下几步： 代码逻辑： 设定缓存位置和缓存文件名称 计算frameId=time*fps 计算lastFrameId=frameId-1 若lastFrameId小于0，前往5，否则前往6 初始化数据，前往7 读取本地存储的上一帧模拟数据文件，文件不存在时报错，否则前往7 计算本帧模拟数据 存储本帧模拟数据到本地 操作逻辑： 将满足上述逻辑的代码写入PixelsWorld中 将时间指示器移动到当前图层的最开始位置处 清除Ae所有缓存（Edit->Purge->All Memory & Disk Cache... 如下图） 按住Ctrl+Alt单击插件面板上的LOGO（这一步可选） 敲击空格开始渲染（不要跳着渲染） 注意：遇到任何不如意的情况（报错、画面闪动等），都要重新执行第2~5步 缓存贴图 代码逻辑： 若降采样（二分之一、四分之一模式），则报错 设定缓存位置和缓存文件名称 计算frameId=time*fps 计算lastFrameId=frameId-1 若lastFrameId小于0，前往5，否则前往6 初始化数据，前往7 读取本地存储的上一帧贴图文件，文件不存在时报错，否则前往7 计算本帧贴图文件 存储本帧贴图文件到本地 关于贴图操作，请看贴图章节 操作逻辑： 将满足上述逻辑的代码写入PixelsWorld中 将插件面板中的设定Advanced->Internal texture format设为Floating point 32bit x RGBA (HDR) 将时间指示器移动到当前图层的最开始位置处 清除Ae所有缓存（Edit->Purge->All Memory & Disk Cache...） 按住Ctrl+Alt单击插件面板上的LOGO（这一步可选） 敲击空格开始渲染（不要跳着渲染） 缓存数据实战——三体问题模拟 the_three_body_problem.lua version3() -- 导入向量库 require(\"veclib\") -- 设定缓存文件名称 local cacheFileName = \"A\" -- 声明检查文件是否存在的函数（函数摘自：https://stackoverflow.com/questions/4990990/check-if-a-file-exists-with-lua） function file_exists(name) local f=io.open(name,\"r\") if f~=nil then io.close(f) return true else return false end end -- 计算当前帧序号并四舍五入取整 local frameId = math.floor(time * fps + .5) -- 计算上一帧序号 local lastFrameId = frameId -1 -- 检查当前帧序号是否非负，若是负数报错。 assert(frameId >= 0, \"FrameId not support\") -- 打印当前帧序号（这一行可以删掉） println(\"Frame ID: \" .. frameId) -- 设定缓存文件夹（我这里用了aep工程所在文件夹旁边的cache文件夹作为目录，使用projectFolder前需要先保存工程） local cachePath = projectFolder .. \"cache\\\\\" -- 打印当前输出文件夹（这一行可以删掉） println(\"Cache path: \" .. cachePath) -- 若本帧序号为0（也就是上一帧小于0） if(lastFrameId 缓存贴图实战——康威生命游戏 game_of_life.lua version3() -- 检查降采样 assert(width == ds_width and height == ds_height , \"Downsample not support\" ) -- 声明检查文件是否存在的函数（函数摘自：https://stackoverflow.com/questions/4990990/check-if-a-file-exists-with-lua） function file_exists(name) local f=io.open(name,\"r\") if f~=nil then io.close(f) return true else return false end end -- 计算当前帧序号并四舍五入取整 local frameId = math.floor(time * fps + .5) -- 计算上一帧序号 local lastFrameId = frameId -1 -- 检查当前帧序号是否非负，若是负数报错。 assert(frameId >= 0, \"FrameId not support\") -- 打印当前帧序号（这一行可以删掉） println(\"Frame ID: \" .. frameId) -- 设定缓存路径 local cachePath = projectFolder .. \"cache\\\\\" println(\"Cache path: \" .. cachePath) -- 检查是否是第一帧 if(lastFrameId = res.x || iuv.x =res.y || iuv.y.5; } // From https://thebookofshaders.com/10/ float random (vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123); } void main(){ if(time == 0.) { outColor = vec4(random(uv)>.5); }else{ bool curstatus = fetchStatus(0,0); int roundCount = 0; for(int i = 0;i 3) outColor = vec4(0); else outColor = vec4(curstatus); } else { if(roundCount == 3) outColor = vec4(1); else outColor = vec4(0); } } } ]==] -- 把上一帧图片放到PARAM0位置处，这样glsl在layer[0]可以读取上一帧贴图 swapTex(PARAM0,lastTexA) --渲染代码 glsl(fragCode) -- 把上一帧图片放回自己的位置 swapTex(PARAM0,lastTexA) -- 储存本帧贴图到本地 saveRAW(cachePath .. \"A_\" .. tostring(frameId) .. \".raw\",OUTPUT) 缓存贴图实战——流体模拟 注意：应原作者代码证书要求，下面的代码仅供学习交流使用。请勿商用 不要忘记把插件面板上的设定Internal texture format改成Floating point 32 bit x RGBA (HDR)。 请在着手模拟前确保您阅读了前文的操作说明！ 前去阅读>>> 把Mipmap filter设置成NONE可以提速。 fluid_simulation.lua version3() assert(width == ds_width and height == ds_height , \"Downsample not support\" ) function file_exists(name) local f=io.open(name,\"r\") if f~=nil then io.close(f) return true else return false end end local frameId = math.floor(time * fps + .5) local lastFrameId = frameId -1 assert(frameId >= 0, \"FrameId not support\") println(\"Frame ID: \" .. frameId) local cachepath = projectFolder .. \"cache\\\\\" println(\"Cache path: \" .. cachepath) if(lastFrameId "},"contents/Lua/Poly.html":{"url":"contents/Lua/Poly.html","title":"Poly函数","keywords":"","body":"创世神启示录——Poly函数 poly(obj)函数将解析obj并绘制物体。 由于本篇较晦涩难懂，我们极力推荐您在观看官方Poly函数视频教程的同时阅读本章节内容。 使用例 如果您用过Houdini，obj的构造过程类似于填一张Houdini中的SpreadSheet 下面这个例子是构造一个奇特三角形的obj PolyTest1.lua version3() background(0.95) move(width/2,height/2) dim3() dotRadius(5) obj={ point={ {p={0,0,0},color={0,1,1}}, {p={100,0,0},color={1,1,0}}, {p={0,100,0},color={1,0,1}}, {p={100,100,0},color={1,0,0}}, }, prim={ {type=\"triangle\",pref={1,2,3}}, {type=\"line\",pref={2,3,3,4,4,2}}, {type=\"point\",pref={2,4}}, } } poly(obj) 支持的图元即名称 以下以pref={1,2,3,4,5,6}为例子做说明。 pref意思是point reference，即参考点的序号，图元会按照送入序号的顺序绘制。 分号（;）为结束一次图元的绘制。 标准名称(type name) 对应图元 绘制顺序 全称 points 点 1;2;3;4;5;6; points pointd 平面点 1;2;3;4;5;6; point disc pointb 球点 1;2;3;4;5;6; point ball line 一根线 123456; single line linef 一根平面线 123456; line flat linec 一根立体线 123456; line capsule linel 循环线 1234561; line loop linelf 循环平面线 1234561; line loop flat linelc 循环立体线 1234561; line loop capsule lines 多根线 12;34;56; lines linesf 多根平面线 12;34;56; lines flat linesc 多根立体线 12;34;56; lines capsule triangles 三角面 123;456; triangles triangleb 桥构造三角面 123;324;345;546; triangle bridge triangler 放射构造三角面 123;134;145;156; triangle radial obj的构造 我们这里按照下面的顺序定义obj的细节。 obj是一个表。 obj可含有四个键：point,vertex,prim,detail。 obj的四个键对应的值分别为四张表，称作pointArray,vertexArray,primArray,detailList。 pointArray必须存在。 vertexArray是可选的。 primArray必须存在。 detailList是可选的。 上述带Array后缀的表可以装有N个子表，N可以自由定义大小。 pointArray的第k个子表叫做point[k]或“第k个点”。 vertexArray的第k个子表叫做vertex[k]或“第k个子点”。 primArray的第k个子表叫做prim[k]或“第k个图元”。 detailList及上述的点、子点和图元，装着若干不可再细分的单位：键值对。这些键值对的键暂时称为K,值称为V。 K推荐只含有英文数字和下划线，且不是纯数字。 V有一维、二维、三维、四维、字符串、贴图id和索引组共7种。 对于任意浮点数x,y,z,w x或{x}称作一维V。 {x,y}称作二维V。 {x,y,z}称作三维V。 {x,y,z,w}称作四维V。 \"Hello! PixelsWorld!\"称作字符串V。 (K的末尾四个字符\"_tex\")且(V是整数且对应贴图存在)时，称作贴图idV。 对于整数数列a1,...,an,{a1,a2,a3,...,an}称作索引组V。 对于每个点point[k]，都必须存在名称为\"p\"的K来表示点位置。否则为无效点。 对于每个子点vertex[k]，都必须存在名称为\"pref\"的K和一维V表示参照点id。否则为无效子点。 对于每个图元prim[k]，都必须存在\"type\"的K和字符串V来表示图元类型，同时必须存在\"vref\"或\"pref\"的K和索引组V来表示图元的绘制点顺序。 覆盖优先级 对于一个同名的K，我们定义如下的覆盖优先级： 和Houdini相同 vertex point prim detail 使用例： 下面这个obj的prim含有颜色信息（红色），所以最终会出来一个纯红色的三角形。 PrimColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0}}, {p={100,0,0}}, {p={0,100,0}}, }, prim={ {type=\"triangle\",pref={1,2,3},color={1,0,0}}, }, } poly(obj) 而下面这个obj的prim和point都具有color，因为point的优先级比较高，所以三角形采用了point提供的数据，最终出现一个彩色的三角形。 PointColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},color={0,1,1}}, {p={100,0,0},color={1,1,0}}, {p={0,100,0},color={1,0,1}}, }, prim={ {type=\"triangle\",pref={1,2,3},color={1,0,0}}, }, } poly(obj) Vertex的用法 Vertex（子点）可以继承Point（点）的信息。 VertexColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0}}, {p={100,0,0}}, {p={0,100,0}}, {p={100,100,0}}, }, vertex={ {pref=1,color={1,0,0}}, {pref=2,color={1,0,0}}, {pref=3,color={1,0,0}}, {pref=2,color={0,1,0}}, {pref=3,color={0,1,0}}, {pref=4,color={0,1,0}}, }, prim={ {type=\"triangle\",vref={1,2,3,4,5,6}}, }, } poly(obj) pref用来指明当前vertex参考的是哪个point，pref全称为Point reference。 prim中的vref是Vertex reference的全称。 注意：Lua中的表，第一个元素的序号为1不是0。 如果不用Vertex，情况就会变成下面这样： NoVertex.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},color={1,0,0}}, {p={100,0,0},color={1,0,0}}, {p={0,100,0},color={1,0,0}}, {p={100,100,0},color={0,1,0}}, }, prim={ {type=\"triangle\",pref={1,2,3,2,3,4}}, }, } poly(obj) 附带shader 您甚至可以在Poly里面使用shader语言。 FragColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},myattribute={1,0}}, {p={100,0,0},myattribute={0,1}}, {p={0,100,0},myattribute={0,0}}, {p={100,100,0},myattribute={1,1}}, }, prim={ { type=\"triangle\", pref={1,2,3,2,3,4}, frag=[==[ #define t ]==] .. tostring(time) .. [==[ void main(){ outColor = vec4(mod(myattribute*10+vec2(t),1),0,1); } ]==], }, }, } poly(obj) 使用贴图 下面的obj将使用输入层做贴图输出到场景中。 当某整数属性值的键名称后缀带有_tex时，该属性将被视为贴图id. 使用自定义shader可以同时在一个prim中使用多个贴图。 更多关于贴图的信息 UVTex.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},uv={0,0}}, {p={100,0,0},uv={1,0}}, {p={0,100,0},uv={0,1}}, {p={100,100,0},uv={1,1}}, }, prim={ { type=\"triangler\", pref={1,2,4,3}, my_tex=INPUT, }, }, } poly(obj) "},"contents/Lua/TransparencyRender.html":{"url":"contents/Lua/TransparencyRender.html","title":"透明渲染","keywords":"","body":"透明形状渲染 一般在渲染一列半透明立方体时，会得到下面的结果 normalCubes.lua version3() in2out() dim3() fill(1,.5) move(width/2, height/2) for i = 1,10 do move(20,0,200) cube() end 但是这个结果是不对的，我们看不到透明立方体后面的部分。 我们需要根据摄像机从远到近渲染这些立方体，这样才能产生正确的叠色： sortCubes.lua version3() in2out() dim3() fill(1,.5) sortarr = {} beginGroup() move(width/2, height/2) for i = 1,10 do move(20,0,200) local x,y,z = global2screen(local2global(0,0,0)) -- Get camera distance sortarr[i] = {z,getTransformMatrix()} -- {distance, transform status} pairs end endGroup() table.sort( sortarr, function(a,b) return a[1] > b[1] end -- Sort by z distance ) for i = 1,10 do beginGroup(sortarr[i][2]) -- Apply transform status cube() endGroup() end "},"contents/Lua/RunGLSL.html":{"url":"contents/Lua/RunGLSL.html","title":"在Lua中运行GLSL ","keywords":"","body":"在lua中运行GLSL 用法 glsl.lua version3() glsl(Your_code_string_here) 注意，我们推荐使用[==[Your_code_string_here]==]符号把字符串括起来，这样不会产生任何转译问题。即：一般您的代码需要写成下面这种形式： glsl2.lua version3() glsl([==[ void main(){ outColor = vec4(uv,sin(time*10)/2+.5,1); } ]==]) 使用下面的代码可以渲染来自shadertoy.com的代码 shadertoy.lua version3() shadertoy(Your_shadertoy_code_here) "},"contents/GLSL/GLSLCode.html":{"url":"contents/GLSL/GLSLCode.html","title":"显卡狂战士GLSL","keywords":"","body":"显卡狂战士GLSL 本节中, 我们将快速了解如何在像素世界里运行GLSL GLSL是什么? GLSL是OpenGL Shader Language的缩写，它是OpenGL支持的基于GPU的渲染语言。 主要通过编写像素渲染规则，使用GPU进行计算。 如何学习? 我们推荐着色器之书，在线即可免费阅读。 显卡语言的优势 如果把主板上的中央处理器(CPU)和显卡上的图形处理器(GPU)做比较的话，CPU像是一辆超级跑车，GPU则像是一辆大型客车。 在一段路程间运输少量人员的话，用一辆超级跑车表现会非常优秀。 但是如果想要做重复性非常高的工作——比如计算一张图像——这时就可以比喻作有成百上千的人员需要移动，那么这时，选择一辆大型客车显然才是明智之举。 我们平时学习的编程语言，诸如C/C++、Java、Python，大都是直接运行在CPU上的。 而GLSL这样的语言，是为了运行在GPU上而设计的语言。 在处理一张图像的时候，GPU可以同时派出非常多的“工人”去做重复性高的工作，而具体的工作内容就由GLSL来指定。 关于GLSL语法的更多信息 , 建议您访问 shadertoy.com. 找到一些有趣且简单的效果，来探索它是如何生效的。 细节 : 在运行GLSL前我们会预定义非常多的变量和函数，如果您是初学者，可以暂时忽略这里。 PixelsWorld V3.0.0 使用的是 #version 330 core. 点击这里查看额外的预定义代码 "},"contents/GLSL/RunGLSL.html":{"url":"contents/GLSL/RunGLSL.html","title":"运行GLSL","keywords":"","body":"运行GLSL代码 GLSL代码请在GLSL(GPU) 模式下运行; 在 \"World rule\"这单击\"Edit\"; 此时，会有部分代码在面板显示。 default.shader void main(){ outColor = getColor(uv); } 此代码会把输入像素发送至输出像素。 你可以把 getColor(uv)改为 vec4(uv,0.0,1.0) 以获得好看的uv色彩图案； uvcolor.shader void main(){ outColor = vec4(uv,0.0,1.0); } 接着, 单击 \"Ok\"即可。 正常情况下，应该会得到如下效果： "},"contents/GLSL/GetStart.html":{"url":"contents/GLSL/GetStart.html","title":"快速开始","keywords":"","body":"写着色器代码是什么感觉？ 着色器代码就像Excel表格工具的表达式功能。通过给表格写入表达式，表格会帮你处理所有数据。 如果我们把表格里的数据理解为输入像素，计算后的表格为输出像素，像素世界的代码就可以理解为Excel表格里的表达式。 使用例：让图像变亮 让一张图像变亮，最简单的计算方法就是让所有像素的红、绿、蓝的数值调高。如果在Excel表格里面，我们需要做如下工作： 这样就可以让左边所有的像素数据都“变亮”了。 换成像素世界，我们就需要输入 bright_describe.shader outColor=getColor(uv)+vec4(0.2); 翻译成人话就是：获取当前位置（uv）的输入像素（getColor），并给四个通道（红、绿、蓝、透明）加上0.2（+vec4(0.2)），最后把计算的结果送到（=）输出（outColor）。 当然只有这一行，像素世界不能正常工作，外面还要套一层“壳”就可以正常工作啦！完整代码如下： bright.shader void main(){ outColor=getColor(uv)+vec4(0.2); } 操作方法： 输入图像（右键保存）： （源作者链接） 效果图： 加入更多的控制！ 当然如果只给图片加0.2通常并不是我们想要的，我们想获取更多的可控性。我们可以把0.2换成slider[0]，这样的话，我们使用参数面板上的滑竿就可以控制特效了。 bright_control.shader void main(){ outColor=getColor(uv)+vec4(slider[0]); } 不过你会发现，如果数值是负的时候，透明度也会跟着变小，但我们通常不想修改图像透明度，需要避开修改透明度通道。如果是这样的话，渲染代码就需要写成下面的形式： bright_control.shader void main(){ vec4 inColor = getColor(uv); inColor.rgb = inColor.rgb + vec3(slider[0]); outColor = inColor; } 解释：先把输入像素暂存在一个四维(vec4)变量inColor里，然后把rgb（代表红绿蓝）这三个通道加上slider[0]的数值。最后再把inColor的值给outColor。这样inColor的a通道（代表透明通道）就会被原封不动地送入输出。 给参数标上名称 我们可以通过如下操作，让我们的参数面板变得整洁一些： 保存至预设 最后我们可以将写好的代码，特别是之后可能会用上的代码保存进预设里。请前往预设管理章节了解详情。 恭喜您！ 您已经掌握了像素世界的大体使用流程！ 像素世界除了可以自己写入代码外，您还可以去shadertoy网站上找一些好玩的效果放入像素世界。关于如何渲染来自shadertoy的代码，请参阅这里。 "},"contents/GLSL/Functions.html":{"url":"contents/GLSL/Functions.html","title":"函数","keywords":"","body":"函数 本节简要介绍内置函数。 这些函数无需任何声明即可使用。 "},"contents/GLSL/getColor.html":{"url":"contents/GLSL/getColor.html","title":"getColor","keywords":"","body":"getColor 此函数有两种版本。 getColor(vec2) 与 getColor(int ,vec2) getColor(vec2) 说明 : 在指定位置获取 输入层的颜色。 参数: vec2：uv位置（各维度0~1） 返回 : vec4 : RGBA颜色（各维度0~1） getColor(int,vec2) 说明 : 获取特定输入层 指定位置的像素 参数 : int : 图层索引, -1 (或者 AE_INPUT_LAYER) 也就是输入层，数字0-9代表着插件面板对应的图层参数0-9(PW_TEMP_LAYER (图层索引-2) Lua渲染模式下使用) vec2 : uv 坐标 返回 : vec4 : RGBA颜色 注意 : 总之, getColor(AE_INPUT_LAYER,uv); 与getColor(uv)效果一致; getColor(n,uv); 能返回layer[n]的像素信息 "},"contents/GLSL/uvxy.html":{"url":"contents/GLSL/uvxy.html","title":"uv2xy,xy2uv","keywords":"","body":"uv2xy,xy2uv 这两个函数用于UV坐标与 XY 坐标之间转换 只是做一些乘除法。 uv2xy(vec2) 说明： 通过给定的uv值计算xy值。 参数： vec2 : uv位置值。 返回： vec2 : xy位置值。 注意： 如果图层尺寸为1280 x 720，则 uv2xy(vec2(0.1,0.5)); 返回 vec2(128.0,360.0); xy2uv(vec2) 说明： 通过给定的xy值计算uv值。 说明： vec2 : xy位置值。 返回： vec2 :uv位置值。 注意： 如果图层尺寸为1920 x 1080，则 xy2uv(vec2(192,108)); 返回 vec2(0.1,0.1); "},"contents/GLSL/LinkParameters.html":{"url":"contents/GLSL/LinkParameters.html","title":"链接参数","keywords":"","body":"链接参数 通过使用外部参数，可以进行动画设置。 当前拥有7种类型参数可用于动画 Sliders Angles Points 3D Points Checkboxes Colors Layers 且每组参数都有10个控制器可供调配 示例 : link_slider.shader void main(){ outColor = vec4(uv,slider[0],1.0); } 比如改变slider 0，预览界面颜色将会变化。 详情 在PixelsWorld参数声明方式如下所示： parameters.shader uniform float slider[10]; uniform float angle[10]; uniform bool checkbox[10]; uniform vec2 point[10]; uniform vec3 point3d[10]; uniform vec4 color[10]; uniform sampler2D layer[10]; uniform sampler2D inLayer; 注意 \"inLayer\" 代表输入层。 sampler2D 是一种由 GLSL提供的变量类型，不用理解该变量类型。如果你想了解图层参数，请参考 \"getColor\" \"uniform\" 代表全局变量。 "},"contents/GLSL/debug.html":{"url":"contents/GLSL/debug.html","title":"调试","keywords":"","body":"Debug 在插件面板勾选debug 复选框 当有错误信息时，会被用红色字体打印在屏幕上。 "},"contents/GLSL/Advanced_settings.html":{"url":"contents/GLSL/Advanced_settings.html","title":"高级设置","keywords":"","body":"高级设置 本节介绍效果面板中的高级选项设置。 Wrap U/V sampler 当采样的像素超出图像边界时，此参数会影响 getColor() 的结果 测试代码(在素材上应用PixelsWorld): wrap_uv_sampler.shader void main(){ outColor = getColor(uv*10); } Magnify/Minify sampler 当采样器要对周围像素进行插值采样时，此参数会影响 getColor() 的行为 测试代码 (在素材上应用PixelsWorld): wrap_uv_sampler.shader void main(){ outColor = getColor(uv*0.1); } 如果想构建相同的像素样式效果， 请把此选项设置为 Nearest pixel（最近像素） Mipmap 可以指定缩小时材质的取色方法。 wrap_uv_sampler.shader void main(){ outColor = getColor(uv*10); } "},"contents/GLSL/predefined.html":{"url":"contents/GLSL/predefined.html","title":"预定义","keywords":"","body":"预定义代码 shader代码在运行前，前后会被接上我们预先设定的环境代码来支持不同的特性。 GLSL模式只含有前置代码。 shadertoy模式有前置代码和后置代码。 GLSL模式 前置代码： pre_frag_shader_glsl.frag #define gl_Position uv2xy(uv) #define gl_FragCoord uv2xy(uv) #define gl_FragColor outColor #define INPUT_LAYER_INDEX -1 #define OUTPUT_LAYER_INDEX -2 #define AE_INPUT_LAYER -1 #define PW_TEMP_LAYER -2 out vec4 outColor; in vec2 uv; uniform float slider[10]; uniform float angle[10]; uniform bool checkbox[10]; uniform vec2 point[10]; uniform vec3 point3d[10]; uniform vec4 color[10]; uniform sampler2D layer[10]; uniform vec2 layerResolution[10]; uniform sampler2D inLayer; uniform sampler2D outLayer; uniform float time; uniform float inpoint; uniform float duration; uniform float comp_time; uniform vec4 date; // vec4(year,month,day,hour*3600 + minute*60 + second + millisecond/1000.) uniform float fps; uniform float width; uniform float height; uniform vec2 origin; uniform vec2 resolution; uniform vec2 downsample; uniform mat4 camera_matrix; uniform vec4 camera_info; // x,y: resolution, z: distance to plane, w: distance to focus. uniform bool camera_perspective; uniform sampler1D inWaveL; // Left wave samples uniform sampler1D inWaveR; // Right wave samples uniform float inWaveN; // Wave sample number uniform float inWaveS; // Sample rate, settings in plugin panel. Default: 44100. uniform vec2 inWaveT; // vec2(sampleStartTime, sampleEndTime), unit: second. New in v3.4.0 uniform sampler1D inSpecL; // Left spectrum samples uniform sampler1D inSpecR; // Right spectrum samples uniform float inSpecN; // Spectrum sample number uniform vec2 inSpecF; // vec2(spectrumStartFrequency, spectrumEndFrequency), unit: hz. New in v3.4.0 vec4 getColor(int layerId,vec2 coord) { if(layerId==AE_INPUT_LAYER) return texture(inLayer,coord); if(layerId==PW_TEMP_LAYER) return texture(outLayer,coord); else if(layerId>=0 && layerId shadertoy 代码 前置代码 pre_frag_shader_shadertoy.frag #define gl_Position (_PixelsWorld_uv * iResolution.xy) #define gl_FragCoord (_PixelsWorld_uv * iResolution.xy) #define gl_FragColor _PixelsWorld_outColor #define _PixelsWorld_INPUT_LAYER_INDEX -1 #define _PixelsWorld_OUTPUT_LAYER_INDEX -2 #define _PixelsWorld_AE_INPUT_LAYER -1 #define _PixelsWorld_PW_TEMP_LAYER -2 uniform vec3 iResolution; uniform float iTime; uniform float iTimeDelta; uniform int iFrame; // uniform float iChannelTime[4]; uniform vec4 iMouse; uniform vec4 iDate; uniform sampler2D iChannel0; uniform sampler2D iChannel1; uniform sampler2D iChannel2; uniform sampler2D iChannel3; uniform vec3 iChannelResolution[4]; uniform float _PixelsWorld_slider[10]; uniform float _PixelsWorld_angle[10]; uniform bool _PixelsWorld_checkbox[10]; uniform vec2 _PixelsWorld_point[10]; uniform vec3 _PixelsWorld_point3d[10]; uniform vec4 _PixelsWorld_color[10]; uniform sampler2D _PixelsWorld_layer[10]; uniform vec2 _PixelsWorld_layerResolution[10]; uniform sampler2D _PixelsWorld_inLayer; uniform sampler2D _PixelsWorld_outLayer; uniform float _PixelsWorld_time; uniform float _PixelsWorld_inpoint; uniform float _PixelsWorld_duration; uniform float _PixelsWorld_comp_time; uniform vec4 _PixelsWorld_date; uniform float _PixelsWorld_fps; uniform float _PixelsWorld_width; uniform float _PixelsWorld_height; uniform vec2 _PixelsWorld_origin; uniform vec2 _PixelsWorld_resolution; uniform vec2 _PixelsWorld_downsample; uniform mat4 _PixelsWorld_camera_matrix; uniform vec4 _PixelsWorld_camera_info; uniform bool _PixelsWorld_camera_perspective; uniform sampler1D _PixelsWorld_inWaveL; uniform sampler1D _PixelsWorld_inWaveR; uniform float _PixelsWorld_inWaveN; uniform float _PixelsWorld_inWaveS; uniform vec2 _PixelsWorld_inWaveT; uniform sampler1D _PixelsWorld_inSpecL; uniform sampler1D _PixelsWorld_inSpecR; uniform float _PixelsWorld_inSpecN; uniform vec2 _PixelsWorld_inSpecF; in vec2 _PixelsWorld_uv; out vec4 _PixelsWorld_outColor; vec4 _PixelsWorld_getColor(int layerId,vec2 coord) { if(layerId==_PixelsWorld_AE_INPUT_LAYER) return texture(_PixelsWorld_inLayer,coord); if(layerId==_PixelsWorld_PW_TEMP_LAYER) return texture(_PixelsWorld_outLayer,coord); else if(layerId>=0 && layerId 后置代码 post_frag_shader_shadertoy.frag void main(){ mainImage(_PixelsWorld_outColor, _PixelsWorld_uv * iResolution.xy); } "},"contents/GLSL/shadertoy.html":{"url":"contents/GLSL/shadertoy.html","title":"模板圣域shadertoy","keywords":"","body":"模板圣域shadertoy 用法 在此模式下，你可以直接使用来自 shadertoy.com的代码。 注意 并非所有来自 shadertoy.com的代码均可在PixelsWorld下完美运行 (比如带有音频输入、需要VR支持和含有循环Buffer引用的代码) 细节 如果您想在shadertoy模式下自有调用参数面板，请把所有GLSL模式下的变量加上_PixelsWorld_前缀即可使用。 比如在GLSL模式下的slider[0]将变成_PixelsWorld_slider[0] 参考这里来了解所有全局变量的定义。 当然在shadertoy模式下我们不推荐您自己定义带有_PixelsWorld_前缀的变量。 使用Buffers Shadertoy自带4个Buffers，在PixelsWorld中也可以实现Buffers。 非循环式Buffers 如果你使用的特效没有循环Buffers之间的循环调用（如上图的下半部分）。那么你的特效中的Buffers属于非循环式Buffers。你可以用如下代码模板调用它们（注意：需要切换到Lua模式）。 例如来自：https://www.shadertoy.com/view/4dVGRW 的代码： 这个效果使用了BufferA，所以下面的代码在第四行把A设为了true。 BufferA在最终被绑定到Main图像的iChannel0上，所以下面代码在15行把AtoMain设为0。 然后，把BufferA和Main的代码分别复制到相应变量上即可。 最后，为了计算结果正确，你需要将插件面板上的Advanced->Internal texture format设为Floating point 32 bit x RGBA (HDR)来阻止PixelsWorld在内部削平Alpha通道的数值。 确保你在Lua渲染模式下。 rotatingCubes.lua version3() enable = { A=true, B=false, C=false, D=false, -- '-1': disable -- '0~3': which iChannel to set AtoB = -1, AtoC = -1, AtoD = -1, AtoMain = 0, BtoC = -1, BtoD = -1, BtoMain = -1, CtoD = -1, CtoMain = -1, DtoMain = -1, } mainCode = [==[ // Paste the main code here. mat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) { vec3 rr = vec3(sin(roll), cos(roll), 0.0); vec3 ww = normalize(target - origin); vec3 uu = normalize(cross(ww, rr)); vec3 vv = normalize(cross(uu, ww)); return mat3(uu, vv, ww); } vec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) { mat3 camMat = calcLookAtMatrix(origin, target, 0.0); return normalize(camMat * vec3(screenPos, lensLength)); } vec2 squareFrame(vec2 screenSize, vec2 coord) { vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0; position.x *= screenSize.x / screenSize.y; return position; } vec2 getDeltas(sampler2D buffer, vec2 uv) { vec2 pixel = vec2(1. / iResolution.xy); vec3 pole = vec3(-1, 0, +1); float dpos = 0.0; float dnor = 0.0; vec4 s0 = texture(iChannel0, uv + pixel.xy * pole.xx); // x1, y1 vec4 s1 = texture(iChannel0, uv + pixel.xy * pole.yx); // x2, y1 vec4 s2 = texture(iChannel0, uv + pixel.xy * pole.zx); // x3, y1 vec4 s3 = texture(iChannel0, uv + pixel.xy * pole.xy); // x1, y2 vec4 s4 = texture(iChannel0, uv + pixel.xy * pole.yy); // x2, y2 vec4 s5 = texture(iChannel0, uv + pixel.xy * pole.zy); // x3, y2 vec4 s6 = texture(iChannel0, uv + pixel.xy * pole.xz); // x1, y3 vec4 s7 = texture(iChannel0, uv + pixel.xy * pole.yz); // x2, y3 vec4 s8 = texture(iChannel0, uv + pixel.xy * pole.zz); // x3, y3 dpos = ( abs(s1.a - s7.a) + abs(s5.a - s3.a) + abs(s0.a - s8.a) + abs(s2.a - s6.a) ) * 0.5; dpos += ( max(0.0, 1.0 - dot(s1.rgb, s7.rgb)) + max(0.0, 1.0 - dot(s5.rgb, s3.rgb)) + max(0.0, 1.0 - dot(s0.rgb, s8.rgb)) + max(0.0, 1.0 - dot(s2.rgb, s6.rgb)) ); dpos = pow(max(dpos - 0.5, 0.0), 5.0); return vec2(dpos, dnor); } void mainImage(out vec4 fragColor, in vec2 fragCoord) { vec3 ro = vec3(sin(iTime * 0.2), 1.5, cos(iTime * 0.2)) * 5.; vec3 ta = vec3(0, 0, 0); vec3 rd = getRay(ro, ta, squareFrame(iResolution.xy, fragCoord.xy), 2.0); vec2 uv = fragCoord.xy / iResolution.xy; vec4 buf = texture(iChannel0, fragCoord.xy / iResolution.xy); float t = buf.a; vec3 nor = buf.rgb; vec3 pos = ro + rd * t; vec3 col = vec3(0.5, 0.8, 1); vec2 deltas = getDeltas(iChannel0, uv); if (t > -0.5) { col = vec3(1.0); col *= max(0.3, 0.3 + dot(nor, normalize(vec3(0, 1, 0.5)))); col *= vec3(1, 0.8, 0.35); } col.r = smoothstep(0.1, 1.0, col.r); col.g = smoothstep(0.1, 1.1, col.g); col.b = smoothstep(-0.1, 1.0, col.b); col = pow(col, vec3(1.1)); col -= deltas.x - deltas.y; fragColor = vec4(col, 1); } ]==]; commonCode = [==[ // Paste the common code here. ]==] bufferACode = [==[ // Paste the Buffer A code here. float sdBox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); } vec2 mirror(vec2 p, float v) { float hv = v * 0.5; vec2 fl = mod(floor(p / v + 0.5), 2.0) * 2.0 - 1.0; vec2 mp = mod(p + hv, v) - hv; return fl * mp; } vec2 rotate2D(vec2 p, float a) { return p * mat2(cos(a), -sin(a), sin(a), cos(a)); } float map(vec3 p) { float r = iMouse.z > 0.0 ? iMouse.x / 100.0 : iTime * 0.9; p.xz = mirror(p.xz, 4.); p.xz = rotate2D(p.xz, r); float d = sdBox(p, vec3(1)); d = min(d, sdBox(p, vec3(0.1, 0.1, 3))); d = min(d, sdBox(p, vec3(3, 0.1, 0.1))); return d; } mat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) { vec3 rr = vec3(sin(roll), cos(roll), 0.0); vec3 ww = normalize(target - origin); vec3 uu = normalize(cross(ww, rr)); vec3 vv = normalize(cross(uu, ww)); return mat3(uu, vv, ww); } vec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) { mat3 camMat = calcLookAtMatrix(origin, target, 0.0); return normalize(camMat * vec3(screenPos, lensLength)); } float calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) { float latest = precis * 2.0; float dist = +0.0; float type = -1.0; float res = -1.0; for (int i = 0; i maxd) break; float result = map(rayOrigin + rayDir * dist); latest = result; dist += latest; } if (dist = 0 and sch 循环式Buffer 嗯...如果你想用的效果是循环Buffer，我们十分不推荐在PixelsWorld中使用它们。（不过这依然是可以实现的，您需要做好跟Ae及PixelsWorld苦斗一夜的准备，我准备好了>>>） "},"contents/Lua/JavaScript.html":{"url":"contents/Lua/JavaScript.html","title":"世界的郊区JavaScript","keywords":"","body":"JavaScript代码 在 Lua (CPU & GPU) 模式下，像素世界可以通过 js 执行JavaScript代码。 executeJS.lua version3() js(\"alert('Hello PixelsWorld!')\"); 注意：由于Ae程序结构问题，我们不推荐您在像素世界中使用js代码（尤其是索取UI控件参数信息）。您可以用js代码做简单的局部变量之间的计算。 "},"contents/Lua/CMDCode.html":{"url":"contents/Lua/CMDCode.html","title":"世界的基盘CMD指令","keywords":"","body":"CMD代码 在 Lua (CPU & GPU) 模式下，像素世界可以通过 cmd(\"Your cmd commands\") 执行CMD命令。 executeCMD.lua version3() cmd(\"echo Hello PixelsWorld! & pause\"); "},"contents/Serial/SerialAttention.html":{"url":"contents/Serial/SerialAttention.html","title":"序列号使用约定","keywords":"","body":"序列号使用约定 注意：该页条款不适用于aescripts.com平台上购买的顾客。 一个序列号包含N个“注册次数”（N大于等于1） 一个“注册次数”永久注册一台电脑 一台电脑的一个“注册次数”可以在多个版本的Ae中使用 注册一台电脑将减少一个“注册次数”，解绑一台已注册的电脑将增加一个“注册次数” 仅注册和解绑两个操作需要联网，即注册后可以断网使用 在电脑更换主板或CPU前，请解绑序列号，并在更换后重新绑定。若您遗忘解绑序列号，请通过邮件与我们联系。 序列号不跟任何个人信息绑定，允许但不推荐朋友间传递使用或者倒卖。若发生传递使用或者倒卖，产生的一切使用、利益问题未来视觉演绎组概不负责。 “注册次数”在购买时默认只有一个，若您有多台设备并想同时使用像素世界，请购买相应数量的像素世界序列号，我们会发送相应“注册次数”的序列号。 "},"contents/QA/EntryPointErr.html":{"url":"contents/QA/EntryPointErr.html","title":"报错Couldn't find main entry point for PixelsWorld.aex (48::72)","keywords":"","body":"报错Couldn't find main entry point for PixelsWorld.aex (48::72) 如果您在首次测试/使用PixelsWorld时遇到下面错误提示时，请检查如下几项。 您需要通过Creative Cloud来把Ae更新至最新（对于CC2019推荐16.1.3+对于2020推荐17.5.1+） Windows10 需更新至最新版（推荐Windows 10 20H2及以后的版本） 您需要拥有最新的显卡驱动 您的显卡需要从硬件支持OpenGL 3.3及以上版本的协议（可以使用OpenGL Extensions Viewer工具查看） C:\\Windows\\System32目录下需存在OpenCL.dll "}}