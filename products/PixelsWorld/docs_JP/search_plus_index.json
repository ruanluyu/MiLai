{"./":{"url":"./","title":"今日、創造神になってきます！","keywords":"","body":"創造神になる PixelsWorld ドキュメントバージョン: v3.7.0 著者：中梓星音 English version 中文 ドキュメントをダウンロード（英語） ドキュメントをダウンロード（中文） ドキュメントをダウンロード（日本語） PixelsWorld へようこそ！ この節では、PixelsWorld を使用するためのエッセンスを凝縮しています。この部分をマスターすれば、あなたは PixelsWorld の新しい創造者となるでしょう！ かんたんに言うと PixelsWorld はあなたのコードに基づいてグラフィックをレンダリングします ここには知っておくべき重要な点があります。 PixelsWorld は単純なゲームエンジンのようなものです。 提供するすべてのコードは Lua エンジンで実行されます。 PixelsWorld でのコード作成は強力な表現式のようなものです。PixelsWorld がサポートするもの： 数学演算 テクスチャ操作 カスタムフィルター GLSL shadertoy.com のコード PixelsWorld はシンプルな 2D/3D ジオメトリを描画できます。詳細はこちら >>> ビデオチュートリアル まずは私たちの基本チュートリアルを視聴することを強くお勧めします。 基本チュートリアル >>> 2D 変換 >>> Lua サンプル：家を描く ここでは、Lua モードで家を描くコードのサンプルをご紹介します。 DrawHouse1.lua version3() -- バージョン 3 を使用、常に最初の行でこの関数を呼び出してください。 move(width/2, height/2) -- ペンを画面の中心に移動 rotateX(PI) -- X 軸を中心にペンの座標を 180 度回転 fill(1,1,0) -- 黄色のペンキを使用（赤=1、緑=1、青=0） rect(100) -- 100x100 ピクセルの正方形を描画 fill(1,0,0) -- 赤のペンキを使用（赤=1、緑=0、青=0） move(0,50) -- ペンの座標を上に 50 ピクセル移動 tri(150,100) -- 底辺150ピクセル、高さ100ピクセルの二等辺三角形を描画 ここでは、シーンに追加のコントロールを追加したいと思います。例えば、家の色のコンビネーションをコントロールします。 DrawHouse2.lua version3() -- バージョン 3 を使用、常に最初の行でこの関数を呼び出してください。 move(width/2, height/2) -- ペン座標を中心に移動 rotateX(PI) -- X 軸を中心にペン座標を 180 度回転 fill(color(0)) -- 色#0を使用 rect(100) -- 100x100 ピクセルの正方形を描画 fill(color(1)) -- 色#1を使用 move(0,50) -- ペン座標を上に 50 ピクセル移動 tri(150,100) -- 底辺150ピクセル、高さ100ピクセルの二等辺三角形を描画 そして確認ボタンをクリックすると、家は……消えてしまいます！ 実際には、我々の家はレイヤーに描かれているのですが、色のコントローラーのデフォルトの色が黒だったため、家は消えたように見えました。 この問題を解決するには、パラメータリストを開き、最初の2つの色コントローラーを見つけ、好みの色に変更します。 異なる家をもっと描こう！ コードの大きな利点は、その繰り返し操作を処理する能力にあります。 言うまでもなく、Lua 言語は繰り返しのコードを書くことができます。 DrawHouse3.lua version3() -- バージョン 3 を使用、常に最初の行でこの関数を呼び出してください。 move(width/2, height/2) -- ペン座標を中心に移動 rotateX(PI) -- X 軸を中心にペン座標を 180 度回転 for i=1,3 do -- 繰り返し開始（3 回） fill(color(0)) -- 色#0を使用 rect(100) -- 100x100 ピクセルの正方形を描画 fill(color(1)) -- 色#1を使用 move(0,50) -- ペン座標を上に 50 ピクセル移動 tri(150,100) -- 底辺150ピクセル、高さ100ピクセルの二等辺三角形を描画 move(0,-50) -- ペン座標を戻ります move(175,0) -- ペン座標を右に 175 ピクセル移動 end -- 繰り返し終了 上記のコードには「ペン座標を戻る」という操作が含まれていますが、毎回これを行うのは少々面倒です。beginGroup()とendGroup()を使用することで簡略化できます： DrawHouse4.lua version3() -- バージョン 3 を使用、常に最初の行でこの関数を呼び出してください。 move(width/2, height/2) -- ペン座標を中心に移動 rotateX(PI) -- X 軸を中心にペン座標を 180 度回転 for i=1,3 do -- 繰り返し開始（3 回） fill(color(0)) -- 色#0を使用 rect(100) -- 100x100 ピクセルの正方形を描画 fill(color(1)) -- 色#1を使用 beginGroup() -- 新しい行！ペン座標の変換を記録開始 move(0,50) -- ペン座標を上に 50 ピクセル移動 tri(150,100) -- 底辺150ピクセル、高さ100ピクセルの二等辺三角形を描画 endGroup() -- 新しい行！この行が自動的に呼び出します 'move(0,-50)' move(175,0) -- ペン座標を右に 175 ピクセル移動 end -- 繰り返し終了 最後にコントローラーに名前を付けたいと思います： コードをプリセットとして保存 注意：Ae をシステムファイルのあるディスク（例えば C:\\）にインストールしている場合、この手順には管理者モードが必要です。 最初に、独自のプリセットカテゴリーを作成します： 次に、自分のプリセットカテゴリーの下にプリセットを保存します： プリセットの適用 適用したいプリセットを選択し、右側のボタンで置き換えをクリックしてください。 おめでとうございます！ PixelsWorld の大まかな使用手順をマスターしました！ >>>次のステップ(初心者)：Lua章に進み、PixelsWorldのコア能力を理解する >>>次のステップ(中級者)：画像のレンダリングおよび処理にGPUをどのように活用するかを理解する >>>次のステップ(専門家)：Luaには既に精通しています。PixelsWorldのLuaモード環境で定義されている利用可能な関数と変数を知りたいです >>>次のステップ(専門家)：GPUシェーダーについて既に精通しており、PixelsWorldのGLSLモード環境で定義されている利用可能な変数を知りたいです PixelsWorld 構造 PixelsWorld の能力 "},"contents/HowTo.html":{"url":"contents/HowTo.html","title":"入手とダウンロード","keywords":"","body":"獲得と使用方法 ダウンロード PixelsWorldを購入/ダウンロードしてください。 注意： 一部のテストプリセットは非商業ライセンスの下にあり、使用する前にソースコード内のライセンスを確認してください。 \"MiLai\" フォルダを次の場所に配置します: AEインストールディレクトリ/Support Files/Plug-ins/ プラグインは以下にあります: AEインストールディレクトリ/Support Files/Plug-ins/MiLai/PixelsWorld.aex 使用方法 Adobe After Effects を開きます。 \"Ctrl + N\" (または \"Command + N\") で新しいコンポジションを作成します。 新しいソリッドレイヤーを作成します。 追加したレイヤーを選択します。 右クリック => エフェクト => MiLai => PixelsWorld \"Edit\" をクリックして \"ワールドルール\" を変更します。 この時、メニューが表示されます。 右上の \"Preset list\" に好きなエフェクトカテゴリを選択し、以下のリストからプリセットを選択します。 Replaceボタンをクリックします。 \"Ok\" をクリックします。 "},"contents/Editor/ScriptWindow.html":{"url":"contents/Editor/ScriptWindow.html","title":"世界ルール　エディター","keywords":"","body":"世界法則エディタ 打ち開け方 「World formula」の横にある「Edit」ボタンをクリックすると、世界法則エディタが開きます。以下は世界法則エディタを開いたときの画面です。 注意：バージョンのアップグレードに伴い、実際のスタイルが多少異なる場合があります。 説明をわかりやすくするために、異なる色で機能領域を枠で囲んでいます。以下の図をご覧ください： ◆コード領域 このエリアでは、創造的なレンダリングコードを記述できます。 Languageのオプションは、編集を完了した後に自動でプラグインパネル上の言語タイプを変更します。この設定はプリセットを保存する際にプリセットファイルに記録されます。(default)オプションは言語を変更しません。 ◆参照表 便利なコードをコピーして使用できる参照ドキュメントを提供しています。このドキュメントは現在、読み取り専用モードであり、編集できません。 ◆パラメータ設定 ここには、パラメータパネルの名前、デフォルト値、および言語設定が表示されます。パラメータ名やデフォルト値を変更したい場合は、下のParameter managerをクリックしてパラメータ管理器にアクセスできます。 パラメータ設定は、プリセットを保存する際にプリセットファイルに記録されます。 ◆プリセットリスト 上部のドロップダウンリストにはすべてのプリセットカテゴリが表示されます。プリセットを以下のように定義します： .pwp拡張子を持ち、プラグインの隣に置かれるJSON形式のファイルはプリセットカテゴリと見なされます。そのカテゴリ名はファイル名です。 プリセットカテゴリには、いくつかのプリセットデータが格納されています。 あるカテゴリのすべてのプリセットデータは、ドロップダウンリストの下のリストに表示されます。 ◆プリセット法則プレビュー リストで選択されたプリセットデータのコードデータがここに表示されます。このプリセットが希望するものである場合は、Replaceボタンをクリックして編集ウィンドウのコードを置き換えます。 テキスト部分のみを置換したい場合は、プリセットパラメータ設定プレビュー領域のApply when replaceを選択解除できます。 現在編集しているコードの前にプリセットコードを追加したい場合はボタンを、後ろに追加したい場合はBottom>>ボタンをクリックしてください。 ◆プリセットパラメータ設定プレビュー リストで選択されたプリセットデータのパラメータ設定データがここに表示されます。現在のパラメータを使用することを確認したら、Applyボタンをクリックしてください。 Apply when replaceオプションボックスは、上記のReplaceボタンをクリックした際に、現在のプリセットのパラメータ設定を自動で適用するかどうかを決定します。 "},"contents/Editor/ParameterWindow.html":{"url":"contents/Editor/ParameterWindow.html","title":"パラメータ　エディター","keywords":"","body":"パラメータエディター ワールドルールエディター上のParameter managerボタンをクリックして、パラメータエディターを起動します。起動すると以下のように表示されます： ルール 長いボックスには名前を入力し、短いボックスにはデフォルト値（10進数）を入力します。 Clear namesボタンは各エリアの名称をクリアします。一番下のClear all namesボタンはすべてのエリアの名称をクリアします。 Reset namesボタンは各エリアの名称をデフォルト名称にリセットし、一番下のReset all namesボタンはすべてのエリアの名称をデフォルト名称にリセットします。 Reset valueボタンは各エリアの数値をリセットし、一番下のReset all namesボタンはすべてのエリアの数値をリセットします。 注意：pointと3dpointの範囲は0~1であるべきです。例えば1280x720のレイヤー上で0.5, 0.5をpointのデフォルト値として使用する場合、PixelsWorldは自動的に640x360に換算してプラグインパネルUI上のpointコントロールに表示します。 パラメータ名コーディング言語 ピクセルワールドはutf-8とローカルエンコードに対応しており、パラメータ名は理論上、大部分のUnicode文字をサポートしています。しかし、Aeのエンコードサポートの問題から、プリセット内の名前データが異なる地域のシステムでは、サポートされていない文字が?（←クエスチョンマーク）に翻訳されることがあります（これは文字化けではありません）。 個人のアーティストの方は、命名言語を自由に設定できます。 所属チームを持つアーティストの方、特に国際交流を含むアート創作チームに所属している場合は、ASCII（通常は英字、数字、アンダースコアで構成）の表示可能な文字で構成されたパラメータ名を使用することをお勧めします。 "},"contents/Editor/SavePresets.html":{"url":"contents/Editor/SavePresets.html","title":"プリセット管理","keywords":"","body":"プリセット管理 プリセットの保存 世界ルールエディターで、Save as presetボタンをクリックし、名前を入力することでプリセットを保存できます。 注意：既存のプリセットリストにある名前を使用すると、上書きされます。 プリセットを上書き保存 世界ルールエディターで、Save as presetボタンをクリックし、リスト中に既に存在するプリセット名を入力して元のプリセットを上書きすることができます。 注意： この操作は元に戻せないため、バックアップを忘れずに。 異なるプリセットカテゴリーのプリセット名は互いに干渉しません。 プリセットの名前を変更 名前を変更したいプリセットをリストでダブルクリックし、REMOVEおよびSORT以外の名前を入力欄に入力します。 プリセットリストのソート プリセットリストの任意のプリセットをダブルクリックし、入力欄にSORTを入力します。 プリセットの削除 削除したいプリセットをリストでダブルクリックし、入力欄にREMOVEを入力します。 プリセットカテゴリーを追加 Preset listパネルのドロップダウンリスト横のAddボタンをクリックしてプリセットカテゴリーを追加します。 注意： 既存のカテゴリー名を新しいカテゴリー名として使用することはできません。 カテゴリーを追加すると、プラグインの横にプリセットファイルが作成されます。作成に失敗したり、次にAeを開いたときにプリセットファイルが消えてしまう場合、Aeに管理者モードを有効にしてピクセル世界がディスクを読んだり書き込んだりすることを許可してください。 プリセットフォーマット/プリセットファイル プリセットはUTF-8（リトルエンディアン）エンコードのJSONフォーマットで情報を保存しています。 プリセットファイルはプレーンテキストで保存されており、暗号化はされていません。 プリセットファイルはサードパーティのJSON編集ツールで修正可能です。しかし、プリセット構造を破損するリスクもあるため、推奨しません。 プリセットの投稿 公式チャネルを通じてプリセットを公開する意向がある場合、プリセットを次のメールアドレスに投稿してください：rly_pxx_123@sina.com。 定期的に受け取ったプリセットを統合し、投稿者リストをプラグインのAboutボタンのところで公開します。 "},"contents/Lua/LuaCode.html":{"url":"contents/Lua/LuaCode.html","title":"世界の中心Lua","keywords":"","body":"世界の中心Lua 第1章で紹介するのは、Luaという言語です。 * Luaは軽量で、高級、多パラダイムのプログラミング言語で、主に組込みアプリケーションで使用されます。 ——Wiki) バージョン : Lua5.3（完全な技術ドキュメントはこちら） 注意：PixelsWorld v3.2.0よりLua5.4を使用しています。 Luaは、式やAeスクリプトに非常に似た言語で、ピクセルワールドの中心としてすべてのモジュールをつなぐ役割を果たします。基本的な命令を数個覚えるだけで、ピクセルワールドが順番に図形を描画するように指示できます。 ピクセルワールドにおけるすべてのレンダリング命令は、この中枢であるLuaを通じて発行できます。例えば、Aeカメラとインタラクティブな立方体を描画したい場合、次のように入力します。 DrawCube.lua version3() move(width/2,height/2) dim3() cube(300) dim3()は3次元モードで描画を行うための関数です。 GLSLコードをレンダリングしたい場合、次のように入力します。 RunGlsl.lua version3() glsl([==[ void main(){ vec3 col = 0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4)); outColor = vec4(col,1.0); } ]==]) 間にGLSLコードを記述するだけで実行可能です。 shadertoyのコードを実行したい場合、次のように入力します。 RunShadertoy.lua version3() shadertoy([==[ void mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec2 uv = fragCoord/iResolution.xy; vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)); fragColor = vec4(col,1.0); } ]==]) 間にshadertoyのコードを記述するだけで実行可能です。 ここではLuaの能力範囲を示します： ピクセルデータの取得 ピクセルデータの記述 JavaScriptの実行 GLSLの実行 パラメータデータの取得 外部C言語ライブラリの実行 Luaモジュールのロード また、LuaはJavaScriptに非常に似ており、JavaScriptは学びやすい言語であるため、プログラミングの基礎がなくても短時間で習得できます。 PixelsWorldの構造 "},"contents/Lua/RunLua.html":{"url":"contents/Lua/RunLua.html","title":"Luaの実装","keywords":"","body":"Luaコードの実行 Lua (CPU & GPU) 言語に切り替える コードのインポート： hello.lua version3() a = 5+6 b = \"PixelsWorld\" c = \"is cool!\" d = time e = slider(0) f = \"5 + 6 = \" .. a .. \"\\nMessage : \" .. b .. \" \" .. c .. \"\\nCurrent time is : \" .. d .. \" (s)\\nValue of slider0 is : \" .. e print(f) a..b は変数aとbを文字列として結合します。 print() 画面にメッセージをレンダリングします。 slider() 指定されたパラメータの値を取得します。 各行の最後に ; を追加することができますが、必須ではありません。Luaは \\n（改行文字）を一行の終わりとして判断します。 最終的に画面の左上に出力情報が表示されます。 "},"contents/Lua/WriteLocalCode.html":{"url":"contents/Lua/WriteLocalCode.html","title":"ローカルコード","keywords":"","body":"ローカルでコードを書く もしピクセルワールド内蔵のエディターが気に入らない場合は、ローカルでtxtドキュメントを作成し、以下のコードでピクセルワールドにインポートすることができます。 コードファイルをシステムドライブ（C:\\ ドライブ）に置かないでください。 loadTxt.lua version3() runFile([[d:\\mycode.txt]]) -- 自分のパスに置き換えてください [[d:\\mycode.txt]]を使用する理由は、\"d:\\mycode.txt\"だと\\がエスケープされるためです。 ファイルの内容がテキストであれば、任意の拡張子（*.lua, *.code, *.magic）を使用できます。 コードをプロジェクトファイルの隣に配置したい場合は、以下のコードを使用できます。 loadTxt.lua version3() runFile( projectFolder .. [[mycode.txt]]) -- 自分のファイル名に置き換えてください 注意: projectFolderを使用する前提として、プロジェクトがローカルに保存されている必要があります。 まだ終わっていません！コードのリフレッシュを忘れずに ローカルでコードを打って保存した後、ピクセルワールドはすぐにはシーンに反映されません。Ctrl + Altを押しながら、プラグインパネルのLOGO画像をマウスでクリックすると、ピクセルワールドが新しいコードを読み込みに行きます。 このLOGO画像は一定の確率でランダムにスライドショーされます。収集を好むアーティストのために、多くの美しいLOGOデザインをここに用意しました。 "},"contents/Lua/LinkParameters.html":{"url":"contents/Lua/LinkParameters.html","title":"パラメータリンク","keywords":"","body":"リンクパラメータ 以下の関数を使用して、プラグインパネルのパラメータを呼び出します。 parameters.lua slider(id) -- 1つのdoubleを返す angle(id) -- 1つのdoubleを返す point(id) -- 2つのdoubleを返す point3d(id) -- 3つのdoubleを返す checkbox(id) -- 1つのbooleanを返す color(id) -- 3つのdoubleを返す layer(id,x,y) -- 4つのdoubleを返す 複数の値を返す場合、複数の変数を宣言して受ける必要があります。例えば、point()関数です。 point.lua version3() x,y = point(0) println('x is ' .. x) println('y is ' .. y) "},"contents/Lua/globals.html":{"url":"contents/Lua/globals.html","title":"グローバル変数","keywords":"","body":"グローバル変数 グローバル定数 PixelsWorldはユーザーが使用できる以下のグローバル定数を提供しています： const.lua PI -- 円周率 pi TPI -- 二倍円周率 two pi HPI -- 円周率の半分 half pi QPI -- 円周率の四分の一 quarter pi E -- 自然数 e PHI -- 黄金分割数 phi R2 -- ルート2 root 2 R3 -- ルート3 root 3 R5 -- ルート5 root 5 R7 -- ルート7 root 7 INPUT -- 入力マテリアル番号 -1 TEMP -- キャッシュマテリアル番号 -2 OUTPUT -- 出力マテリアル番号 -3 PARAM0 -- 第0層マテリアル 0 PARAM1 -- 第1層マテリアル 1 PARAM2 -- 第2層マテリアル 2 PARAM3 -- 第3層マテリアル 3 PARAM4 -- 第4層マテリアル 4 PARAM5 -- 第5層マテリアル 5 PARAM6 -- 第6層マテリアル 6 PARAM7 -- 第7層マテリアル 7 PARAM8 -- 第8層マテリアル 8 PARAM9 -- 第9層マテリアル 9 platform -- プラットフォーム：Windows10: 0 他のプラットフォームは現在サポートされていません host -- ホストプログラム：Ae: 0 現在他のホストはサポートされていません グローバル変数 PixelsWorldは以下のいくつかのAeで取得された変数をユーザーに提供しています： [cached]とマークされたものはメモリがクリアされない限り再レンダリングを引き起こさないグローバル変数です。 globalvars.lua depth -- カラーデプス，8，16，32 width -- 入力レイヤーの幅 height -- 入力レイヤーの高さ time -- 現在の時間(s) duration -- 所在レイヤーの持続時間(s) [cached] inpoint -- 所在レイヤーのインポイント時間(s) [cached] compTime -- 合成時間(s) pluginFolder -- プラグイン所在ディレクトリ(utf8) projectName -- プロジェクト名(utf8) projectPath -- プロジェクトパス(utf8) projectFolder -- プロジェクト所在フォルダのパス(utf8) ds_width -- ダウンサンプル後の合成幅 ds_height -- ダウンサンプル後の合成高 origin_x -- 入力レイヤーの左上がレイヤー座標系のX座標 origin_y -- 入力レイヤーの左上がレイヤー座標系のY座標 layerName -- 現在のレイヤーのレイヤー名，レイヤー名が設定されていない場合は空 (v3.6.4+) [cached] layerSourceName -- 現在のレイヤーのソース名、通常は空でない (v3.6.4+) [cached] compName -- 現在の合成名 (v3.6.4+) [cached] fps -- フレームレート グローバル変数の印刷 以下のコードをLuaモードで実行してグローバル変数（グローバル関数を含む）を印刷します。 printGlobals.lua version3() in2out() for k, v in pairs(_G) do print(k) print(\" \" .. type(v) , .5,.5,.5) print(\" \".. tostring(_G[k]),0,1,1) println(\"\") end "},"contents/Lua/FuncList.html":{"url":"contents/Lua/FuncList.html","title":"関数一覧表","keywords":"","body":"関数一覧 以下は、PixelsWorldのLuaモードで定義されているすべての関数です。 必須の宣言関数 version3 パラメータ取得関数 slider, angle, point, point3d, checkbox, color, layer 情報出力関数 print, println, alert 変換関数 move, scale, rotate, rotateX, rotateY, rotateZ, twirl beginGroup, endGroup, beginGlobal, endGlobal global2local, local2global, global2screen, screen2global getTransformMatrix 描画関数 図形 tri, quad, rect, circle, ellipse, par, line cube, tet, cone, ball, tube image, imageAlign, imageAnchor text, textSize, textFont, textAlign, textAnchor, textAlignOuter, textInterval, textAdvanceScale coord, grid poly, setPoly background, in2out 描画属性制御 dim2, dim3 perspective, noPerspective fill, noFill, stroke, noStroke, dot, noDot wireframe, noWireframe blendAlpha, noBlendAlpha back, noBack pure, phong, anime rgba, depth, normal setDepth ライト newLight, delLight, getLightInfo activateLight, deactivateLight, getActivatedLight, setActivatedLight fetchLight ambientLight (legacy), pointLight (legacy), parallelLight (legacy) clearLight (legacy), getLight (legacy) カメラ aeCamera, lookAt, viewSpace ストロークの詳細 strokeWidth, strokeDivision, strokeGlobal, strokeLocal 点描画の詳細 dotRadius, dotDivision, dotGlobal, dotLocal 出力の詳細 smooth, noSmooth テクスチャ操作 newTex, delTex, getSize, swapTex, drawTo, castTex, blendTex, copyTex, savePNG, loadPNG, saveEXR, loadEXR, rotateTex, flipTex, resizeTex, trimTex ツール r2d, d2r map clamp step smoothStep bezier rgb2hsl,hsl2rgb,rgb2hsv,hsv2rgb,rgb2cmy,cmy2rgb,rgb2cmyk,cmyk2rgb,cmy2cmyk,cmyk2cmy,hsl2hsv,hsv2hsl utf8ToLocal, localToUtf8 getGLInfo, getDrawRecord, getStatus getAudio loadString saveString ピクセル読写関数 getColor, setColor, getSize, コード実行関数 shadertoy, glsl, cmd, lua, runFile, txt 詳細な説明 version3 version3() 関数はLuaモードで必ず最初の行に宣言する関数です。この関数の役割は、pw3というテーブル下の全ての関数をグローバルスコープに展開することです。もしこの行がなければ、すべてのPixelsWorldが提供する関数を呼ぶときにpw3.という接頭辞を付ける必要があります。例えば、これから説明するprintln()関数はpw3.println()と書く必要があります。逆に、最初の行でversion3()を呼び出した場合は、pw3.の接頭辞を省略できます。これは、コードの後方互換性を持たせるために設計された関数です。Luaレンダリングモードではどんな場合でも、最初の行でversion3()の呼び出しを追加することをお勧めします。 version3.lua version3() println(\"Hello PixelsWorld! \") without_version3.lua pw3.println(\"Hello PixelsWorld! \") print print(str),print(str,brightness),print(str,r,g,b),print(str,r,g,b,a)は、画面の左上に情報を出力する関数です。 print.lua version3() print(\"Hello PixelsWorld! \") str = \"Hello, I am colorful PixelsWorld! \" for i=1,#str do local c = str:sub(i,i) local phase = math.sin(i/#str*TPI + time*10) / 2 + .5 print(c,phase,1-phase,1,1) end println println(str),println(str,brightness),println(str,r,g,b),println(str,r,g,b,a)は、画面の左上に情報を出力し、出力後改行する関数です。 println.lua version3() println(\"Hello PixelsWorld! \") str = \"Hello, I am colorful PixelsWorld! \" for i=1,#str do local c = str:sub(i,i) local phase = math.sin(i/#str*TPI + time*10) / 2 + .5 -- println(c,phase,1-phase,1,1) print(c,phase,1-phase,1,1) end alert alert(str)は画面の左上に警告情報を出力する関数です。現在、この関数はprintln(str,1,1,0,1)と同等です。 alert.lua version3() alert(\"Warning: Write your message here! \") move move(x,y),move(x,y,z)は、画筆の座標を平行移動させる関数です。 すべての変換は、現在の画筆座標を基準に行われます。 例えば、次の例： move.lua version3() coord() -- 変換前の画筆位置を表示 move(100,0) coord() -- 1回目の変換後の画筆位置を表示 move(0,100) coord() -- 2回目の変換後の画筆位置を表示 最終的に画筆は(100,100,0)の位置にあります。 scale scale(ratio),scale(x,y),scale(x,y,z)は、画筆の座標を拡大縮小する関数です。 すべての変換は、現在の画筆座標を基準に行われます。 scale.lua version3() move(100,100) scale(2) rect(50,25) no_scale.lua version3() move(100,100) --scale(2) rect(50,25) rotate rotateX rotateY rotateZ rotate(theta)は、画筆座標をthetaラジアンだけ回転させる関数です。rotateX(theta)はX軸周りに回転させる関数で、rotate(theta)はrotateZ(theta)と実質的に同じです。 すべての変換は現在の画筆座標を基準に行われます。 ラジアンに慣れていない場合、d2r(degree)を用いて角度をラジアンに変換できます。例えば：rotate(d2r(90))は90度回転します。 rotate_degree.lua version3() move(100,100) rotate(d2r(45)) rect(50,25) rotate_radian.lua version3() move(100,100) rotate(PI/4) rect(50,25) rotateX.lua version3() dim3() move(100,100) grid() coord() rotateX(d2r(45)) cube(50,25,10) rotateY.lua version3() dim3() move(100,100) grid() coord() rotateY(d2r(45)) cube(50,25,10) rotateZ.lua version3() dim3() move(100,100) grid() coord() rotateZ(d2r(45)) cube(50,25,10) twirl twirl(theta,x,y,z)は軸(x,y,z)に沿ってthetaラジアンだけ画筆を回転させる関数です。例えば、上記のrotateX(theta)はここではtwirl(theta,1,0,0)に相当します。 すべての変換は現在の画筆座標を基準に行われます。 twirlは四元数回転の行列実装です。 twirl.lua version3() dim3() move(100,100) grid() coord() stroke(1,1,0) line(-50,-50,-50,50,50,50) stroke(0,0,0) twirl(d2r(90),1,1,1) cube(50,25,10) beginGroup endGroup beginGroup(),endGroup()は親子関係を作成するための関数です。beginGroup()からendGroup()の間に行われた変換（move,scale,rotate,twirl）はendGroup()の後で取り消されます。 beginGroup(mat)は親子関係を作成し、4x4行列matをシーンにプッシュします。（変換行列を取得するにはgetTransformMatrixを使用できます。） ProcessingのpushMatrix()やpopMatrix()に相当します。 例えば、以下の2つのコードは等価です。 group.lua version3() for i = 1,6 do beginGroup() move(i*25,i*25) rotate(d2r(15*i)) rect(25) endGroup() end without_group.lua version3() for i = 1,6 do move(i*25,i*25) rotate(d2r(15*i)) rect(25) rotate(d2r(-15*i)) move(-i*25,-i*25) end beginGlobal endGlobal beginGlobal,endGlobalの間にある描画関数は、一時的にグローバル座標系で描画されます。 beginGlobal.lua version3() move(100,100) fill(0,1,0) -- 緑 rect(50) -- (100,100,0)に描画 beginGlobal() fill(1,0,0) -- 赤 rect(50) -- (0,0,0)に描画 endGlobal() move(100,100) fill(0,0,1) -- 青 rect(50) -- (200,200,0)に描画 global2local global2local(x,y,z)はグローバル座標をローカル座標に変換し、3つのdoubleを返します。 global2local.lua version3() move(100,100) rect(25) move(0,50) rotate(d2r(30)) coord() x,y,z=global2local(100,100,0) println(\"The local coordinate of the rectangle is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") local2global local2global(x,y,z)は、ローカル座標をグローバル座標に変換します。3つのdoubleを返します。 local2global.lua version3() move(100,100) move(0,50) rotate(d2r(30)) coord() move(25,50) rect(25) x,y,z=local2global(0,0,0) println(\"The global coordinate of the rectangle is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") global2screen global2screen(x,y,z)は、グローバル座標をスクリーン座標に変換します。3つのdoubleを返します。 この変換は投影の影響を受けます global2screen.lua version3() dim3() move(100,100,0) move(0,50,0) rotateZ(d2r(30)) coord() move(25,50,0) cube(25) x,y,z=global2screen(local2global(0,0,0)) println(\"The screen coordinate of the rectangle is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") screen2global screen2global(x,y,z)は、スクリーン座標をグローバル座標に変換します。3つのdoubleを返します。 この変換は投影の影響を受けます screen2global.lua version3() dim3() x,y,z=screen2global(0,0,0) println(\"The global coordinate of the camera is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") getTransformMatrix getTransformMatrix()は、列主体の4x4変換行列を返します。この変換行列はbeginGroup(mat)で適用できます。 mat[i][j]で第i列第j行の要素にアクセスできます。（i,jの範囲は1~4です） 例： matrix.lua version3() dim3() beginGroup() move(width/3,height/3) twirl(d2r(30),1,1,1) cubetransform = getTransformMatrix() endGroup() beginGroup(cubetransform) cube(50) endGroup() tri tri(radius)は半径radiusの円に内接する正三角形を、画筆座標のy軸の正方向に向けて作成します。 tri()はtri(100)と等価です。 tri(w,h)は底辺w、高さhの二等辺三角形を作成します。 tri(p1x,p1y,p2x,p2y,p3x,p3y)はp1,p2,p3の2つの2次元点を頂点とする三角形を作成します。 tri(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z)はp1,p2,p3の3つの3次元点を頂点とする三角形を作成します。 立体的な三角形を観察するには、version3()関数の後にdim3()を追加し、Aeレイヤーでカメラを作成して観測する必要があります。 前3種類の方法で構成される三角形の法線は画筆座標のz軸の負の方向をデフォルトとし、後2種類ではcross(p1-p2,p3-p2)により几何法線が決定されます。 関数名はtriangleの略です。 tri1.lua version3() move(width/2,height/2) tri(100) tri5.lua version3() dim3() move(width/2,height/2) tri(0,0,100,50,0,0,0,50,0) quad quad(p1x,p1y,p2x,p2y,p3x,p3y,p4x,p4y) quad(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z,p4x,p4y,p4z) p1,p2,p3の順序で最初の三角形を描き、p1,p3,p4の順序で第二の三角形を描きます。 quad.lua version3() move(200,100) quad(0,0,75,0,50,40,0,15) rect rect(size)でサイズsizeの正方形を描きます。 rect()はrect(100)と等価です。 rect(width,height)で幅width、高さheightの長方形を描きます。 長方形は画筆座標の中心を対角線の交点として生成されます。 関数名はrectangleの略です。 rect.lua version3() move(200,100) rect(100,75) circle circle(radius)は半径radiusの円を描きます。 circle()はcircle(100)と等価です。 circle(radius, div)で半径radius、分段数divの円を描きます。 デフォルト分段は128です。 circle.lua version3() move(100,100) fill(1,0,0) circle(25) move(100,0) fill(0,1,0) circle(25,10) move(100,0) fill(0,0,1) circle(25,3) ellipse ellipse(radiusx,radiusy)でx半径radiusx、y半径radiusyの楕円を描きます。 ellipse()はellipse(100,100)と等価です。 ellipse(radiusx,radiusy,div)でx半径radiusx、y半径radiusy、分段divの楕円を描きます。 デフォルト分段は128です。 ellipse.lua version3() move(100,100) fill(1,0,0) ellipse(25,15) move(100,0) fill(0,1,0) ellipse(25,15,10) move(100,0) fill(0,0,1) ellipse(25,15,4) line line(p1x,p1y,p2x,p2y)で線分を描きます。 line(p1x,p1y,p1z,p2x,p2y,p2z)で3次元線分を描きます。 line()はline(0,0,0,100,100,100)と等価です。 線の色はstroke(r,g,b)で制御されます。 線の太さはstrokeWidth(width)で制御されます。 線はデフォルトでレンダリングされます。線のレンダリングをオフにしたい場合はnoStroke()、オンにする場合はstroke()を使用します。 line.lua version3() move(200,100,0) stroke(1,0,0) line(0,0,0,50) move(100,0,0) stroke(0,1,0) line(0,0,0,50) move(100,0,0) stroke(0,0,1) line(0,0,0,50) line_circle.lua version3() math.randomseed(1) num = 32 move(width/2,height/2) for i=1,num do beginGroup() rotateZ(d2r(360/num*i)) strokeWidth(math.random()*3) line(0,0,100,0) endGroup() end par par(x)で位置(x,0,0)に点を描きます par(x,y)で位置(x,y,0)に点を描きます par(x,y,z)で位置(x,y,z)に点を描きます par()はpar(0,0,0)と等価です 点のレンダリングはデフォルトで無効化されています。dot()を使って有効にします。また、noDot()を呼び出して無効化することもできます 点の半径はdotRadius(radius)で制御されます 点の色はdot(r,g,b)で制御されます 点が変換で圧縮されたり縮小されたりしないようにするには、dotGlobal()を使用します。デフォルトでは点はdotLocal()モードでレンダリングされます。 par.lua version3() dot() dotRadius(3) move(200,100) par() dot(1,0,0) dotRadius(7) move(100,0) par() cube cube(size)で辺長がsizeの立方体を描きます cube(sizex,sizey,sizez)で幅size、高さsizey、奥行きsizezの長方体を描きます cube()はcube(100)と等価です cube() 長方体の法線はデフォルトで外向きです。負の長さを入力したり、負の符号のscale()を使用すると法線が内向きになります cube.lua version3() dim3() move(200,100,0) rotateY(d2r(30)) rotateX(d2r(30)) cube(40,25,10) tet tet(radius)でradiusを球面半径とする内接正四面体を描きます tet()はtet(50)と等価です tet(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z,p4x,p4y,p4z)でp1,p2,p3,p4を頂点に持つ四面体を描きます 3番目の方法で描かれる四面体の法線は、指定された順序に従います。具体的には、p1,p2,p3;p2,p1,p4;p3,p2,p4;p1,p3,p4.の順で四つの三角面が描かれます。三角面の法線の方向についてはtriを参照してください 関数名はtetrahedronの略です tet.lua version3() dim3() move(200,100,0) tet(0,0,0, 100,0,0, 0,100,0, 30,20,-50 ) cone cone(size)で底辺半径がsizeで高さが2*sizeの円錐を描きます cone()はcone(50)と等価です cone(radius,height)で半径radius高さheightの円錐を描きます cone(radius,height,div)で半径radius高さheightの分段数がdivの円錐を描きます 円錐のデフォルトの分段数は64です 分段数が16を超える場合、円錐面のエッジと底辺の頂点は隠されます 負の入力値や負の符号のscale()を使用すると法線が内向きになる可能性があります cone.lua version3() dim3() move(100,100,0) beginGroup() rotateY(d2r(60)) cone(25) endGroup() move(100,0,0) beginGroup() rotateY(d2r(60)) noStroke() cone(25) endGroup() move(100,0,0) beginGroup() rotateY(d2r(60)) stroke(1,0,0) dot(1,1,0) dotRadius(3) cone(30,100,12) endGroup() ball ball(radius)で半径radiusの3次元球を描きます ball()はball(50)と等価です ball(radius,level)で半径radiusと細分レベルlevelの球を描きます デフォルトのレベルは4です レベルは0以上である必要があります レベルが0の場合、正八面体になります レベルが2を超える場合、エッジと頂点は隠されます 負の入力値や負の符号のscale()を使用すると法線が内向きになる可能性があります ball.lua version3() dim3() move(200,100,0) beginGroup() rotateY(d2r(60)) ball(25) endGroup() move(100,0,0) beginGroup() rotateY(d2r(60)) stroke(0,0.25,0.5) dot(0,0.5,1) dotRadius(3) ball(30,2) endGroup() tube tube(size)で半径size高さが2*sizeの円柱を描きます tube()はtube(50)と等価です tube(radius,height)で半径radius、高さheightの円柱を描きます tube(radius1,radius2,height)で原点寄りの底面半径がradius1、もう一方の底面半径がradius2、高さがheightの円柱を描きます tube(radius1,radius2,height,div)で、4番目の関数に分段数の制御を追加します。 tube(radius1,radius2,height,div,needMesh)で、5番目の関数に「2つの円面をレンダリングするかどうか」のBoolean値を追加します。 tube(radius1,radius2,height,div,needMesh1,needMesh2)で、6番目の関数に「近い側の底面をレンダリングするかどうか」のneedMesh1、「遠い側の底面をレンダリングするかどうか」のneedMesh2をBoolean値として追加します。 divのデフォルト値は64です needMeshのデフォルト値はtrueです 分段数が16を超える場合、円柱面のエッジと底面の頂点は隠されます 負の入力値や負の符号のscale()を使用すると法線が内向きになる可能性があります tube.lua version3() dim3() move(200,100,0) beginGroup() rotateY(d2r(60)) tube(25) endGroup() move(100,0,0) beginGroup() rotateY(d2r(60)) stroke(1,0.25,0.5) dot(0,0,1) dotRadius(3) tube(30,25,50,8) endGroup() image image(id,width,height)で幅width、高さheightの画像をシーンに描画します idはテクスチャ番号であり、PARAM0~PARAM9はプラグインパネルのレイヤーコントロールから取得されたテクスチャであり、INPUTはプラグインの入力画像、OUTPUTは出力画像です。 idがOUTPUTに指定された場合、OUTPUTは現在描画されているキャンバスメディアであり、キャンバスのスクリーンショットが発生します。そのため、他のパラメータよりもやや遅くなります。 この関数とin2out(id)の違いは、image(id,width,height)が描画ペン座標に基づいてシーンの深度情報と相互作用する画像を生成する点です。つまり、画像はデフォルトで上下が反転して描画されます。Aeのデフォルト座標系ではy軸が下向きであるため、前にrotateX(PI)を追加して正します（scale(1,-1)を使用することは推奨しません。これは後に描かれる他の図形で法線エラーを引き起こす可能性があります）。in2out(id)は深度情報を無視し、ピクセルを現在のキャンバスに直接書き込みます（上下反転問題はありません）。 以下の例では、入力画像と立方体が相互に交錯する描画を示します。 render_image.lua version3() dim3() move(width/2,height/2) twirl(d2r(45),-1,1,0) beginGroup() rotateX(d2r(180)) image(INPUT,width,height) endGroup() twirl(d2r(60),1,1,1) cube() imageAlign v3.3.0新関数。 imageAlign(rule)でimage関数の画像の向きを変更します。ruleは以下のルールに従います： ruleは長さ4の文字列です 第1文字は+または-です 第2文字はx, y, zのいずれかです 第3文字は+または-です 第4文字はx, y, zのいずれかです ruleは画像のUV座標（左下隅を原点とする）を描画ペン座標のどの軸に合わせるかを表します。デフォルトではruleは\"+x+y\"で、u軸がxの正の方向に、v軸がyの正の方向に合わせられます。 imageAlign.lua version3() dim3() move(100,100,0) coord() image(PARAM0,128,128) move(150,0,0) coord() imageAlign(\"+x-y\") image(PARAM0,128,128) move(150,0,0) coord() imageAlign(\"+z-y\") image(PARAM0,128,128) imageAnchor v3.5.0の新関数。 imageAnchor(u,v)は画像のアンカーポイントの位置を指定するために使用します。 imageAnchor(a)はimageAnchor(a,a)の短縮版です。 text v3.5.0の新関数 text(str)は画面上に文字をレンダリングするために使用します。 text.lua version3() move(width/2,height/2) textAlign(\"+x-y\") text(\"Hello PixelsWorld!\") また、以下の関数を使用して文字スタイルを変更することができます。 文字の塗りつぶし色：fill(r,g,b) 文字の線の色：stroke(r,g,b) 塗りつぶしの無効化：noFill() 線の無効化：noStroke() 線の太さ：strokeWidth(width) フォント：textFont(fontFileName) フォントサイズ：textSize(size) フォント間隔：textInterval(dx,dy) 文字幅の等比縮小：textAdvanceScale(rx,ry) textSize v3.5.0の新関数 textSize(size,resolution)は次に描画する文字のサイズを設定します。sizeは文字サイズを制御し、resolutionは文字の解像度を制御します。 textSize(size)はtextSize(size,size)と等価です。 textSize.lua version3() textAlign(\"+x-y\") textAnchor(0,1) for i=1,13 do local sz = i + 8 textSize(sz) text(\"~MiLai visual performance group~\") move(0,sz + 4) end textFont v3.5.0の新関数 textFont(fontFileName)は次に描画する文字のフォントを設定します。fontFileNameはC:\\Windows\\Fontsフォルダにあるフォントファイルのファイル名（右クリックして、プロパティからフォントファイルのファイル名を確認できます。例：textFont(\"arial.ttf\")）。 フォントファイルの完全なパスを入力することもできます。これにより任意の場所のフォントを読み込むことが可能です。（例：textFont([[D:\\MyFolder\\arial.ttf]])） textFont.lua version3() textAlign(\"+x-y\") textAnchor(0,1) textSize(20) font_list={ {\"arial.ttf\",\"The quick brown fox jumps over the lazy dog. \"}, {\"MATURASC.TTF\",\"The quick brown fox jumps over the lazy dog. \"}, {\"KUNSTLER.TTF\",\"The quick brown fox jumps over the lazy dog. \"}, {\"msmincho.ttc\",\"色は匂へど　散りぬるを\"}, {\"UDDigiKyokashoN-R.ttc\",\"我が世誰ぞ　常ならむ\"}, {\"STXINGKA.TTF\",\"人生得意须尽欢 莫使金樽空对月\"}, {\"msjh.ttc\",\"山氣日夕佳 飛鳥相與還\"}, {\"simsun.ttc\",\"吥葽 莣記莪、伱知道 莪 拿起伱 就 倣吥丅。\"}, {\"STZHONGS.TTF\",\"○●対沵倾注ㄋ珴所侑旳温柔︶ㄣ\"}, } for i=1,#font_list do textFont(font_list[i][1]) text(font_list[i][2]) move(0,28) end textAlign v3.5.0の新関数 textAlign(rule)はフォントのレンダリング方向を設定するために使用され、ruleはimageAlign(rule)内のルールに従います。 詳しくはimageAlignを参照>>> textAnchor v3.5.0の新関数 textAnchor(x,y)はフォントのアンカーポイント位置を設定するために使用します。 詳しくはimageAnchorを参照>>> textAlignOuter v3.5.0の新関数 textAlignOuter(flag)は文字を外輪郭で整列するかどうかを設定します。flagはブール値です。 textInterval v3.5.0の新関数 textInterval(x,y)は文字の間隔を設定します。デフォルトはx:0, y:0です。 textAdvanceScale v3.5.0の新関数 textAdvanceScale(rx,ry)は文字の進捗倍率を制御します。デフォルトはrx:1, ry:1です。 coord coord()は現在の描画ペンの座標を可視化します。 coord.lua version3() move(100,100) coord() move(150,0) coord() rotate(d2r(30)) move(50,0) scale(2,1) coord() grid grid()は現在の描画ペンの座標がいるxy平面を100x100のグリッドサイズで可視化します。 grid.lua version3() move(width/2,height/2) rotate(d2r(30)) grid() setPoly setPoly(obj)は描画する物体情報を事前に解析します。設定後にpoly()を呼び出すことで、設定した物体を迅速に描画できます。 同じobjをシーン内に複数回描画する場合、この関数を使用してobjを事前に設定すると効果的です。 objの構造についてはPoly章を参照してください。 background background(brightness), background(r,g,b), background(r,g,b,a)は現在のキャンバスを対応する色で塗りつぶします。 注意：以前に描画した形状がある場合、それらは上書きされます。 background.lua version3() background(1,1,0) in2out in2out(id)は第id個のレイヤーパラメータを背景として設定します。 in2out()はin2out(INPUT)と等価で、入力レイヤーを背景とします。 idの範囲：PARAM0~PARAM9またはINPUT。 dim2 dim2()は2Dモードで描画を行います。デフォルトではこれが有効になっており、通常は呼び出す必要はありません。 PixelsWorldの本質で、2Dモードは深度情報を持たない正交3Dモードです。 dim3 dim3()は3Dモードで描画を行います。version3()の直後に宣言することを推奨します。 注意：合成サイズと異なるレイヤーに3D形状をレンダリングする場合、viewSpaceを使用してカメラの遠平面サイズを変更してください。そうしないと、予期しない位置結果が得られる場合があります。 perspective perspective()は透視投影を使用してレンダリングを行います。物体は近くが大きく、遠くが小さいという規則に従います。viewSpaceを使用してカメラ情報を調整したり、lookAtを使用してカメラ位置を調整することができます。 dim3()を呼び出した場合、透視モードはデフォルトで有効になります。 noPerspective noPerspective()は直交投影を使用してレンダリングを行います。物体の相互に平行なエッジがレンダリングビューでも平行になります。 noPerspective.lua version3() dim3() n = 20 move(100,100,0) beginGroup() rotateX(d2r(85)) for i=1,n do move(0,300,0) fill(i/n,1-i/n,1) cube(50) end endGroup() move(300,0,0) noPerspective() beginGroup() rotateX(d2r(85)) for i=1,n do move(0,300,0) fill(i/n,1-i/n,1) cube(50) end endGroup() fill fill()で塗りつぶしを有効にします。デフォルトでは有効です。 fill(brightness), fill(r,g,b), fill(r,g,b,a)は塗りつぶしを有効にし、塗りつぶし色を設定します。 注意：3Dモードでは、塗りつぶしの透明値を1より小さく設定する場合、遠方から近方へ順に物体をレンダリングする必要があります。そうしないと前方の透明物体が後方の物体を完全に遮ることがあります。（これはOpenGL描画の特性です。）noFill noFill()で塗りつぶしを無効にします。 fill.lua version3() move(200,100,0) fill(1,0,0) rect(50) move(100,0,0) fill(1,1,0) rect(50) move(100,0,0) noFill() rect(50) stroke stroke()は描画線を有効にします。デフォルトでは有効です。 stroke(brightness), stroke(r,g,b), stroke(r,g,b,a)は描画線を有効にし、線の色を設定します。 noStroke noStroke()で描画線を無効にします。 stroke.lua version3() fill(0) move(200,100,0) stroke(1,0,0) rect(50) move(100,0,0) stroke(1,1,0) rect(50) move(100,0,0) noStroke() rect(50) dot dot()で頂点レンダリングを有効にします。デフォルトでは無効です。 dot(brightness), dot(r,g,b), dot(r,g,b,a)は頂点レンダリングを有効にし、頂点レンダリングの色を設定します。 noDot noDot()で頂点レンダリングを無効にします。 dot.lua version3() fill(1) move(200,100,0) stroke(1,0,0) rect(50) move(100,0,0) dot(1,1,0) rect(50) move(100,0,0) noDot() rect(50) wireframe wireframe()でワイヤーフレームモードを有効にします。 noWireframe noWireframe()でワイヤーフレームモードを無効にします。 wireframe.lua version3() n=8 dim3() move(width/2, height/2) for i=1,n do if i>n//2 then wireframe() else noWireframe() end beginGroup() rotateZ(d2r(i*360/n)) move(100,0,0) fill(i/n,1-i/n,1) ball(30,1) endGroup() end blendAlpha blendAlpha()で混色を有効にします。 noBlendAlpha noBlendAlpha()で混色を無効にします。 blendAlpha.lua version3() castTex(OUTPUT,INPUT) move(200,100,0) fill(1,0,0,0.2) rect(80) move(100,0,0) noBlendAlpha() fill(1,0,0,0.2) rect(80) back 透明色を含む場合、物体の背面を表示します。デフォルトでは無効です。 noBack noBack()で背面レンダリングモードを無効にします。 back.lua version3() dim3() fill(1,0,0,0.2) rotateX(d2r(30)) rotateY(d2r(-15)) move(200,180,0) cube(80) move(150,0,0) back() cube(80) pure pure()で純色モードでシーンをレンダリングします。デフォルトで有効です。 anime, phong, pureの3つの材質は同時に適用できず、そのうち1つを有効にすると他は無効になります。 phong phong(ambient,diffuse,specular,specularPower)はフォンモードに切り替え、環境光反射強度をambient、明面拡散反射強度をdiffuse、ハイライト強度をspecularに設定します。specularPowerはハイライトの減衰度を設定するためのもので、この項目が大きいほどハイライトの減衰が速くなります。 phong()はフォン材質モードに切り替えますが、設定は変更しません。 デフォルトではシーンに光源がないため、光源を取得するためにgetLight()、ambientLight()、parallelLight()、pointLightを使用する必要があります。 光源がある場合でも物体が純黒色でレンダリングされる場合、normalを呼び出して法線が正しいか確認してください。 各引数の初期値は：ambient:1, diffuse:1, specular:1, specularPower:1 anime, phong, pureの3つの材質は同時に適用できず、そのうち1つを有効にすると他は無効になります。 使用前にdim3()を実行してください。 phong.lua version3() dim3() move(width/2,height/2,0) grid() coord() n=10 beginGroup() move(0,0,-100) pointLight() endGroup() for i=1,n do beginGroup() rotateZ(d2r(i*360/n)) move(100,0,0) fill(i/n,1-i/n,1) if(i anime anime(ambient,diffuse,specular,specularPower,diffuseThreshold,specularThreshold) anime()はアニメ風材質モードに切り替えますが、設定は変更しません。 アニメ風材質モードはphongを基にしています。そのため、最初の4項目の引数：ambient, diffuse, specular, specularPowerはphongと同じで、残りの2つの引数diffuseThresholdは、散乱反射の閾値を設定します。散乱反射の輝度が閾値を超える場合は明るい面として設定され、閾値以下の場合は暗い面として設定されます。同様に、specularThresholdはハイライトの閾値を担当します。 アニメ風材質モードはアンチエイリアス処理が最適化されており、アンチエイリアスを有効にしている場合（デフォルトで有効）、光影の境界線が滑らかに処理されます。プラグインパネルでのアンチエイリアス設定を無効にすることで、光影の境界線のアンチエイリアス処理を無効にできます。 各項目の初期値は：ambient:1, diffuse:1, specular:1, specularPower:1, diffuseThreshold:0.5, specularThreshold:0.8 anime, phong, pureの3つの材質は同時に適用できず、そのうち1つを有効にすると他は無効になります。 使用前にdim3()を実行してください。 anime.lua version3() dim3() move(width/2,height/2,0) grid() coord() n=10 beginGroup() move(0,0,-100) pointLight() endGroup() for i=1,n do beginGroup() rotateZ(d2r(i*360/n)) move(100,0,0) fill(i/n,1-i/n,1) if(i rgba rgba()はRGBA直接出力モードで、デフォルトで有効です。 rgba, depth, normalは同時に成立しない3つのモードのうち1つを有効にすると他の2つは無効になります。 このモードでは材質を使用できます。 rgba.lua version3() dim3() background(1) move(width/2,height/2,0) n=10 beginGroup() move(0,0,-100) pointLight() endGroup() rgba() -- depth() -- normal() noStroke() for x=1,n do for y=1,n do for z=1,n do beginGroup() fill(x/n,y/n,z/n) move(map(x,1,n,-n/2,n/2)*50,map(y,1,n,-n/2,n/2)*50,map(z,1,n,-n/2,n/2)*200) ball(10,2) endGroup() end end end depth depth(blackDistance, whiteDistance)は深度を輝度情報として出力するモードです。たとえば深度図を出力したい場合、blackDistanceとwhiteDistanceを指定することで、カメラからの距離がどの程度で黒色または白色として出力するかを設定できます。その間の距離については、ピクセルワールドが線形補間を行いグレースケールで描画します。blackDistanceとwhiteDistanceを同じ値に設定すると、設定された値を閾値として純黒または純白を出力します。 rgba, depth, normalは同時に成立しない3つのモードのうち1つを有効にすると他の2つは無効になります。 このモードでは材質が無視されます。 使用前にdim3()を実行してください。 depth.lua version3() dim3() background(1) move(width/2,height/2,0) n=10 beginGroup() move(0,0,-100) pointLight() endGroup() -- rgba() depth() -- normal() noStroke() for x=1,n do for y=1,n do for z=1,n do beginGroup() fill(x/n,y/n,z/n) move(map(x,1,n,-n/2,n/2)*50,map(y,1,n,-n/2,n/2)*50,map(z,1,n,-n/2,n/2)*200) ball(10,2) endGroup() end end end normal normal(faceToCamera, normalize)はnormalモードに切り替え、faceToCameraとnormalize変数を変更します。 normal(faceToCamera)はnormalモードに切り替え、faceToCamera変数のみを変更します。 normal()はnormalモードに切り替えるだけです。 faceToCameraはブール値で、カメラ視点を基準にnormalを生成するかどうかを制御します。 normalizeはブール値で、正規化（長さが1の）normalを出力するか指定します。 初期値：faceToCamera:true, normalize:true。 rgba, depth, normalは同時に成立しない3つのモードのうち1つを有効にすると他の2つは無効になります。 このモードでは材質が無視されます。 使用前にdim3()を実行してください。 normal.lua version3() dim3() background(.5,.5,1) move(width/2,height/2,0) n=10 beginGroup() move(0,0,-100) pointLight() endGroup() -- rgba() -- depth() normal() noStroke() for x=1,n do for y=1,n do for z=1,n do beginGroup() fill(x/n,y/n,z/n) move(map(x,1,n,-n/2,n/2)*50,map(y,1,n,-n/2,n/2)*50,map(z,1,n,-n/2,n/2)*200) ball(10,2) endGroup() end end end setDepth setDepth(id, blackDistance, whiteDistance)は、指定されたid上の材質の赤色チャンネルを読み取り、チャンネル値が0の部分をblackDistanceに、1の部分をwhiteDistanceに設定し、その材質を深度テスト材質に適用します。 3Dソフトウェアからレンダリングした深度シーケンスをこの関数を通じてPixel Worldにインポートすることができます。これにより、Pixel Worldは他のレイヤーと深度の相互作用を行うことができます。 使用前にdim3()を実行してください。 有効なid: INPUT, PARAM0 ~ PARAM9 newLight 3.7.0で新たに追加された関数。 newLightはライトインスタンスの作成を担当します。現在、3種類の組み込みライトインスタンスがあります：全局光、点光源と平行光です。 全局光を作成：newLight(AMBIENT_LIGHT, r, g, b, intensity) 点光源を作成：newLight(POINT_LIGHT, r, g, b, intensity, x, y, z, radius, smoothWidth) 平行光を作成：newLight(PARALLEL_LIGHT, r, g, b, intensity, tx, ty, tz) AMBIENT_LIGHT, POINT_LIGHT, PARALLEL_LIGHTは定数です。 r, g, bはライトの色で範囲は0~1です。 intensityはライトの強度で、範囲は>=0です。 x, y, zは点光源の座標です。 tx, ty, tzは平行光源の方向ベクトルです。 radiusは点光源の半径（下図参照） smoothWidthは点光源の減衰距離（下図参照） 戻り値は、ライトデータを表す正の整数のidです。 注意：この関数はライトをただ作成するだけです。ライトをシーンに適用するには、activateLightを呼び出す必要があります。 delLight 3.7.0で新たに追加された関数。 delLightはライトインスタンスを削除するために使用されます。 delLight(id1) delLight(id1, id2) delLight(id1, id2, id3) ...(任意の回数のidを入力可能) idはライトデータを表す正の整数で、newLight関数の戻り値で取得します。 通常、手動でライトを削除する必要はありません。Pixel Worldはすべてのライトをフレーム終了時に自動でクリーンアップします。 getLightInfo 3.7.0で新たに追加された関数。 getLightInfo(id)を使用して、指定したライトの情報を取得します。 ライトが全局光の場合、type, r, g, b, intensity = getLightInfo(id)でライトデータを受け取ります。 ライトが点光源の場合、type, r, g, b, intensity, x, y, z, radius, smoothWidth = getLightInfo(id)でライトデータを受け取ります。 ライトが平行光の場合、type, r, g, b, intensity, tx, ty, tz = getLightInfo(id)でライトデータを受け取ります。 idがどのタイプの光源なのか不明な場合、以下の手法で光源の情報を処理できます。 getLightInfo.lua version3() -- 新たに3つのテスト用ライトを作成 local lightList = { newLight(AMBIENT_LIGHT, 1,0,0,1), newLight(POINT_LIGHT, 1,0,0,1,100,200,300,20,30), newLight(PARALLEL_LIGHT, 1,0,0,1,100,200,300), } for i,v in ipairs(lightList) do -- すべての戻り値を一度配列に入れる local returnList = {getLightInfo(v)} -- 最初の戻り値でライトタイプを判断します。（注意: Luaでは配列のインデックスは1から始まります、0ではありません） if(returnList[1] == AMBIENT_LIGHT) then println(\"Ambient light! Its intensity is: \".. returnList[5]) elseif(returnList[1] == POINT_LIGHT) then println(\"Point light! Its radius is: \" .. returnList[9]) elseif(returnList[1] == PARALLEL_LIGHT) then println(\"Parallel light! Its x component of direction is: \" .. returnList[6]) end end -- 光源の削除は必須ではありません delLight(table.unpack(lightList)) activateLight 3.7.0で新たに追加された関数。 光源を活性化し、それが以後に描画されるすべての三次元オブジェクトの出力色に影響を与えます。 activateLight(id1) activateLight(id1, id2) activateLight(id1, id2, id3) ...(任意の回数のidを入力可能) idはnewLight関数の戻り値で取得する正の整数です。 deactivateLight 3.7.0で新たに追加された関数。 反活性化によって光源が影響を及ぼすことを防ぎます。 deactivateLight(id1) deactivateLight(id1, id2) deactivateLight(id1, id2, id3) ...(任意の回数のidを入力可能) idはnewLight関数の戻り値で取得する正の整数です。 getActivatedLight 3.7.0で新たに追加された関数。 現在の環境でアクティブなすべての光源のIDを取得します。 getActivatedLight() 戻り値：すべてのactivateLightによってアクティブ化されたライトID（戻り値の数は0以上） すべての戻り値をリストにまとめて返したい場合は、idList = {getActivatedLight()}を使用してください。 setActivatedLight 3.7.0で新たに追加された関数。 環境でアクティブなライトをクリアし、新しくアクティブなライトを設定します。 setActivatedLight()は単に環境内のすべてのライトをクリアします。 setActivatedLight(id1)は環境内のすべてのライトをクリアし、id1で指定したライトをアクティブにします。 setActivatedLight(id1, id2)は環境内のすべてのライトをクリアし、id1およびid2で指定したライトをアクティブにします。 ...(任意の回数のIDを入力可能) 既存のライトをクリアせずにライトを追加したい場合は、activateLightを使用してください。 fetchLight 3.7.0で新たに追加された関数。 After Effects（Ae）シーンから指定された名前の光源情報を取得し、取得したパラメータに基づいてPixelsWorld内部の光源インスタンスを作成し、そのライトインスタンスのIDを戻します。 fetchLight(matchName) fetchLight()はfetchLight(\"*\")と同等 matchNameルール：文字列の末尾に\"*\"が含まれていない場合、Aeの現在のコンポジションの中から名前がmatchNameのライトを検索してシーンに追加します。末尾に\"*\"が含まれている場合は、matchNameで始まるすべてのライトをシーンに追加します。 現在サポートされているAeライトの種類：ambient, point, parallel 戻り値：matchNameに一致する1つまたは複数のライトデータのID（戻り値の数は0以上） 注意：この関数はライトインスタンスを作成するのみです。作成したライトをシーンに適用するにはactivateLightを組み合わせて使用する必要があります。 ambientLight v3.7.0バージョンから、この関数の使用は推奨されていません。newLightを使用してください。 ambientLight(r, g, b, intensity) ambientLight()はambientLight(1, 1, 1, 1)と同等 ambientLight(brightness)はambientLight(brightness, brightness, brightness, 1)と同等 ambientLight(brightness, intensity)はambientLight(brightness, brightness, brightness, intensity)と同等 ambientLight(r, g, b)はambientLight(r, b, g, 1)と同等 シーン内のすべてのオブジェクトに影響を与える環境光を生成します。 この光はオブジェクトの法線方向を無視できます。法線が逆方向でもオブジェクトを照らします。 al.lua version3() dim3() move(width/2,height/2,0) n=4 phong() ambientLight(1,0.5,0.2,10) noStroke() for r=1,n do local ra = r*50 local cn = math.floor(ra*TPI/40) for i=1,cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn,0.5,0.5)) move(ra,0,0) ball(15,3) endGroup() end end pointLight v3.7.0バージョンから、この関数の使用は推奨されていません。newLightを使用してください。 pointLight(r, g, b, intensity, radius, smoothWidth) pointLight()はpointLight(1, 1, 1, 1, 1000, 1000)と同等 pointLight(brightness, intensity)はpointLight(brightness, brightness, brightness, intensity, 1000, 1000)と同等 pointLight(r, g, b)はpointLight(r, g, b, 1, 1000, 1000)と同等 pointLight(r, g, b, intensity)はpointLight(r, g, b, intensity, 1000, 1000)と同等 pointLight(r, g, b, intensity, radiusAndSmoothWidth)はpointLight(r, g, b, intensity, radiusAndSmoothWidth, radiusAndSmoothWidth)と同等 現在の描画の原点において点光源を生成します。 この光はオブジェクトの法線方向に影響を受け、法線に向くオブジェクトは拡散反射やハイライトを受けませんが、点光源による環境光を受けることができます。 radiusは点光源の光が届く範囲であり、radiusからradius+smoothWidthの間で光の強度が減衰します。 pl.lua version3() dim3() move(width/2,height/2,0) n=4 phong() ambientLight(0.2,0.5,1,2) beginGroup() move(0,0,-100) pointLight(1,0.5,0.2,2,500,100) endGroup() noStroke() for r=1,n do local ra = r*50 local cn = math.floor(ra*TPI/40) for i=1,cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn,0.5,0.5)) move(ra,0,0) ball(15,3) endGroup() end end parallelLight v3.7.0バージョンから、この関数の使用は推奨されていません。newLightを使用してください。 parallelLight(r, g, b, intensity, tx, ty, tz) グローバル範囲で方向が(tx, ty, tz)の平行光を生成します。 pll.lua version3() dim3() move(width/2,height/2,0) n=4 phong() ambientLight(0.2,0.5,1,2) parallelLight(1,0.5,0.2,2,1,-1,1) noStroke() for r=1,n do local ra = r*50 local cn = math.floor(ra*TPI/40) for i=1,cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn,0.5,0.5)) move(ra,0,0) ball(15,3) endGroup() end end light_effects.lua version3() dim3() background(0.1,0.2,0.3) move(width/2,height/2,0) math.randomseed(1) n=5 ambientLight(0.2,0.5,1,1) parallelLight(1,0.5,0.2,0.1,1,-1,1) beginGroup() move(200,0,-100) pointLight(1,0.5,0.2,1,200,100) endGroup() beginGroup() move(-30,200,-100) pointLight(0,1,1,1,200,100) endGroup() beginGroup() move(-30,-200,-100) pointLight(0,1,1,1,200,100) endGroup() noStroke() for r=1,n do local ra = r*50 local cn = math.floor(ra*TPI/40) for i=1,cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn,r/n,0.6)) move(ra,0,0) if math.random() clearLight v3.7.0バージョンから、この関数の使用は推奨されていません。deactivateLight、delLightまたはsetActivatedLightを使用してください。 clearLight()はシーン内のすべてのライトをクリアします。 getLight v3.7.0バージョンから、この関数の使用は推奨されていません。fetchLightとactivateLightを組み合わせて使用してください。 getLight(matchName) getLight()はgetLight(\"*\")と同等 現在のコンポジションでmatchNameに一致するライトを取得します。 matchNameルール：文字列の末尾に\"*\"が含まれていない場合、Aeの現在のコンポジションの中から名前がmatchNameのライトを検索してシーンに追加します。末尾に\"*\"が含まれている場合は、matchNameで始まるすべてのライトをシーンに追加します。 現在サポートされているAeライトの種類：ambient, point, parallel aeCamera aeCamera()はAeの現在シーンのカメラをピクセルワールドのシーンカメラとして使用します。 lookAt lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ,upVecX,upVecY,upVecZ)を使ってカメラ位置と方向を設定します lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ)はlookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ,0,-1,0)と同等です eyePosは目の位置、objPosは注視対象のオブジェクトの位置、upVecは頭上の方向を示します。 注意：AeではY軸が通常下方向を向いているため、upVecを(0,-1,0)に設定することが一般的です。 eyePosとobjPosが近すぎてはいけません（推奨される距離は1e-7以上）。 upVecは視線と平行であってはいけません。 upVecの長さは小さすぎてはいけません。 viewSpace viewSpace(width,height,distanceToPlane,farLevel) viewSpace(width,height,distanceToPlane)はviewSpace(width,height,distanceToPlane,4)と同等です widthとheightはカメラの遠景のサイズです カメラとカメラの遠景の垂直距離はdistanceToPlaneです farLevel * distanceToPlaneは一番遠い平面の距離を示し、それを超える物体はレンダリングされません。通常farLevelは4で十分です。もしシーンが非常に大きければ、この値を高く設定することができます。この値は遠くの物体がレンダリングされるかどうかだけに影響します。値を高く設定しすぎると、近くの物体の深度テスト精度に影響を与えるかもしれません。 strokeWidth strokeWidth(width)を使って線の太さを設定します。 デフォルト値：2 strokeWidth.lua version3() background(1) move(100,100) for i=1,30 do move(10,0) strokeWidth(i/8) line(0,0,0,100) end strokeDivision strokeDivision(level)で線の細分化レベルを設定します デフォルト値：3 strokeDivision.lua version3() background(1) strokeWidth(30) move(100,100) for i=0,3 do strokeDivision(i) line(0,0,0,100) move(75,0) end strokeGlobal strokeGlobal()でグローバルモードで線を描画し、線の太さはスケールの影響を受けません。 デフォルト値はローカルモード strokeGlobal.lua version3() strokeWidth(4) strokeGlobal() move(50,100) beginGroup() for i=1,13 do beginGroup() scale(1/i) rect(50) endGroup() move(50/i+20,0) end endGroup() strokeLocal strokeLocal()でローカルモードで線を描画し、線の太さはスケールの影響を受けます。 デフォルト値はローカルモード strokeLocal.lua version3() strokeWidth(4) strokeLocal() move(50,100) beginGroup() for i=1,13 do beginGroup() scale(1/i) rect(50) endGroup() move(50/i+20,0) end endGroup() dotRadius dotRadius(radius)で点の太さを設定します。 デフォルト値：2 dotRadius.lua version3() background(1) fill(0,1,1) dot(1,0,0) move(100,100) for i=1,7 do dotRadius(i/2) rect(40) move(50,0) end dotDivision dotDivision(level)で点の細分化レベルを設定します。（非負整数、最大7） デフォルト値：3 dotDivision.lua version3() background(1) fill(0,1,1) dot(1,0,0) dotRadius(10) move(100,100) for i=0,4 do dotDivision(i) rect(40) move(70,0) end dotGlobal dotGlobal()でグローバルモードで点を描画し、点の半径はスケールの影響を受けません。 デフォルト値はローカルモード dotGlobal.lua version3() dot(1,0,0) dotGlobal() move(50,100) beginGroup() for i=1,13 do beginGroup() scale(1/i) rect(50) endGroup() move(50/i+20,0) end endGroup() dotLocal dotLocal()でローカルモードで点を描画し、点の半径はスケールの影響を受けます。 デフォルト値はローカルモード dotLocal.lua version3() dot(1,0,0) dotLocal() move(50,100) beginGroup() for i=1,13 do beginGroup() scale(1/i) rect(50) endGroup() move(50/i+20,0) end endGroup() smooth smooth()でアンチエイリアスモードで描画します。 デフォルトでオン プラグインパネルでアンチエイリアス強度を変更可能 noSmooth noSmooth()でアンチエイリアスなしのモードで描画します。 この関数の優先度はプラグインパネルのアンチエイリアス設定よりも高いです。 r2d r2d(radians)でラジアンを度に変換し、度を返します。 d2r d2r(degrees)で度をラジアンに変換し、ラジアンを返します。 map map(value,in1,in2,out1,out2)で、数値valueを範囲in1~in2からout1~out2にマッピングします。 in1がin2と等しい場合、valueのときこの関数はout1を返し、それ以外ではout2を返します。 clamp clamp(value,lower,upper)で数値valueを範囲[lower,upper]に挟み込み、挟み込まれた値を返します。 v3.2.0の新関数 valueがlowerとupperの間にある場合はvalueを返し、valueがlowerより小さい場合はlowerを返し、valueがupperより大きい場合はupperを返します。 step step(value,threshold)でvalueのときに0を返し、それ以外では1を返します。 v3.2.0の新関数smoothStep smoothStep(value,lower,upper)は、valueの場合に0を返し、value>higherの場合に1を返します。それ以外の場合は、lowerとhigherの間でvalueに基づいてスムーズに補間します。 補間の公式： t:=x−lowerupper−lower\r t := \\frac{x - lower}{upper - lower}\r t:=​upper−lower​​x−lower​​ Result:=t2(3−2t)\r Result:=t^2(3 - 2t)\r Result:=t​2​​(3−2t) v3.2.0の新しい関数です bezier bezier(t,p0,p1,...,pn)は、p0,p1,...,pnをn次のベジエ補間を行い、補間結果を返します。 補間の公式： Result:=∑k=0nCnk⋅(1−t)n−k⋅tk⋅pk\r Result := \\sum_{k=0}^n{C_n^k\\cdot (1-t)^{n-k}\\cdot t^k\\cdot p_k}\r Result:=∑​k=0​n​​C​n​k​​⋅(1−t)​n−k​​⋅t​k​​⋅p​k​​ Cnk:=n!(n−k)!k!\r C_n^k:=\\frac{n!}{(n-k)!k!}\r C​n​k​​:=​(n−k)!k!​​n!​​ v3.2.0の新しい関数です nの最大値は66 カラー変換 xxx2xxxは下図の変換を許容します 例えば、hsl形式のカラーをrgbに変換したい場合は関数：hsl2rgbを使用します。入力値と返り値はそれぞれ3つです。 すべてのカラーは0~1の範囲で変換されます。 v3.2.0の新しい関数です color_convert.lua version3() dim3() strokeWidth(0.5) stroke(0) move(width/2,height/2,0) for x = -5,5 do for y =-5,5 do for z=-5,5 do beginGroup() move(x*15,y*15,z*15) fill(cmy2rgb(x/10+.5,y/10+.5,z/10+.5)) cube(12) endGroup() end end end utf8ToLocal utf8ToLocal(str)はUnicode文字列をローカル文字列に変換し、ローカルエンコーディングの文字列を返します。 Luaのioモジュールを使用していてパスにutf8文字が含まれたファイルを読み込めない場合、この関数を使用してパスエンコーディングを変換してください。 localToUtf8 localToUtf8(str)はローカル文字列をUnicode文字列に変換し、Unicodeエンコード文字列を返します。 getGLInfo getGLInfo()は現在のグラフィックカードの情報を取得します。文字列を返します。 getDrawRecord getDrawRecord(needStringFormat)は現在のシーンの描画記録情報を出力します。needStringFormatはブール値で、trueの場合は文字列を出力し、falseの場合はLuaテーブルを出力します。 getDrawRecord()はgetDrawRecord(true)と同等です。 printDrawRecord.lua version3() dot(1,0,0) move(width/2,height/2) dim3() cube() println(getDrawRecord()) getStatus getStatus(needStringFormat)は現在のペン情報を出力できます。needStringFormatはブール値で、trueの場合は文字列を出力し、falseの場合はLuaテーブルを出力します。 getStatus()はgetStatus(true)と同等です。 getStatus.lua version3() move(width/2,height/2) dim3() cube() println(getStatus()) getAudio v3.4.0+バージョンのPixelsWorldを持っていることを確認してください getAudio([startTime,duration[,id[,sampleRate,startFrequency,endFrequency[,resolution]]]])は音声情報を取得し、6つのテーブルを返します：左右チャンネルの2つの波形サンプル、2つのFFT結果テーブル（左右チャンネル）と2つのスペクトルテーブル（左右チャンネル）。 省略項目はプラグインパネルのオーディオ設定データで埋められます。 左チャンネル波形 (-1~1) 右チャンネル波形 (-1~1) 左チャンネルFFT (0~正無限) 右チャンネルFFT (0~正無限) 左チャンネルスペクトル (0~正無限) 右チャンネルスペクトル (0~正無限) waveInfo.lua version3() castTex(OUTPUT,INPUT) local wl,wr,ftl,ftr,specl,specr = getAudio() local nm = math.floor(height/8); for i=1,nm do local wid =math.max(math.floor(i/nm*#wl),1) local fid = math.max(math.floor(i/nm*#specl),1) print(string.format(\"%8.5f\",wl[wid]),wl[wid]*4,0,-wl[wid]*4) print(\" \",1,0,0,0) print(string.format(\"%8.5f\",wr[wid]),wr[wid]*4,0,-wr[wid]*4) print(\" \",0.5,0.5,0.5) print(string.format(\"%8.5f\",specl[fid]),specl[fid],0,0) print(\" \",1,0,0,0) print(string.format(\"%8.5f\",specr[fid]),0,0,specr[fid]) println(\"\"); end saveString saveString(utf8_path,string)は文字列をテキスト形式でローカルに保存します。 loadString loadString(utf8_path)はローカルテキストファイルを読み込み、文字列を返します。 getColor getColor(id,x,y)はidのテクスチャにおける(x,y)座標のピクセル値を返し、r,g,b,aの4つの倍精度浮動小数点数を返します。 getColor(x,y)はgetColor(INPUT,x,y)と同等です。 すべてのシーンを描画する前にgetColorを使用すると（すなわち、version3()の直後）、この関数の効率は最高です。しかし、シーンの描画中にgetColorを使用すると、この関数の効率は非常に低下します。LuaはCPU上で動作しており、描画する場面ではすべてのテクスチャがグラフィックカードに送信されるため、グラフィックカードとCPUの間で通信する時間コストが非常に高くなります。 有効なidはINPUT、OUTPUT、PARAM0~PARAM9です。 setColor setColor(x,y,r,g,b,a)はOUTPUTテクスチャの(x,y)座標のピクセル値を設定します。 すべてのシーンを描画する前にsetColorを使用すると（すなわち、version3()の直後）、この関数の効率は最高です。 getSize getSize(id)はidのテクスチャのサイズ（幅と高さの2つのdouble）を返します。 シーンのダウンサンプリングを変更すると（例えば、1/2、1/4など）、返されるサイズは0~4ピクセルの揺れがあります。これはAeのダウンサンプリングメカニズムによる特徴です。ただし、この揺れは時間とともに変化しません。ダウンサンプリングをオフにしたとき、この関数は正しいレイヤーサイズを保証して返します。 shadertoy shadertoy(code)はShadertoyのコードを実行します。 すべてのShadertoyコードがサポートされるわけではありません glsl glsl(code)はフラグメントステージのコードを実行します cmd cmd(code)はcmdコマンドを実行します コマンドが正常に実行完了した場合、最初の返り値はtrueです。それ以外の場合はnilです。最初の返り値の後、関数は文字列と数字を返します。以下のようになります： \"exit\": コマンドが正常終了した場合；次の数字はコマンドの終了ステータスコードです。 \"signal\": コマンドが信号で中断された場合；次の数字はそのコマンドを中断した信号です。 lua lua(code)はLuaコードを実行します runFile runFile(utf8_path)はローカルファイルをテキストファイルとして読み込み、Luaコードとして実行します。 デフォルトでutf8文字をサポートしており、utf8ToLocalを呼び出して変換する必要はありません。 txt txt(utf8_path)はローカルファイルをテキストファイルとして読み込み、文字列を返します。 デフォルトでutf8文字をサポートしており、utf8ToLocalを呼び出して変換する必要はありません。 "},"contents/Lua/Texture.html":{"url":"contents/Lua/Texture.html","title":"テクスチャシステム","keywords":"","body":"テクスチャシステム v3.3.0+のPixelsWorldを持っていることを確認してください この章を通じて、PixelsWorldのテクスチャシステムの使い方をすばやく学ぶことができます。 newTex delTex getSize swapTex drawTo castTex blendTex copyTex fetchTex savePNG,loadPNG,saveEXR,loadEXR,saveRAW,loadRAW rotateTex,flipTex,resizeTex,trimTex テクスチャID PixelsWorldでは、テクスチャは整数（テクスチャID）で表されます。PixelsWorldが提供する基本的なテクスチャIDは以下の通りです： テクスチャID Luaモードグローバル定数 GLSLモードグローバル定数 Shadertoyモードグローバル定数 説明 -3 OUTPUT アクセス不可 アクセス不可 出力テクスチャ -2 TEMP PW_TEMP_LAYER _PixelsWorld_PW_TEMP_LAYER バッファテクスチャ -1 INPUT AE_INPUT_LAYER _PixelsWorld_AE_INPUT_LAYER 入力テクスチャ 0 PARAM0 0 0 パラメーターレイヤー0 1 PARAM1 1 1 パラメーターレイヤー1 ... PARAM... ... ... ... 9 PARAM9 9 9 パラメーターレイヤー9 テクスチャIDを自分で作成することもできます。方法は後述します。 基本的な流れ 通常、Aeは1枚の画像をPixelsWorldに送信し、PixelsWorldはまずその画像をINPUTに配置します。そして、計算結果をOUTPUTテクスチャに置き、すべての命令が終了した後、OUTPUTテクスチャをAeに結果として送信します。 TEMPの役割 OpenGLは同じテクスチャを同時に読み書きすることをサポートしていないため、PixelsWorldはTEMPを提供して、前回のglsl,shadertoyなどの関数での描画結果を保存します。シェーダー内でgetColor(PW_TEMP_LAYER,uv);を使用してTEMPの色をサンプリングすることができます。 テクスチャの作成 newTex(width,height)を使用してテクスチャを作成し、テクスチャID（ランダムな整数値）を返します。 テクスチャの削除 delTex(id)を使用して指定したテクスチャを削除します。 通常、手動で削除する必要はありませんが、PixelsWorldは毎フレーム終了時にすべてのテクスチャを削除します。しかし、不要になったテクスチャを事前に解放し、そのメモリを開放することは良い習慣です。 サイズの取得 getSize(id)を使用してテクスチャのサイズを取得します。 getSize.lua version3() mytex = newTex(512,256) w,h = getSize(mytex) println(\"Width of mytex is: \" .. w) println(\"Height of mytex is: \" .. h) テクスチャの交換 swapTex(id1,id2)を使用してid1とid2が指すテクスチャを交換します。 swapTex.lua version3() tex1 = newTex(128,128) tex2 = newTex(256,256) w,h = getSize(tex1) println(\"tex1 size: \" .. w .. \", \".. h) swapTex(tex1,tex2) w,h = getSize(tex1) println(\"tex1 size after swapped: \" .. w .. \", \".. h) 描画先の設定 drawTo(id)を使用して描画先テクスチャを変更します。描画先テクスチャはデフォルトでOUTPUTです。PixelsWorldは最終的にOUTPUTを結果としてAeに送信することに注意してください。以下の3つの方法で他のテクスチャの結果をOUTPUTに渡すことができます： drawTo(OUTPUT)+image castTex swapTex テクスチャの投射 castTex(toTexId,fromTexId)を使用して、fromTexIdからtoTexIdにピクセルを投射します。たとえば、パラメーターレイヤー0 PARAM0を出力テクスチャOUTPUTに投射できます： castTex.lua version3() castTex(OUTPUT,PARAM0) また、投射するテクスチャの範囲を指定することができます（テクスチャの左上を原点とします）： castTex(toTexId,fromTexId,to1x,to1y,to2x,to2y) castTex(toTexId,fromTexId,to1x,to1y,to2x,to2y,from1x,from1y,from2x,from2y) 範囲を省略した場合はテクスチャ全体が使用されます。 テクスチャの混合 blendTex(toTexId,fromTexId,blendRule)を使用して、混合ルールblendRuleを使用してテクスチャfromTexをテクスチャtoTexに貼り付けます。 blendRuleはNORMAL,ADD,SUBTRACT,MULTIPLY,DIVIDE,MAX,MINのいずれかを指定できます。 blendRuleは文字列にもでき、以下のように指定します： AはtoTexIdの入力ピクセルを表します BはfromTexIdの入力ピクセルを表します CはtoTexIdの出力ピクセルを表します たとえば、次のコードを使用して入力テクスチャとパラメーターレイヤー0の画像を加算混合することができます。 blendRule.lua version3() castTex(OUTPUT,INPUT) -- まずINPUTテクスチャをOUTPUTにキャスト。 blendTex(OUTPUT,PARAM0,\"C=A+B\") -- PARAM0をOUTPUTに混合。 実際には、ここでの文字列はGLSLコードに処理され、\"C=A+B\"は内部で以下のコードに変換されます： blendRuleGLSL.frag #version 330 core out vec4 outColor; in vec2 uv; in vec2 uv2; uniform sampler2D inLayerA; uniform sampler2D inLayerB; void main(){ vec4 A = texture(inLayerA,uv); vec4 B = texture(inLayerB,uv2); vec4 C = A; C=A+B // あなたの混合ルールはこちらに結合されます。 ; outColor = C; } castTexと同様に、blendTexもテクスチャ範囲の指定に対応しています： blendTex(toTexId,fromTexId,blendRule,to1x,to1y,to2x,to2y) blendTex(toTexId,fromTexId,blendRule,to1x,to1y,to2x,to2y,from1x,from1y,from2x,from2y) テクスチャのコピー copyTex(refTexId)を使用してテクスチャをコピーし、コピーされた新しいテクスチャを返します。 任意の時間におけるレイヤーピクセルの取得 fetchTex(layerId, time)を使用して、指定した時間の特定のレイヤーのテクスチャを取得し、取得したテクスチャIDを返します。 layerId: PARAM0~PARAM9のみが入力可能です。 time: レイヤーの時間（浮動小数点数、単位は秒） 注意: この関数を使用すると、Aeのキャッシュにエラーが発生する可能性があります。定期的にキャッシュをクリアするようにしてください。 v3.4.3+で新しく追加された関数です。 テクスチャの読み込みと保存 savePNG(utf8Path,texId),loadPNG(utf8Path)を使用して、PNG画像を保存および読み込みます。 saveEXR(utf8Path,texId),loadEXR(utf8Path)を使用して、EXR画像を保存および読み込みます。 saveRAW(utf8Path,texId),loadRAW(utf8Path)を使用して、MiLaiの未圧縮のオリジナルメモリ画像を保存および読み込みます。 以下は、PixelsWorldがサポートする画像仕様の詳細です： 形式 使用するライブラリ サポートされる圧縮方法 画像カラー規格 PNG cute_headers DEFLATE準拠デコンプレッサzlib(RFC 1950) RGBA、各チャネル毎に8ビットの符号なし整数。 EXR tinyexr NONE,RLE,ZIP,ZIPS,PIZ,ZFP RGBA、各チャネル毎にHDR 32ビット浮動小数点。 RAW (なし) MiLai独自形式。（以下の図参照） RGBA、各チャネル毎にHDR 32ビット浮動小数点。 シーンにPNG画像を読み込む： loadPNG.lua version3() local mypng = loadPNG([[d:\\test.png]]) -- あなたのパスに置き換えてください。 castTex(OUTPUT,mypng) -- mypngからOUTPUTにピクセルをキャスト。 PNG画像をローカルに保存する： savePNG.lua version3() --OUTPUTに何かを描画 move(width/2,height/2) rotate(time) triangle() --描画終了。 savePNG([[d:\\test.png]],OUTPUT) -- OUTPUTをPNGとしてローカルディスクに保存。ここで自分のパスに置き換えてください。 PNGをEXRに変えると、EXR画像の保存と読み込みが可能になります。 一部の場所に保存するには管理者権限が必要です。 テクスチャの修整 rotateTex(texId,times)を使用して90*times度テクスチャを回転させます。rotateTex(texId)はrotateTex(texId,1)と同等です。 flipTex(texId,flipV)を使用してテクスチャを反転します。flipVはブール値で、flipVがtrueの場合は垂直反転、falseの場合は水平反転です。 resizeTex(texId,width,height)を使用してテクスチャを縮小します。 trimTex(texId,p1x,p1y,p2x,p2y)を使用してテクスチャをトリミングします。p1x,p1y,p2x,p2yはテクスチャ左上を原点とした座標です。 "},"contents/Lua/Filter.html":{"url":"contents/Lua/Filter.html","title":"フィルターシステム","keywords":"","body":"フィルターシステム v3.6.0+のPixelsWorldをお持ちの方のみご利用いただけます フィルターシステムは、矩形シェーダーのラッピングを行い、画面全体のエフェクトに対する後処理シェーダーを迅速に構築することを可能にします。 この章を通じて、PixelsWorldのフィルターシステムを迅速に理解し、使用方法を学ぶことができます。 newFilter フィルターを作成 runFilter フィルターを実行 delFilter フィルターを削除 setFilterUniform フィルターを設定 setFilterDrawto 出力画像を設定 newFilterModule フィルターモジュールを作成 高度な応用 フィルターを作成 newFilter(glslCode) を使用してフィルタープログラムを作成します 戻り値：フィルタープログラムを表すランダム整数（フィルターID） glslCode は以下のコンテキストに挿入されます： glslcode_context.glsl #version 330 core in vec2 uv; out vec4 outColor; // Your glslCode here! サンプル 注意：Luaでは、二重中括弧[[...]]を使用して複数行の文字列を表します newFilter.lua version3() filterID = newFilter([[ void main(){ outColor = vec4(uv,0,1); } ]]) フィルターを実行 runFilter(filterID) を使用してフィルタープログラムを実行します サンプル runFilter.lua version3() filterID = newFilter([[ void main(){ outColor = vec4(uv,0,1); } ]]) runFilter(filterID) フィルターを削除 delFilter(filterID) を使用してフィルターを削除します。 通常、フィルターを削除する必要はありませんが、PixelsWorldは各フレームの終了時にすべてのフィルターを自動的に削除します。ただし、必要がないフィルターは削除することをお勧めします。 サンプル delFilter.lua version3() filterID = newFilter([[ void main(){ outColor = vec4(uv,0,1); } ]]) delFilter(filterID) フィルターを設定 setFilterUniform(filterID, uniformType, uniformName, data0, data1, data2, ...) を使用してフィルター内で定義した uniform 属性を設定します。 filterID: フィルターID、整数。 uniformType: 変数タイプを表す文字列。一次元データ（\"int\",\"float\",\"bool\"）やベクトル（\"vec2\",\"vec3\",\"vec4\",\"ivec2\"...）、行列（\"mat2, mat4x3, ...\"）、テクスチャ（\"sampler2D\"）をサポートします。 uniformName：変数名の文字列。 data0,data1,...：浮動小数データ。（サンプル参照） サンプル setFilterUniform.lua version3() filterID = newFilter([[ uniform float myfloat; uniform vec2 myvec; uniform mat3x2 mymat; uniform sampler2D mytex1; void main(){ outColor = vec4(myfloat,myvec[0],mymat[0][1],1) + texture(mytex1,uv); } ]]) setFilterUniform(filterID, \"float\", \"myfloat\", math.sin(time)*0.5 + 0.5) setFilterUniform(filterID, \"vec2\", \"myvec\", 1,2) -- 列単位で、例えば mymat[0][0]==1, mymat[0][1]==slider(0), mymat[0][2]==2, mymat[1][0]==3, ... setFilterUniform(filterID, \"mat3x2\", \"mymat\", 1, slider(0), 2, 3, 4, 5) -- INPUT テクスチャを mytex1 として使用 setFilterUniform(filterID, \"sampler2D\", \"mytex1\", INPUT) -- ** 生成したテクスチャを mytex1 として設定することも可能です ** -- myInputTexID = newTex(512,256) -- setFilterUniform(filterID, \"sampler2D\", \"mytex1\", myInputTexID) runFilter(filterID) 出力画像を設定 setFilterDrawto(filterID, texID) を使用してフィルターの結果をどのテクスチャに出力するかを指定します。texID についてはテクスチャシステムをご参照ください。 デフォルトの出力テクスチャは OUTPUT です 一枚の画像に対して反復着色を行うこともできます。 詳細は高度な応用をご参照ください。 フィルターモジュールを作成 newFilterModule(glslCode) を使用してフィルターモジュールを作成します。 戻り値：フィルターIDといくつかのユーティリティ関数が含まれるテーブル。 フィルターモジュールの役割はコードを簡素化することです。 フィルターモジュールを使用しない場合、通常以下のようにフィルターを書かなければなりません： no_module.lua version3() filterID = newFilter([[ uniform float myfloat; void main(){ outColor = vec4(myfloat,0,0,1); } ]]) setFilterUniform(filterID, \"float\", \"myfloat\", math.sin(time)*0.5 + 0.5) setFilterDrawto(filterID, OUTPUT) runFilter(filterID) delFilter(filterID) フィルターモジュールを使用すると、以下のように書くことができます： no_module.lua version3() filter = newFilterModule([[ uniform float myfloat; void main(){ outColor = vec4(myfloat,0,0,1); } ]]) filter.set(\"float\", \"myfloat\", math.sin(time)*0.5 + 0.5) filter.drawto(OUTPUT) filter.run() filter.del() 高度な応用 以下はチャンネルぼかしのコードサンプルです： slider 0：ぼかし強度 layer 0：ぼかしマスク iterateFilter.lua version3() -- 一時テクスチャを作成 tempTexID = newTex(width, height) -- 入力を一時テクスチャにコピー castTex(tempTexID, INPUT) -- ぼかしコード blurGLSLCode = [[ uniform sampler2D in_tex; uniform mat3 kernel; uniform vec2 resolution; void main() { vec2 xy = resolution * uv; vec4 res = vec4(0,0,0,0); for(int x = 0; x "},"contents/Lua/Simulation.html":{"url":"contents/Lua/Simulation.html","title":"物理シミュレーション","keywords":"","body":"物理シミュレーション 以下の画像は、nimitzによって制作されたChimera's BreathがPixelsWorldで実行された結果です。完全なビデオを見る この章では、PixelsWorldでデータをキャッシュする方法を紹介します。 注意：Aeの機能が制限されているため、このマニュアルに定められた規範に厳密に従ってキャッシュを行ってください。 PixelsWorldのv3.3.3+バージョンをお持ちであることを確認してください この文章は、読者がある程度のAe操作とPixelsWorldコードの熟練度を有していることを前提としています。PixelsWorldの使用法に不慣れな場合は、前の章を学習してください。 Aeのマルチコアレンダリング機能をオフにすることをお勧めします。 物理シミュレーション データキャッシュ テクスチャキャッシュ データキャッシュ実践――三体問題シミュレーション テクスチャキャッシュ実践――コンウェイのライフゲーム テクスチャキャッシュ実践――流体シミュレーション データキャッシュ PixelsWorldでデータをキャッシュするには、以下のステップに従います： コードロジック： キャッシュ位置とキャッシュファイル名を設定 frameId=time*fpsを計算 lastFrameId=frameId-1を計算 lastFrameIdが0未満の場合は5へ、そうでない場合は6へ データを初期化し、7へ ローカルに保存された前フレームのシミュレーションデータファイルを読み取り、ファイルが存在しない場合はエラーを報告、そうでない場合は7へ 今回のフレームのシミュレーションデータを計算 今回のフレームのシミュレーションデータをローカルに保存 操作ロジック： 上記ロジックに従うコードをPixelsWorldに書き込む 時間インジケータを現在のレイヤーの最初の位置に移動する Aeのすべてのキャッシュをクリアする（Edit->Purge->All Memory & Disk Cache... 下図） Ctrl+Altを押し、プラグインパネルのLOGOをクリックする（このステップはオプション） スペースキーを押してレンダリングを開始する（飛ばしてレンダリングしないでください） 注意：不安を感じる場合（エラー、画面がフラッシュするなど）は、必ず2〜5のステップを再実行してください テクスチャキャッシュ コードロジック： ダウンサンプリング（1/2、1/4モード）の場合、エラーを報告 キャッシュ位置とキャッシュファイル名を設定 frameId=time*fpsを計算 lastFrameId=frameId-1を計算 lastFrameIdが0未満の場合は5へ、そうでない場合は6へ データを初期化し、7へ ローカルに保存された前フレームのテクスチャファイルを読み取り、ファイルが存在しない場合はエラーを報告、そうでない場合は7へ 今回のフレームのテクスチャファイルを計算 今回のフレームのテクスチャファイルをローカルに保存 テクスチャの操作については、テクスチャの章をご覧ください 操作ロジック： 上記ロジックに従うコードをPixelsWorldに書き込む プラグインパネルの設立Advanced->Internal texture formatをFloating point 32bit x RGBA (HDR)に設定する 時間インジケータを現在のレイヤーの最初の位置に移動する Aeのすべてのキャッシュをクリアする（Edit->Purge->All Memory & Disk Cache...） Ctrl+Altを押し、プラグインパネルのLOGOをクリックする（このステップはオプション） スペースキーを押してレンダリングを開始する（飛ばしてレンダリングしないでください） データキャッシュ実践――三体問題シミュレーション the_three_body_problem.lua version3() -- ベクトルライブラリをインポート require(\"veclib\") -- キャッシュファイル名を設定 local cacheFileName = \"A\" -- ファイルが存在するか確認する関数を宣言（関数はhttps://stackoverflow.com/questions/4990990/check-if-a-file-exists-with-luaより） function file_exists(name) local f=io.open(name,\"r\") if f~=nil then io.close(f) return true else return false end end -- 現在のフレーム番号を計算し四捨五入 local frameId = math.floor(time * fps + .5) -- 前のフレーム番号を計算 local lastFrameId = frameId -1 -- 現在のフレーム番号が非負であることを確認し、負の場合はエラーを報告 assert(frameId >= 0, \"FrameId not support\") -- 現在のフレーム番号を表示（この行は削除可能） println(\"Frame ID: \" .. frameId) -- キャッシュフォルダを設定（ここではaepプロジェクトの隣にあるcacheフォルダをディレクトリとして使用、projectFolderを使用する前にプロジェクトを保存する必要があります） local cachePath = projectFolder .. \"cache\\\\\" -- 現在の出力フォルダを表示（この行は削除可能） println(\"Cache path: \" .. cachePath) -- 本フレーム番号が0の場合（つまり前のフレームが0未満） if(lastFrameId テクスチャキャッシュ実践――コンウェイのライフゲーム game_of_life.lua version3() -- ダウンサンプリングをチェック assert(width == ds_width and height == ds_height , \"Downsample not support\" ) -- ファイルが存在するか確認する関数を宣言（関数はhttps://stackoverflow.com/questions/4990990/check-if-a-file-exists-with-luaより） function file_exists(name) local f=io.open(name,\"r\") if f~=nil then io.close(f) return true else return false end end -- 現在のフレーム番号を計算し四捨五入 local frameId = math.floor(time * fps + .5) -- 前のフレーム番号を計算 local lastFrameId = frameId -1 -- 現在のフレーム番号が非負であることを確認し、負の場合はエラーを報告 assert(frameId >= 0, \"FrameId not support\") -- 現在のフレーム番号を表示（この行は削除可能） println(\"Frame ID: \" .. frameId) -- キャッシュパスを設定 local cachePath = projectFolder .. \"cache\\\\\" println(\"Cache path: \" .. cachePath) -- 最初のフレームかどうかを確認 if(lastFrameId = res.x || iuv.x =res.y || iuv.y.5; } // 出典 https://thebookofshaders.com/10/ float random (vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123); } void main(){ if(time == 0.) { outColor = vec4(random(uv)>.5); }else{ bool curstatus = fetchStatus(0,0); int roundCount = 0; for(int i = 0;i 3) outColor = vec4(0); else outColor = vec4(curstatus); } else { if(roundCount == 3) outColor = vec4(1); else outColor = vec4(0); } } } ]==] -- 前のフレーム画像をPARAM0位置に配置し、glslがlayer[0]で前のフレームのテクスチャを読み取れるようにする swapTex(PARAM0,lastTexA) --レンダリングコード glsl(fragCode) -- 前のフレーム画像を自分の位置に戻す swapTex(PARAM0,lastTexA) -- 今回のフレームのテクスチャをローカルに保存 saveRAW(cachePath .. \"A_\" .. tostring(frameId) .. \".raw\",OUTPUT) テクスチャキャッシュ実践――流体シミュレーション 注意：原作者のコードライセンスにより、以下のコードは学習交流のみに使用し、商用利用しないでください。 プラグインパネルのInternal texture formatをFloating point 32 bit x RGBA (HDR)に変更することを忘れないでください。 シミュレーションを始める前に、必ず前提の操作説明をお読みください！ 読みに行く>>> Mipmap filterをNONEに設定すると速度が向上します。 fluid_simulation.lua version3() assert(width == ds_width and height == ds_height , \"Downsample not support\" ) function file_exists(name) local f=io.open(name,\"r\") if f~=nil then io.close(f) return true else return false end end local frameId = math.floor(time * fps + .5) local lastFrameId = frameId -1 assert(frameId >= 0, \"FrameId not support\") println(\"Frame ID: \" .. frameId) local cachepath = projectFolder .. \"cache\\\\\" println(\"Cache path: \" .. cachepath) if(lastFrameId "},"contents/Lua/Poly.html":{"url":"contents/Lua/Poly.html","title":"Poly関数","keywords":"","body":"創世神啓示録——Poly関数 poly(obj)関数は、objを解析して物体を描画します。 使用例 Houdiniをご使用の方は、objの構造プロセスがHoudiniのスプレッドシートを埋めるのに似ていることを確認できます。 以下の例では、特異な三角形のobjを構築しています。 PolyTest1.lua version3() background(0.95) move(width/2,height/2) dim3() dotRadius(5) obj={ point={ {p={0,0,0},color={0,1,1}}, {p={100,0,0},color={1,1,0}}, {p={0,100,0},color={1,0,1}}, {p={100,100,0},color={1,0,0}}, }, prim={ {type=\"triangle\",pref={1,2,3}}, {type=\"line\",pref={2,3,3,4,4,2}}, {type=\"point\",pref={2,4}}, } } poly(obj) サポートするプリミティブと名前 以下にpref={1,2,3,4,5,6}を例として説明します。 prefはpoint referenceの意味で、参照点の番号を指し、プリミティブは送られた番号の順に描画されます。 セミコロン（;）は1回のプリミティブ描画の終わりを示します。 標準名称(type name) 対応するプリミティブ 描画順序 全称 points 点 1;2;3;4;5;6; points pointd 平面点 1;2;3;4;5;6; point disc pointb 球点 1;2;3;4;5;6; point ball line 1本の線 123456; single line linef 平面線 123456; line flat linec 立体線 123456; line capsule linel ループ線 1234561; line loop linelf ループ平面線 1234561; line loop flat linelc ループ立体線 1234561; line loop capsule lines 複数本の線 12;34;56; lines linesf 複数本の平面線 12;34;56; lines flat linesc 複数本の立体線 12;34;56; lines capsule triangles 三角面 123;456; triangles triangleb 橋状三角面 123;324;345;546; triangle bridge triangler 放射状三角面 123;134;145;156; triangle radial objの構築 ここでは、以下の順序でobjの詳細を定義します。 objはテーブルです。 objは4つのキー：point、vertex、prim、detailを持つことができます。 objの4つのキーに対応する値は、それぞれ４つのテーブルです。これをpointArray、vertexArray、primArray、detailListと呼びます。 pointArrayは存在する必要があります。 vertexArrayはオプションです。 primArrayは存在する必要があります。 detailListはオプションです。 上述したArrayのサフィックスが付くテーブルはN個のサブテーブルを含むことができ、Nのサイズは自由に定義できます。 pointArrayの第k個のサブテーブルはpoint[k]あるいは“第kの点”と呼ぶことができます。 vertexArrayの第k個のサブテーブルはvertex[k]あるいは“第kのサブ点”と呼びます。 primArrayの第k個のサブテーブルはprim[k]あるいは“第kのプリミティブ”と呼びます。 detailList及び、上述の点、サブ点、プリミティブには、それ以上細分可能でないユニット、すなわちキーと値のペアが含まれます。これらのキーを一時的にK、値をVと呼びます。 Kは英数字とアンダースコアのみを含むことをお勧めし、純数字でないことをお勧めします。 Vには一次元、二次元、三次元、四次元、文字列、テクスチャID、及びインデックス集合の7種類があります。 任意の浮動小数点数x,y,z,wについて xまたは{x}は一次元Vと呼びます。 {x,y}は二次元Vと呼びます。 {x,y,z}は三次元Vと呼びます。 {x,y,z,w}は四次元Vと呼びます。 \"Hello! PixelsWorld!\"は文字列Vとして呼びます。 (Kの末尾4文字\"_tex\")かつ(Vが整数で対応テクスチャが存在する)場合、これはテクスチャIDVとして呼びます。 整数列a1,...,anの場合、{a1,a2,a3,...,an}をインデックス集合Vとして呼びます。 各点point[k]について、点の位置を表すKとして\"p\"が存在する必要があります。そうでなければ無効な点と見なされます。 各サブ点vertex[k]について、参照点IDを表すKとして\"pref\"が存在し、一次元Vを持つ必要があります。そうでなければ無効なサブ点と見なされます。 各プリミティブprim[k]について、プリミティブの種類を表すために\"type\"というKと文字列Vが存在する必要があり、同時にプリミティブの描画点順序を表すために\"vref\"または\"pref\"のKとインデックス集合Vが存在する必要があります。 オーバーライド優先順位 同じ名前のKに対し、次のようなオーバーライド優先順位を定義します： Houdiniと同様 vertex point prim detail 使用例： 以下のobjのprimには色情報（赤色）が含まれているため、最終的に赤色のみの三角形が生成されます。 PrimColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0}}, {p={100,0,0}}, {p={0,100,0}}, }, prim={ {type=\"triangle\",pref={1,2,3},color={1,0,0}}, }, } poly(obj) 一方、こちらのobjではprimとpointの両方にcolorがあるため、pointがより高い優先順位を持ち、最終的にカラフルな三角形が描画されます。 PointColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},color={0,1,1}}, {p={100,0,0},color={1,1,0}}, {p={0,100,0},color={1,0,1}}, }, prim={ {type=\"triangle\",pref={1,2,3},color={1,0,0}}, }, } poly(obj) Vertexの使用方法 Vertex（サブ点）はPoint（点）の情報を継承できます。 VertexColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0}}, {p={100,0,0}}, {p={0,100,0}}, {p={100,100,0}}, }, vertex={ {pref=1,color={1,0,0}}, {pref=2,color={1,0,0}}, {pref=3,color={1,0,0}}, {pref=2,color={0,1,0}}, {pref=3,color={0,1,0}}, {pref=4,color={0,1,0}}, }, prim={ {type=\"triangle\",vref={1,2,3,4,5,6}}, }, } poly(obj) prefは現在のvertexがどのpointを参照しているかを指し示します。prefはPoint referenceの省略形です。 prim内のvrefはVertex referenceの省略形です。 注意：Luaのテーブルでは、最初の要素の番号は0ではなく1です。 Vertexを使用しない場合は、このようになります： NoVertex.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},color={1,0,0}}, {p={100,0,0},color={1,0,0}}, {p={0,100,0},color={1,0,0}}, {p={100,100,0},color={0,1,0}}, }, prim={ {type=\"triangle\",pref={1,2,3,2,3,4}}, }, } poly(obj) シェーダーの付属 Polyの中でシェーダー言語を使用することも可能です。 FragColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},myattribute={1,0}}, {p={100,0,0},myattribute={0,1}}, {p={0,100,0},myattribute={0,0}}, {p={100,100,0},myattribute={1,1}}, }, prim={ { type=\"triangle\", pref={1,2,3,2,3,4}, frag=[==[ #define t ]==] .. tostring(time) .. [==[ void main(){ outColor = vec4(mod(myattribute*10+vec2(t),1),0,1); } ]==], }, }, } poly(obj) テクスチャの使用 下記のobjは、入力レイヤーをテクスチャとして使用し、シーンに出力します。 ある整数属性値のキー名に_texが付いている場合、その属性はテクスチャIDとして扱われます。 カスタムシェーダーを使用することで、1つのprimで複数のテクスチャを使用することが可能です。 テクスチャに関する詳細情報 UVTex.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},uv={0,0}}, {p={100,0,0},uv={1,0}}, {p={0,100,0},uv={0,1}}, {p={100,100,0},uv={1,1}}, }, prim={ { type=\"triangler\", pref={1,2,4,3}, my_tex=INPUT, }, }, } poly(obj) "},"contents/Lua/TransparencyRender.html":{"url":"contents/Lua/TransparencyRender.html","title":"透明オブジェレンダー法","keywords":"","body":"透明な形状のレンダリング 半透明の立方体を一列にレンダリングすると、次のような結果になります。 normalCubes.lua version3() in2out() dim3() fill(1,.5) move(width/2, height/2) for i = 1,10 do move(20,0,200) cube() end しかし、この結果は正しくありません。透明な立方体の後ろの部分が見えません。 カメラから遠い順にこれらの立方体をレンダリングすることで、正しい重ね合わせを行う必要があります： sortCubes.lua version3() in2out() dim3() fill(1,.5) sortarr = {} beginGroup() move(width/2, height/2) for i = 1,10 do move(20,0,200) local x,y,z = global2screen(local2global(0,0,0)) -- カメラの距離を取得 sortarr[i] = {z,getTransformMatrix()} -- {距離, 変換状態} のペア end endGroup() table.sort( sortarr, function(a,b) return a[1] > b[1] end -- z距離でソート ) for i = 1,10 do beginGroup(sortarr[i][2]) -- 変換状態を適用 cube() endGroup() end "},"contents/Lua/RunGLSL.html":{"url":"contents/Lua/RunGLSL.html","title":"LuaでGLSLを実行する","keywords":"","body":"LuaでGLSLを実行する 使用方法 glsl.lua version3() glsl(Your_code_string_here) 注意、文字列を括る際に[==[Your_code_string_here]==]を使用することをお勧めします。これにより、エスケープの問題が回避されます。通常、コードは以下の形式で記述する必要があります： glsl2.lua version3() glsl([==[ void main(){ outColor = vec4(uv,sin(time*10)/2+.5,1); } ]==]) 以下のコードを使用して、shadertoy.comからのコードをレンダリングできます。 shadertoy.lua version3() shadertoy(Your_shadertoy_code_here) "},"contents/GLSL/GLSLCode.html":{"url":"contents/GLSL/GLSLCode.html","title":"グラフィックスバーサーカーGLSL","keywords":"","body":"グラフィックバトラーGLSL このセクションでは、ピクセルの世界でGLSLを実行する方法を簡単に解説します。 GLSLとは何ですか？ GLSLはOpenGL Shader Language（オープンジーエル シェーダー ランゲージ）の略称で、OpenGLがサポートするGPUベースのレンダリング言語です。 主にピクセルレンダリングルールを記述し、GPUで計算を行います。 どうやって学ぶのか？ シェーダーの書をお勧めします。オンラインで無料で読むことができます。 グラフィック言語の利点 マザーボード上の中央処理ユニット(CPU)とグラフィックスカード上のグラフィックス処理ユニット(GPU)を比較すると、CPUはスーパーカーのようで、GPUは大型バスのようです。 少数の人員を運ぶのであれば、スーパーカーの性能は非常に優れています。 しかし、同じ作業を何度も行う必要がある場合(例えば画像を計算する場合)、膨大な数の人々を移動させることに例えられ、この場合、大型バスを選ぶ方が明らかに賢明です。 通常、私たちが学ぶプログラミング言語は、C/C++、Java、Pythonなど、CPU上で直接実行されます。 一方、GLSLのような言語は、GPU上で実行されるように設計された言語です。 画像を処理する際、GPUは非常に多くの“作業者”を一度に動員し、反復性の高い作業を行うことができます。その具体的な作業内容はGLSLによって指示されます。 GLSLの構文についての詳細は、shadertoy.comをご覧ください。いくつかの面白くて簡単な効果を見つけて、それがどのように機能するかを探索してみてください。 詳細: GLSLを実行する前に非常に多くの変数と関数を事前定義します。初心者であれば、ここは一時的に無視して構いません。 PixelsWorld V3.0.0は#version 330 coreを使用します。 ここをクリックして追加の事前定義コードを確認してください。 "},"contents/GLSL/RunGLSL.html":{"url":"contents/GLSL/RunGLSL.html","title":"GLSLの実装","keywords":"","body":"GLSLコードの実行 GLSLコードはGLSL(GPU)モードで実行してください。 \"World rule\"で\"Edit\"をクリックします。 この時、一部のコードがパネルに表示されます。 default.shader void main(){ outColor = getColor(uv); } このコードは入力ピクセルを出力ピクセルに送信します。 getColor(uv)をvec4(uv,0.0,1.0)に変更することで、きれいなuvカラーパターンを得ることができます。 uvcolor.shader void main(){ outColor = vec4(uv,0.0,1.0); } 次に、\"Ok\"をクリックすれば完了です。 通常、次のような結果が得られるはずです： "},"contents/GLSL/GetStart.html":{"url":"contents/GLSL/GetStart.html","title":"クイックスタート","keywords":"","body":"シェーダーコードを書くとはどんな感じ？ シェーダーコードは、Excelの表計算機能のようなものです。表に数式を入力すると、表がすべてのデータを処理してくれます。 もし表のデータを入力ピクセルとし、計算後の表を出力ピクセルと考えると、ピクセルの世界のコードはExcelの表計算式と同じように理解できます。 使用例：画像を明るくする 画像を明るくする最も簡単な方法は、すべてのピクセルの赤、緑、青の数値を上げることです。Excelの表計算では、次の手順を行う必要があります： これで、左側のすべてのピクセルデータを「明るく」できます。 ピクセルの世界に変えると、次のコードを入力する必要があります： bright_describe.shader outColor=getColor(uv)+vec4(0.2); つまり、現在の位置（uv）の入力ピクセルを取得し（getColor）、その4つのチャネル（赤、緑、青、透明）に0.2を加え（+vec4(0.2)）、計算結果を出力（outColor）に送ります（=）。 もちろん、この一行だけではピクセルの世界は正常に動作しないので、外側には「シェル」を1つ被せる必要があります。完全なコードは次のようになります： bright.shader void main(){ outColor=getColor(uv)+vec4(0.2); } 操作方法： 入力画像（右クリックして保存）： （元の作者リンク） 効果図： さらにコントロールを追加！ もちろん、単に0.2を加えるだけでは私たちが望む結果にはなりません。もっと制御可能にしたい場合は、0.2をslider[0]に置き換えることで、パネルのスライダーを使って効果を調整できます。 bright_control.shader void main(){ outColor=getColor(uv)+vec4(slider[0]); } しかし、もし値が負の場合、透明度も小さくなることに気づくでしょうが、通常透明度を変更したくないため、そのチャンネルを避ける必要があります。そうすると、レンダリングコードは次のように書く必要があります： bright_control.shader void main(){ vec4 inColor = getColor(uv); inColor.rgb = inColor.rgb + vec3(slider[0]); outColor = inColor; } 説明：まず入力ピクセルを4次元(vec4)変数inColorに一時保存し、それからrgb（赤緑青）3つのチャネルにslider[0]の数値を加えます。最後にinColorの値をoutColorに渡します。これにより、inColorのaチャネル（透明チャネル）はそのまま出力に送られます。 パラメータに名前を付ける 次の操作で、パラメータパネルを整理整頓されたものにすることができます： プリセットに保存 最後に、作成したコードを保存して、特に後で使うかもしれないコードをプリセットに保存することができます。詳細については、プリセット管理セクションを参照してください。 おめでとうございます！ あなたはピクセルの世界の基本的な使用方法を習得しました！ ピクセル世界ではコードを書くことができる以外に、shadertoyのサイトから面白いエフェクトを探し出して、ピクセル世界に持ち込むこともできます。shadertoyからのコードのレンダリング方法については、こちらを参照してください。 "},"contents/GLSL/Functions.html":{"url":"contents/GLSL/Functions.html","title":"内装関数","keywords":"","body":"関数 このセクションでは、組み込み関数を簡単に紹介します。これらの関数は宣言なしで使用できます。 "},"contents/GLSL/getColor.html":{"url":"contents/GLSL/getColor.html","title":"getColor","keywords":"","body":"getColor この関数には2つのバージョンがあります。getColor(vec2) と getColor(int, vec2) です。 getColor(vec2) 説明 : 指定された位置で入力レイヤーの色を取得します。 パラメータ: vec2：uv位置（各次元0〜1） 戻り値 : vec4 : RGBAカラー（各次元0〜1） getColor(int, vec2) 説明 : 特定の入力レイヤーの指定された位置のピクセルを取得します。 パラメータ : int : レイヤーインデックス, -1（または AE_INPUT_LAYER）は入力レイヤーを指し、0-9の数字はプラグインパネルの対応するレイヤーパラメータ0-9を指します（PW_TEMP_LAYER (レイヤーインデックス-2) Luaレンダリングモード時に使用） vec2 : uv座標 戻り値 : vec4 : RGBAカラー 注意 : つまり、getColor(AE_INPUT_LAYER, uv); とgetColor(uv) は同じ効果を持ちます。 getColor(n, uv); はlayer[n]のピクセル情報を返すことができます。 "},"contents/GLSL/uvxy.html":{"url":"contents/GLSL/uvxy.html","title":"uv2xy,xy2uv","keywords":"","body":"uv2xy, xy2uv これらの2つの関数はUV座標とXY座標の間の変換に使用されます。 単に掛け算と割り算を行います。 uv2xy(vec2) 説明： 指定されたuv値からxy値を計算します。 パラメータ： vec2 : uv位置値。 戻り値： vec2 : xy位置値。 注意： レイヤーサイズが1280 x 720の場合、uv2xy(vec2(0.1,0.5)); は vec2(128.0,360.0); を返します。 xy2uv(vec2) 説明： 指定されたxy値からuv値を計算します。 パラメータ： vec2 : xy位置値。 戻り値： vec2 : uv位置値。 注意： レイヤーサイズが1920 x 1080の場合、xy2uv(vec2(192,108)); は vec2(0.1,0.1); を返します。 "},"contents/GLSL/LinkParameters.html":{"url":"contents/GLSL/LinkParameters.html","title":"パラメータリンク","keywords":"","body":"リンクパラメータ 外部パラメータを使用することで、アニメーション設定が可能です。 現在、アニメーションに使用できる7種類のパラメータがあります。 スライダー 角度 ポイント 3D ポイント チェックボックス カラー レイヤー そして、各パラメータセットには10個のコントローラが利用可能です。 例 : link_slider.shader void main(){ outColor = vec4(uv,slider[0],1.0); } 例えば、スライダー0を変更すると、プレビュー画面の色が変わります。 詳細 PixelsWorldでのパラメータの宣言方法は以下の通りです： parameters.shader uniform float slider[10]; uniform float angle[10]; uniform bool checkbox[10]; uniform vec2 point[10]; uniform vec3 point3d[10]; uniform vec4 color[10]; uniform sampler2D layer[10]; uniform sampler2D inLayer; 注目 \"inLayer\" は入力レイヤーを表します。 sampler2D はGLSLで提供されている変数タイプで、その変数タイプを理解する必要はありません。レイヤーパラメータについて知りたい場合は、\"getColor\"を参照してください。 \"uniform\" はグローバル変数を表します。 "},"contents/GLSL/debug.html":{"url":"contents/GLSL/debug.html","title":"デバッグ","keywords":"","body":"Debug（デバッグ） プラグインパネルでdebug（デバッグ）チェックボックスをチェックします。 エラーメッセージがある場合、赤い文字で画面に表示されます。 "},"contents/GLSL/Advanced_settings.html":{"url":"contents/GLSL/Advanced_settings.html","title":"高級設定","keywords":"","body":"高度な設定 このセクションでは、エフェクトパネルの高度なオプション設定について説明します。 Wrap U/V サンプラー サンプリングしたピクセルが画像の境界を超えた場合、このパラメータはgetColor()の結果に影響します。 テストコード（素材にPixelsWorldを適用）: wrap_uv_sampler.shader void main(){ outColor = getColor(uv*10); } 拡大/縮小サンプラー サンプラーが周囲のピクセルを補間サンプリングする際に、このパラメータはgetColor()の動作に影響します。 テストコード（素材にPixelsWorldを適用）: wrap_uv_sampler.shader void main(){ outColor = getColor(uv*0.1); } 同じピクセルスタイルの効果を構築したい場合、このオプションを最近接ピクセルに設定してください。 ミップマップ 縮小時の材質のカラーサンプリング方法を指定することができます。 wrap_uv_sampler.shader void main(){ outColor = getColor(uv*10); } "},"contents/GLSL/predefined.html":{"url":"contents/GLSL/predefined.html","title":"プリコード","keywords":"","body":"プリデファインコード シェーダーコードは実行前に、特定の機能をサポートするためにあらかじめ設定された環境コードで囲まれます。 GLSLモードは前置コードのみを含みます。 shadertoyモードは前置コードと後置コードの両方があります。 GLSLモード 前置コード： pre_frag_shader_glsl.frag #define gl_Position uv2xy(uv) #define gl_FragCoord uv2xy(uv) #define gl_FragColor outColor #define INPUT_LAYER_INDEX -1 #define OUTPUT_LAYER_INDEX -2 #define AE_INPUT_LAYER -1 #define PW_TEMP_LAYER -2 out vec4 outColor; in vec2 uv; uniform float slider[10]; uniform float angle[10]; uniform bool checkbox[10]; uniform vec2 point[10]; uniform vec3 point3d[10]; uniform vec4 color[10]; uniform sampler2D layer[10]; uniform vec2 layerResolution[10]; uniform sampler2D inLayer; uniform sampler2D outLayer; uniform float time; uniform float inpoint; uniform float duration; uniform float comp_time; uniform vec4 date; // vec4(year,month,day,hour*3600 + minute*60 + second + millisecond/1000.) uniform float fps; uniform float width; uniform float height; uniform vec2 origin; uniform vec2 resolution; uniform vec2 downsample; uniform mat4 camera_matrix; uniform vec4 camera_info; // x,y: resolution, z: distance to plane, w: distance to focus. uniform bool camera_perspective; uniform sampler1D inWaveL; // 左側の波形サンプル uniform sampler1D inWaveR; // 右側の波形サンプル uniform float inWaveN; // 波形サンプル数 uniform float inWaveS; // サンプルレート、プラグインパネルの設定。デフォルト: 44100. uniform vec2 inWaveT; // vec2(sampleStartTime, sampleEndTime), 単位: second. v3.4.0から新登場 uniform sampler1D inSpecL; // 左側のスペクトラムサンプル uniform sampler1D inSpecR; // 右側のスペクトラムサンプル uniform float inSpecN; // スペクトラムサンプル数 uniform vec2 inSpecF; // vec2(spectrumStartFrequency, spectrumEndFrequency), 単位: hz. v3.4.0から新登場 vec4 getColor(int layerId, vec2 coord) { if(layerId==AE_INPUT_LAYER) return texture(inLayer,coord); if(layerId==PW_TEMP_LAYER) return texture(outLayer,coord); else if(layerId>=0 && layerId shadertoyコード 前置コード pre_frag_shader_shadertoy.frag #define gl_Position (_PixelsWorld_uv * iResolution.xy) #define gl_FragCoord (_PixelsWorld_uv * iResolution.xy) #define gl_FragColor _PixelsWorld_outColor #define _PixelsWorld_INPUT_LAYER_INDEX -1 #define _PixelsWorld_OUTPUT_LAYER_INDEX -2 #define _PixelsWorld_AE_INPUT_LAYER -1 #define _PixelsWorld_PW_TEMP_LAYER -2 uniform vec3 iResolution; uniform float iTime; uniform float iTimeDelta; uniform int iFrame; // uniform float iChannelTime[4]; uniform vec4 iMouse; uniform vec4 iDate; uniform sampler2D iChannel0; uniform sampler2D iChannel1; uniform sampler2D iChannel2; uniform sampler2D iChannel3; uniform vec3 iChannelResolution[4]; uniform float _PixelsWorld_slider[10]; uniform float _PixelsWorld_angle[10]; uniform bool _PixelsWorld_checkbox[10]; uniform vec2 _PixelsWorld_point[10]; uniform vec3 _PixelsWorld_point3d[10]; uniform vec4 _PixelsWorld_color[10]; uniform sampler2D _PixelsWorld_layer[10]; uniform vec2 _PixelsWorld_layerResolution[10]; uniform sampler2D _PixelsWorld_inLayer; uniform sampler2D _PixelsWorld_outLayer; uniform float _PixelsWorld_time; uniform float _PixelsWorld_inpoint; uniform float _PixelsWorld_duration; uniform float _PixelsWorld_comp_time; uniform vec4 _PixelsWorld_date; uniform float _PixelsWorld_fps; uniform float _PixelsWorld_width; uniform float _PixelsWorld_height; uniform vec2 _PixelsWorld_origin; uniform vec2 _PixelsWorld_resolution; uniform vec2 _PixelsWorld_downsample; uniform mat4 _PixelsWorld_camera_matrix; uniform vec4 _PixelsWorld_camera_info; uniform bool _PixelsWorld_camera_perspective; uniform sampler1D _PixelsWorld_inWaveL; uniform sampler1D _PixelsWorld_inWaveR; uniform float _PixelsWorld_inWaveN; uniform float _PixelsWorld_inWaveS; uniform vec2 _PixelsWorld_inWaveT; uniform sampler1D _PixelsWorld_inSpecL; uniform sampler1D _PixelsWorld_inSpecR; uniform float _PixelsWorld_inSpecN; uniform vec2 _PixelsWorld_inSpecF; in vec2 _PixelsWorld_uv; out vec4 _PixelsWorld_outColor; vec4 _PixelsWorld_getColor(int layerId, vec2 coord) { if(layerId==_PixelsWorld_AE_INPUT_LAYER) return texture(_PixelsWorld_inLayer,coord); if(layerId==_PixelsWorld_PW_TEMP_LAYER) return texture(_PixelsWorld_outLayer,coord); else if(layerId>=0 && layerId 後置コード post_frag_shader_shadertoy.frag void main(){ mainImage(_PixelsWorld_outColor, _PixelsWorld_uv * iResolution.xy); } "},"contents/GLSL/shadertoy.html":{"url":"contents/GLSL/shadertoy.html","title":"テンプレート聖域shadertoy","keywords":"","body":"テンプレート聖域shadertoy 使用方法 このモードでは、shadertoy.com のコードを直接使用することができます。 注意 shadertoy.comからのすべてのコードがPixelsWorldで完全に動作するわけではありません (例: オーディオ入力が必要なもの、VRサポートが必要なもの、ループバッファ参照を含むコードなど) 詳細 shadertoyモードで独自にパラメータパネルを呼び出したい場合は、GLSLモード下のすべての変数に_PixelsWorld_プレフィックスを付けることで利用可能です。 例えば、GLSLモード下のslider[0]は_PixelsWorld_slider[0]になります。 すべてのグローバル変数の定義については、こちらを参照してください。 もちろん、shadertoyモードで_PixelsWorld_プレフィックスを持つ変数を独自に定義することはお勧めしません。 バッファーの使用 Shadertoyには4つのバッファーがあり、PixelsWorldでもバッファーを実装することができます。 ループしないバッファー 使用しているエフェクトに、バッファー間のループ呼び出しがない場合（上図の下半分のようなもの）は、エフェクト内のバッファーはループしないバッファーに属します。それらを呼び出すには、以下のコードテンプレートを使用します（注意：Luaモードに切り替える必要があります）。 例：https://www.shadertoy.com/view/4dVGRW からのコード このエフェクトはBufferAを使用しているので、以下のコードの4行目でAをtrueに設定します。 BufferAは最終的にMain画像のiChannel0にバインドされるので、以下のコードの15行目でAtoMainを0に設定します。 その後、BufferAとMainのコードをそれぞれ対応する変数にコピーするだけです。 最後に、計算結果が正確になるように、プラグインパネルのAdvanced->Internal texture formatをFloating point 32 bit x RGBA (HDR)に設定して、PixelsWorldが内部でアルファチャンネルの値を削らないようにします。 Luaレンダーモードであることを確認してください。 rotatingCubes.lua version3() enable = { A=true, B=false, C=false, D=false, -- '-1': 無効化 -- '0~3': どのiChannelに設定するか AtoB = -1, AtoC = -1, AtoD = -1, AtoMain = 0, BtoC = -1, BtoD = -1, BtoMain = -1, CtoD = -1, CtoMain = -1, DtoMain = -1, } mainCode = [==[ // ここにメインコードを貼り付けます。 mat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) { vec3 rr = vec3(sin(roll), cos(roll), 0.0); vec3 ww = normalize(target - origin); vec3 uu = normalize(cross(ww, rr)); vec3 vv = normalize(cross(uu, ww)); return mat3(uu, vv, ww); } vec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) { mat3 camMat = calcLookAtMatrix(origin, target, 0.0); return normalize(camMat * vec3(screenPos, lensLength)); } vec2 squareFrame(vec2 screenSize, vec2 coord) { vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0; position.x *= screenSize.x / screenSize.y; return position; } vec2 getDeltas(sampler2D buffer, vec2 uv) { vec2 pixel = vec2(1. / iResolution.xy); vec3 pole = vec3(-1, 0, +1); float dpos = 0.0; float dnor = 0.0; vec4 s0 = texture(iChannel0, uv + pixel.xy * pole.xx); // x1, y1 vec4 s1 = texture(iChannel0, uv + pixel.xy * pole.yx); // x2, y1 vec4 s2 = texture(iChannel0, uv + pixel.xy * pole.zx); // x3, y1 vec4 s3 = texture(iChannel0, uv + pixel.xy * pole.xy); // x1, y2 vec4 s4 = texture(iChannel0, uv + pixel.xy * pole.yy); // x2, y2 vec4 s5 = texture(iChannel0, uv + pixel.xy * pole.zy); // x3, y2 vec4 s6 = texture(iChannel0, uv + pixel.xy * pole.xz); // x1, y3 vec4 s7 = texture(iChannel0, uv + pixel.xy * pole.yz); // x2, y3 vec4 s8 = texture(iChannel0, uv + pixel.xy * pole.zz); // x3, y3 dpos = ( abs(s1.a - s7.a) + abs(s5.a - s3.a) + abs(s0.a - s8.a) + abs(s2.a - s6.a) ) * 0.5; dpos += ( max(0.0, 1.0 - dot(s1.rgb, s7.rgb)) + max(0.0, 1.0 - dot(s5.rgb, s3.rgb)) + max(0.0, 1.0 - dot(s0.rgb, s8.rgb)) + max(0.0, 1.0 - dot(s2.rgb, s6.rgb)) ); dpos = pow(max(dpos - 0.5, 0.0), 5.0); return vec2(dpos, dnor); } void mainImage(out vec4 fragColor, in vec2 fragCoord) { vec3 ro = vec3(sin(iTime * 0.2), 1.5, cos(iTime * 0.2)) * 5.; vec3 ta = vec3(0, 0, 0); vec3 rd = getRay(ro, ta, squareFrame(iResolution.xy, fragCoord.xy), 2.0); vec2 uv = fragCoord.xy / iResolution.xy; vec4 buf = texture(iChannel0, fragCoord.xy / iResolution.xy); float t = buf.a; vec3 nor = buf.rgb; vec3 pos = ro + rd * t; vec3 col = vec3(0.5, 0.8, 1); vec2 deltas = getDeltas(iChannel0, uv); if (t > -0.5) { col = vec3(1.0); col *= max(0.3, 0.3 + dot(nor, normalize(vec3(0, 1, 0.5)))); col *= vec3(1, 0.8, 0.35); } col.r = smoothstep(0.1, 1.0, col.r); col.g = smoothstep(0.1, 1.1, col.g); col.b = smoothstep(-0.1, 1.0, col.b); col = pow(col, vec3(1.1)); col -= deltas.x - deltas.y; fragColor = vec4(col, 1); } ]==]; commonCode = [==[ // ここに共通コードを貼り付けます。 ]==] bufferACode = [==[ // ここにBuffer Aのコードを貼り付けます。 float sdBox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); } vec2 mirror(vec2 p, float v) { float hv = v * 0.5; vec2 fl = mod(floor(p / v + 0.5), 2.0) * 2.0 - 1.0; vec2 mp = mod(p + hv, v) - hv; return fl * mp; } vec2 rotate2D(vec2 p, float a) { return p * mat2(cos(a), -sin(a), sin(a), cos(a)); } float map(vec3 p) { float r = iMouse.z > 0.0 ? iMouse.x / 100.0 : iTime * 0.9; p.xz = mirror(p.xz, 4.); p.xz = rotate2D(p.xz, r); float d = sdBox(p, vec3(1)); d = min(d, sdBox(p, vec3(0.1, 0.1, 3))); d = min(d, sdBox(p, vec3(3, 0.1, 0.1))); return d; } mat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) { vec3 rr = vec3(sin(roll), cos(roll), 0.0); vec3 ww = normalize(target - origin); vec3 uu = normalize(cross(ww, rr)); vec3 vv = normalize(cross(uu, ww)); return mat3(uu, vv, ww); } vec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) { mat3 camMat = calcLookAtMatrix(origin, target, 0.0); return normalize(camMat * vec3(screenPos, lensLength)); } float calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) { float latest = precis * 2.0; float dist = +0.0; float type = -1.0; float res = -1.0; for (int i = 0; i maxd) break; float result = map(rayOrigin + rayDir * dist); latest = result; dist += latest; } if (dist = 0 and sch ループ バッファー うーん...もしループバッファーを使用したい場合、PixelsWorldでそれらを使用することは強くお勧めしません。（しかし、実現することは可能です。AeとPixelsWorldとの長い夜の戦いに備える必要があります。準備ができましたか>>>） "},"contents/Lua/JavaScript.html":{"url":"contents/Lua/JavaScript.html","title":"世界の郊外JavaScript","keywords":"","body":"JavaScriptコード Lua (CPU & GPU) モードでは、ピクセルワールドでjsを使用してJavaScriptコードを実行できます。 executeJS.lua version3() js(\"alert('Hello PixelsWorld!')\"); 注：Aeプログラムの構造上の問題から、ピクセルワールドでjsコード（特にUIコントロールのパラメータ情報を要求するもの）の使用は推奨しません。jsコードを使って簡単なローカル変数間の計算を行うことができます。 "},"contents/Lua/CMDCode.html":{"url":"contents/Lua/CMDCode.html","title":"世界の基盤CMD","keywords":"","body":"CMDコード Lua (CPU & GPU) モードで、ピクセルワールドはcmd(\"Your cmd commands\")を使用してCMDコマンドを実行できます。 executeCMD.lua version3() cmd(\"echo Hello PixelsWorld! & pause\"); "},"contents/Serial/SerialAttention.html":{"url":"contents/Serial/SerialAttention.html","title":"規約","keywords":"","body":"シリアル番号の使用規約 注意: このページの条項は、aescripts.comプラットフォームで購入したお客様には適用されません。 一つのシリアル番号にはN個の「登録回数」が含まれています（Nは1以上） 一つの「登録回数」は、一台のコンピュータに永久に登録されます 一台のコンピュータの一つの「登録回数」は、複数のバージョンのAeで使用可能です 一台のコンピュータを登録すると「登録回数」が一つ減少し、既登録のコンピュータを解除すると「登録回数」が一つ増加します 登録と解除の操作のみ、インターネット接続が必要です。つまり、登録後はオフラインで使用可能です コンピュータのマザーボードまたはCPUを交換する前に、シリアル番号を解除し、交換後に再登録してください。シリアル番号の解除を忘れた場合は、メールでご連絡ください。 シリアル番号は個人情報と紐付いていないため、推奨しませんが、友人間で伝達または転売して使用することが許可されています。伝達使用または転売が発生した場合、使用および利益問題に関して、未来ビジュアル演繹（えんえき）チームは一切責任を負いません。 「登録回数」は購入時に基本的に一つのみです。複数のデバイスで同時にピクセルワールドを使用したい場合は、必要な数のシリアル番号を購入してください。我々は相応の「登録回数」のシリアル番号を送信いたします。 "},"contents/Serial/Lost.html":{"url":"contents/Serial/Lost.html","title":"助けて，deactivateし忘れた！","keywords":"","body":"助けて、登録解除を忘れた！ 解決策 解決策: 新しいマシンで登録 シリアルナンバー認証システムは、クラウド上で1ヶ月以上アクティブでないシートを自動的に削除します。 もしエラーメッセージ key_already_used を受け取った場合： これは前の席がまだ自動削除されるのに十分な時間が経過していないことを示していますので、最長で1ヶ月待ってから再試行してください。 "},"contents/QA/EntryPointErr.html":{"url":"contents/QA/EntryPointErr.html","title":"エラー： Couldn't find main entry point for PixelsWorld.aex (48::72)","keywords":"","body":"エラーCouldn't find main entry point for PixelsWorld.aex (48::72) PixelsWorldを初めてテスト/使用する際に以下のエラーメッセージが表示される場合、次の項目を確認してください。 Creative Cloudを使用してAeを最新バージョンに更新する必要があります（CC2019の場合は16.1.3+、2020の場合は17.5.1+を推奨）。 Windows10を最新バージョンに更新する必要があります（Windows 10 20H2以降を推奨）。 最新のグラフィックカードドライバーを持っている必要があります。 グラフィックカードがOpenGL 3.3以上のバージョンのプロトコルにハードウェアで対応している必要があります（OpenGL Extensions Viewerツールを使用して確認できます）。 C:\\Windows\\System32ディレクトリにOpenCL.dllが存在する必要があります。 "}}