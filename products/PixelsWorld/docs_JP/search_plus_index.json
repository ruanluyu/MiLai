{"./":{"url":"./","title":"今日、創造神になってきます！","keywords":"","body":"創造神になりましょう！ PixelsWorld マニュアルバージョン : v3.4.2 著者：中梓星音 English version 中文 ダウンロード(日本語) ダウンロード(English) ダウンロード(中文) 注意：本マニュアルはまだ翻訳途中で一部の文章は英語となっています。 翻訳ミス報告はこちらでお願いします。 ピクセルスワールドへようこそ！ PixelsWorldのコツやエッセンスはこのページに記載されています。このページのコンテンツさえマスターすれば、PixelsWorldの全てを把握できるようになります 簡単に言えば PixelsWorldはコードでグラフィックスを描くものです ほかのアーティストが創作したコードを直接使えます。 簡単なグラフ描画言語を学んで自らグラフを作ることができます。 高度なGLSLコードを使い、VFXをゼロから構築することもできます。 PixelsWorldでコードを描くというのはどんな感じ？ PixelsWorldは描画ロボットのことと思ってもいいです。ユーザーはグラフの種類と描く地点を順番に伝えると、そのロボットは命令に応じてグラフを描いてくれます。 例えば、いまあなたは画面の中央に家を描こうとするシチュエーションを考えましょう。しかし、ペンを持っているのはあなたの親友高橋さんです。さて、あなたのいまから下す命令を考えましょう。 通常我々はこう伝えるのでしょう： DrawHouse.myBro 画面の中央に家を描け。 もちろん、人間の場合はその主旨は伝わります。もし、機械をシミュレート為に高橋さんの語彙量に制限をかけて、「グラフの種類と描く地点」のみが許されるとすればどうでしょう。我々はこう伝えるのでしょう： DrawHouse2.myBro 画筆を画面の中央に移動させろ 画筆に黄色をつけろ 画筆のある位置を中心に１０cmの正方形を描け 画筆を上へ５cm移動させろ 画筆に赤をつけろ 画筆のある位置を基準に、底が１５cm、高が１０cmの二等辺三角形を描け。 これで高橋さんは家の描く手順にしたがってあなたの思いどおりに家を仕上げられます。 実際、上の命令は、まさにPixelsWorldで描くべき命令です。具体的に、それに対応するコードは次のようになります。 DrawHouse3.lua version3() -- バージョン３を使え（必須コード） move(width/2, height/2) -- 画筆を画面の中央に移動させろ rotateX(PI) -- 上へ向け fill(1,1,0) -- 画筆に黄色をつけろ（Red=1,Green=1,Blue=0） rect(100) -- 画筆のある位置を中心に１００px大きさの正方形を描け fill(1,0,0) -- 画筆に赤をつけろ（Red=1,Green=0,Blue=0） move(0,50) -- 画筆を上へ５０px移動させろ tri(150,100) -- 画筆のある位置を基準に、底が１５０px、高が１００pxの二等辺三角形を描け。 ここで、多分予想外の命令が一つ出ました：rotateX(PI)。Aeでは、Y軸は普通は下向きなので、このY軸をX軸に沿って180度回転させる必要があります。この命令を除くと、次のmove(0,50)は画筆を下へ５０px移動させてしまいます。 天地開闢、世界を作る第一歩を踏みましょう！ まず、PixelsWorldを平面レーヤーに適用しましょう。 言語オプション（Language）はLuaモードであるかどうかを確認し、Editボタンをクリックしてください。それでは、次の図の指示に従って家の描画を完成しましょう。 この家の配色をパラメーターで制御できるようにしてみましょう： DrawHouse4.lua version3() -- バージョン３を使え（必須コード） move(width/2, height/2) -- 画筆を画面の中央に移動させろ rotateX(PI) -- 上へ向け fill(color(0)) -- 画筆に０号色をつけろ rect(100) -- 画筆のある位置を中心に１００px大きさの正方形を描け fill(color(1)) -- 画筆に１号色をつけろ move(0,50) -- 画筆を上へ５０px移動させろ tri(150,100) -- 画筆のある位置を基準に、底が１５０px、高が１００pxの二等辺三角形を描け。 これでOKボタンを押すと、なんと、家が消えてしまいました！ 実際家は消えたのではなく、ただ色のパラメーターの初期値が黒だったからです。 Colors欄を開いて、ここであなたの好きな色を選べばいいです。 「村長は俺だ！」家をたくさん建てましょう。 コードを使う一つのメリットは、重複度の高いことをしてれることです。 Lua言語では、一段落のコードをループしてくれる機能があります。 RepeatHouse.lua version3() -- バージョン３を使え（必須コード） move(width/2, height/2) -- 画筆を画面の中央に移動させろ rotateX(PI) -- 上へ向け for i=1,3 do -- ループ開始（計３回） fill(color(0)) -- 画筆に０号色をつけろ rect(100) -- 画筆のある位置を中心に１００px大きさの正方形を描け fill(color(1)) -- 画筆に１号色をつけろ move(0,50) -- 画筆を上へ５０px移動させろ tri(150,100) -- 画筆のある位置を基準に、底が１５０px、高が１００pxの二等辺三角形を描け。 move(0,-50) -- 画筆を下へ５０px移動させろ move(175,0) -- 画筆を右へ１７５px移動させろ end -- ループ終了 最後に、後日便利の為、色パラメーターに名前をつけましょう。 コマンドのセーブ、再利用 注意：ここで、ローカルディスクにファイルを書き込む為の管理者権限が必要です。管理者権限を持っていない場合、Aeを管理者モードで再開してください。 まず、プリセットコラムを新規作成しましょう。 作ったコラムで、コードをプリセットとして保存しましょう。 プリセットコードの適用 プリセットを選択し、右のReplaceボタンをクリックしてください。 おめでとうございます！ これであなたは、PixelsWorldのほぼ全部の利用方法をマスターしました。 >>>次のステップ：第三章より描画言語（Lua）の詳細を学びましょう。 PixelsWorld構成図 PixelsWorld能力範囲 "},"contents/HowTo.html":{"url":"contents/HowTo.html","title":"入手とダウンロード","keywords":"","body":"入手とダウンロード 入手方法 購入ページ/ダウンロードページ 「MiLai」フォルダーを次のパスにおいてください： AEルートフォルダー/Support Files/Plug-ins/ プラグインは次のパスにあるかどうかを確認してください： AEルートフォルダー/Support Files/Plug-ins/MiLai/PixelsWorld.aex 適用方法 Adobe After Effectsを開きます. \"Ctrl + N\"　でコンポジションを新規します。 平面レイヤーを新規します。 新規したレイヤーを選択肢ます。 右クリック => エフェクト => MiLai => PixelsWrold \"Edit\" をクリックし \"世界ルール\" を変えます。 ここでパネルが出てきます。 \"Preset list\"　でお気に入りのコラムを選択肢て下のリストから一つのプリセットを選択してください。 \"Replace\"をクリックしてください。 \"Ok\"　をクリックしてください。 "},"contents/Editor/ScriptWindow.html":{"url":"contents/Editor/ScriptWindow.html","title":"世界ルール　エディター","keywords":"","body":"世界ルール　エディター エディター プラグインパネルのWorld formulaとなりのEditボタンを押すと、世界ルール　エディターが開かれます。 ここで、記述便宜上、異なるエリアを次のようにハイライトしておきます。 ◆コードエリア コードエリアで、コード入力はできます。 このエリアのLanguage設定は、プラグインパネルにあるLanguage設定より優先度が高いです。(default)とは「パネルのほうの設定を変えずに維持する」という意味です。 ◆参照リスト ここで、よく使われているコードが挙げられています。現在、このリストは読み取り専用です。 ◆パラメーター設定 ここで、パラメーター名とパラメーター初期値を一覧することができます。Parameter managerボタンからパラメーター管理パネルが開けます。Parameter managerも参照してください。 パラメーター設定はコードと一緒にプリセットに保存できます。 ◆プリセットリスト すべてのローカルプリセットファイルはここのポップアップメニューにあります。 プリセットに関するの定義をここでここで述べておきます。 ファイル名の拡張子が .pwp で、 PixelsWorld.aexの隣にあるJSON 様式のファイルを「プリセットコラム」と我々は呼びます。 一つのプリセットコラムの中に若干の「プリセット」が入っています。 「プリセット」はポップアップメニューの下のリストに列挙されています。 ◆コードプレビュー 選択されているプリセットの内容をここでチェックすることができます。Replaceボタンを押すと、選択されたプリセットのコードを左のコードエリアに既存のコードを置き換えられます。 コードのみを置換し、設定を置き換えたくない場合は、パラメーター設定プレビューのApply when replaceのチェックを外してからReplaceボタンを押してください。 プリセットコードを今のコードを上書きせず、先頭につなげたい場合はボタンを、後ろにつなげたい場合はBottom>>ボタンを押してください。 ◆パラメーター設定プレビュー 選択されているプリセットのパラメーター設定をここでチェックできます。プリセットの設定を適用するにはApplyボタンを押してください。 Apply when replaceは「コードエリアのReplaceボタンを押すと自動的にこのエリアのApplyボタンを押してくれる」という意味です。 "},"contents/Editor/ParameterWindow.html":{"url":"contents/Editor/ParameterWindow.html","title":"パラメータ　エディター","keywords":"","body":"パラメータ　エディター 世界ルール　エディターのParameter managerボタンを押すと、次のパラメータ　エディターを開くことができます。 ルール パラメーター名を左に、パラメーター初期値を右に入力してください。（初期値範囲：十進数 0~1、範囲越え可能） Clear names パラメーター名を消します。 Clear all names すべてのパラメーター名を消します。 Reset names パラメーター名を初期値に戻します。 Reset all names すべてのパラメーター名を初期値に戻します。 Reset values パラメーター初期値を初期値を戻します。 Reset all value すべてのパラメーター初期値を初期値を戻します。 注意：pointと3dpointの範囲は0~1に収められています。例えば、1280x720のレイヤーに、0.5, 0.5をpointの初期値とすれば、PixelsWorldは自動的に640x360に換算します。 文字コード PixelsWorldはutf-8のパラメーター名をサポートしています。 識別されない文字コードは?マークになります。 異国環境や合同作業の場合、ASCII文字コードのパラメーター名の使用を推奨します。 "},"contents/Editor/SavePresets.html":{"url":"contents/Editor/SavePresets.html","title":"プリセット管理","keywords":"","body":"プリセット管理 プリセットの保存 World formula editorにおいて、Save as presetボタンを押し、名前を入力するコードとパラメーター設定がプリセットとして保存されます。 注意：既存の名前で保存すると上書きが発生します。 プリセットの上書き保存 World formula editorにおいて、Save as presetボタンを押し、既存の名前を入力するコードとパラメーター設定がプリセットとして保存されます。 注意：World formula editorではすべての操作を取り消すことができません。 プリセットの名前変更 変更したいプリセットをダブルクリックし、入力欄にREMOVEとSORT以外の名前を入力してください。 プリセットのアルファベット順ソート 変更したいプリセットをダブルクリックし、入力欄に大文字SORTを入力してください。 プリセットの削除 変更したいプリセットをダブルクリックし、入力欄に大文字REMOVEを入力してください。 プリセットコラムの新規作成 Preset listのAddボタンを押し、名前を入力すると新しいコラムが新規作成されます。 注意： 既存の名前は使用不可となります。 新規作成が失敗の場合、管理者権限でAeを再開してください。 プリセット仕様 フォーマット： utf-8・JSON 暗号化無し プリセットのアップロード及び公式整合リクエスト アップロードしたいプリセットをZzStarSound@gmail.com宛てに作者名前と説明文付きで送ってください。 "},"contents/Lua/LuaCode.html":{"url":"contents/Lua/LuaCode.html","title":"世界の中心Lua","keywords":"","body":"Lua コード 最初の第一章で紹介した言語の名前はLuaでした。 Luaは手続き型・プロトタイプベースのオブジェクト指向・関数型・データ駆動型のスクリプト言語である。 --Wiki Luaバージョン：Lua5.3 注意：PixelsWorld v3.2.0より、Lua5.4に変更しました。 簡単に言えば、Luaは、Aeとユーザーの間の架け橋であり、コミュニケーション通路の役を果たしています。LuaはAeスクリプト言語に似ているため、プログラミング経験ゼロの人でもPixelsWorldを楽しめます。また、小行数のスクリプトでもバラエティー満ちたシーンを構築可能です。例えば、Aeカメラでキューブをレンダーするには、次のコードを書けば十分です： DrawCube.lua version3() move(width/2,height/2) dim3() cube(300) dim3()は三次元モードでレンダーするという意味です。 GLSLコードをレンダーするには、次のように書きます： RunGlsl.lua version3() glsl([==[ void main(){ vec3 col = 0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4)); outColor = vec4(col,1.0); } ]==]) shadertoyのコードをレンダーするには、次のように書きます： RunShadertoy.lua version3() pw.shadertoy([==[ void mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec2 uv = fragCoord/iResolution.xy; vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)); fragColor = vec4(col,1.0); } ]==]) Luaでは、次のことができます： ピクセルデータの読み取り ピクセルデータの書き込み JavaScriptの実行 GLSLの実行 パラメーターの読み取り 外部Cライブラリの実行 (COOL!) 外部Luaモデルの読み取り PixelsWorld構成図 "},"contents/Lua/RunLua.html":{"url":"contents/Lua/RunLua.html","title":"Luaの実装","keywords":"","body":"Luaの実装 まず、Lua ( CPU & GPU )　モードに切り替えてください。 次のコードをエディターに入力してください。 hello.lua version3() a = 5+6 b = \"PixelsWorld\" c = \"is cool!\" d = time e = slider(0) f = \"5 + 6 = \" .. a .. \"\\nMessage : \" .. b .. \" \" .. c .. \"\\nCurrent time is : \" .. d .. \" (s)\\nValue of slider0 is : \" .. e print(f) a..b は文字列aとbを連結する操作です。 print()：文字列を出力する関数 slider()：スライダーの値を読み取る関数 Lua言語では;を行の最後につけることが可能ですが、必須ではありません。 結果として、画面の左上に文字が出力されます。 "},"contents/Lua/WriteLocalCode.html":{"url":"contents/Lua/WriteLocalCode.html","title":"ローカルコード","keywords":"","body":"ローカルコードの読み取り PixelsWorldは、txt形式のファイルを読み取れる為、ローカルでユーザーが好きなエディターでコードを書くことが可能です。 システムディスク（通常C:\\）でないほかのディスクでtxtファイルを作成してください。 loadTxt.lua version3() runFile([[d:\\mycode.txt]]) -- Replace to your path ここで、\"d:\\mycode.txt\"ではなく、[[d:\\mycode.txt]]を使う理由は\\が制御文字として扱われることを避けるからです。 実際、仕様がテキストファイルでさえあれば、拡張子は任意です(*.lua, *.code, *.magic)。 次のコードを使ってAeプロジェクトファイル周辺に置かれているコードファイルを読み取れます。 loadTxt.lua version3() runFile( projectFolder .. [[mycode.txt]]) -- Replace to your file name 注意：projectFolderを使うには、Aeプロジェクトの保存が必須です。さもなければ、projectFolderは空文字列になってしまいます。 まだおわってない！ ローカルでファイルの書き込みが終わって保存しても、PixelsWorldは直ぐにコードをシーンに反映できません。PixelsWorldにコードをロードさせるために、Ctrl + Altを押しながら、プラグインパネルにあるロゴ画像をクリックしてください。これでPixelsWorldはローカルファイルを読み取ってくれます。 コレクション好きなお客様のために、高確率でよく出てくるロゴ画像もありながら、ウルトラ激レアの画像も用意してあります。 "},"contents/Lua/LinkParameters.html":{"url":"contents/Lua/LinkParameters.html","title":"パラメータリンク","keywords":"","body":"パラメーター　リンク parameters.lua slider(id) -- 戻り値： 1 double angle(id) -- 戻り値： 1 double point(id) -- 戻り値： 2 double point3d(id) -- 戻り値： 3 double checkbox(id) -- 戻り値： 1 boolean color(id) -- 戻り値： 3 double layer(id,x,y) -- 戻り値： 4 double 二つ以上の戻り値がある場合は、二つ以上の変数で受け取る必要があります。例えば、point()関数は次のように戻り値を処理します。 point.lua version3() x,y = point(0) -- Declear two variables x and y println('x is ' .. x) println('y is ' .. y) "},"contents/Lua/globals.html":{"url":"contents/Lua/globals.html","title":"グローバル変数","keywords":"","body":"Globals グローバル定数 PixelsWorldのグローバル定数は次のように定義されています。 const.lua PI -- 円周率 TPI -- 円周率二倍 HPI -- 円周率半分 QPI -- 円周率四分の一 E -- 自然数 PHI -- 黄金比 R2 -- ルート２ R3 -- ルート３ R5 -- ルート５ R7 -- ルート７ INPUT -- インプットテクスチャID -1 TEMP -- 一時のテクスチャID -2 OUTPUT -- アウトプットテクスチャID -3 PARAM0 -- レイヤパラメーターテクスチャ 0 PARAM1 -- レイヤパラメーターテクスチャ 1 PARAM2 -- レイヤパラメーターテクスチャ 2 PARAM3 -- レイヤパラメーターテクスチャ 3 PARAM4 -- レイヤパラメーターテクスチャ 4 PARAM5 -- レイヤパラメーターテクスチャ 5 PARAM6 -- レイヤパラメーターテクスチャ 6 PARAM7 -- レイヤパラメーターテクスチャ 7 PARAM8 -- レイヤパラメーターテクスチャ 8 PARAM9 -- レイヤパラメーターテクスチャ 9 platform -- Windows == 0, ほかのプラットホームはまだ無し host -- Ae == 0, ほかのホストはまだ無し グローバル変数 グローバル変数は次のように定義されています。 globalvars.lua depth -- Dpc: 8,16,32 width -- Width input image height -- Height input image time -- Current time(s) duration -- Duration of current layer(s) inpoint -- Inpoint of current layer(s) compTime -- Comp current time(s) pluginFolder -- The plugin folder(utf8) projectName -- Project name(utf8) projectPath -- Project path(utf8) projectFolder -- Project folder(utf8) ds_width -- Width of downsampled input image ds_height -- Height of downsampled input image origin_x -- The X coordinate of left top corner of input image in the layer coordinate. origin_y -- The Y coordinate of left top corner of input image in the layer coordinate. グローバル変数を全部プリント 次のコードを用いてグローバル変数をシーンにプリントします。 printGlobals.lua version3() in2out() for k, v in pairs(_G) do print(k) print(\" \" .. type(v) , .5,.5,.5) print(\" \".. tostring(_G[k]),0,1,1) println(\"\") end "},"contents/Lua/FuncList.html":{"url":"contents/Lua/FuncList.html","title":"関数一覧表","keywords":"","body":"Function List This page covers all functions provided in Lua render mode. Required functions version3 Parameter link functions slider, angle, point, point3d, checkbox, color, layer Print message functions print, println, alert Transform functions move, scale, rotate, rotateX, rotateY, rotateZ, twirl beginGroup, endGroup, beginGlobal, endGlobal global2local, local2global, global2screen, screen2global getTransformMatrix Draw functions Primitives tri, quad, rect, circle, ellipse, par, line cube, tet, cone, ball, tube image, imageAlign, imageAnchor text, textSize, textFont, textAlign, textAnchor, textAlignOuter, textInterval, textAdvanceScale coord, grid poly, setPoly background, in2out Attribute controls dim2, dim3 perspective, noPerspective fill, noFill, stroke, noStroke, dot, noDot wireframe, noWireframe blendAlpha, noBlendAlpha back, noBack pure, phong, anime rgba, depth, normal setDepth Lights ambientLight, pointLight, parallelLight clearLight, getLight Camera function aeCamera, lookAt, viewSpace Stroke details strokeWidth, strokeDivision, strokeGlobal, strokeLocal Dot details dotRadius, dotDivision, dotGlobal, dotLocal Output details smooth, noSmooth Texture operations newTex, delTex, getSize, swapTex, drawTo, castTex, blendTex, copyTex, savePNG, loadPNG, saveEXR, loadEXR, rotateTex, flipTex, resizeTex, trimTex Utility tools r2d, d2r map clamp step smoothStep bezier rgb2hsl,hsl2rgb,rgb2hsv,hsv2rgb,rgb2cmy,cmy2rgb,rgb2cmyk,cmyk2rgb,cmy2cmyk,cmyk2cmy,hsl2hsv,hsv2hsl utf8ToLocal, localToUtf8 getGLInfo, getDrawRecord, getStatus getAudio loadString saveString Read/Write pixels functions getColor, setColor, getSize, Run code functions shadertoy, glsl, cmd, lua, runFile, txt Detailed descriptions version3 version3() function must be called in the first line. It put all functions in the table pw3 to the global field. If you don't call it, you need to add a pw3. prefix to all the functions provided by PixelsWorld. For instance, the following demonstrated function print() should be pw3.print(). On the contrary, If you call the function version3() in the first line, the pw3. prefix could be omitted. This function is designed for backward compatibility. We recommend calling version3() in the first line any time you use Lua render mode. version3.lua version3() println(\"Hello PixelsWorld! \") without_version3.lua pw3.println(\"Hello PixelsWorld! \") print print(str),print(str,brightness),print(str,r,g,b),print(str,r,g,b,a) prints message to the left top corner of your scene. print.lua version3() print(\"Hello PixelsWorld! \") str = \"Hello, I am colorful PixelsWorld! \" for i=1,#str do local c = str:sub(i,i) local phase = math.sin(i/#str*TPI + time*10) / 2 + .5 print(c,phase,1-phase,1,1) end println println(str),println(str,brightness),println(str,r,g,b),println(str,r,g,b,a) prints message to the left top corner of your scene, this function adds \\n in the end of input string. println.lua version3() println(\"Hello PixelsWorld! \") str = \"Hello, I am colorful PixelsWorld! \" for i=1,#str do local c = str:sub(i,i) local phase = math.sin(i/#str*TPI + time*10) / 2 + .5 -- println(c,phase,1-phase,1,1) print(c,phase,1-phase,1,1) end alert alert(str) prints caution message, equals to println(str,1,1,0,1) alert.lua version3() alert(\"Warning: Write your message here! \") move move(x,y),move(x,y,z)moves Paintbrush. All transforms are done basing on the Paintbrush coordinate. Example: move.md version3() coord() -- show Paintbrush coordinate move(100,0) coord() -- show Paintbrush coordinate move(0,100) coord() -- show Paintbrush coordinate Finally, the Paintbrush is located at (100,100,0). scale scale(ratio),scale(x,y),scale(x,y,z)scales the Paintbrush coordinate. All transforms are done basing on the Paintbrush coordinate. scale.lua version3() move(100,100) scale(2) rect(50,25) no_scale.lua version3() move(100,100) --scale(2) rect(50,25) rotate rotateX rotateY rotateZ rotate(theta)rotates Paintbrush with theta radians. rotateX(theta) rotates Paintbrush along X axis. rotate(theta) equals to rotateZ(theta). All transforms are done basing on the Paintbrush coordinate. If you are not familiar with radians, use d2r(degree) to convert a degree to a radian. For example：rotate(d2r(90)) means rotate 90 degrees. rotate_degree.lua version3() move(100,100) rotate(d2r(45)) rect(50,25) rotate_radian.lua version3() move(100,100) rotate(PI/4) rect(50,25) rotateX.lua version3() dim3() move(100,100) grid() coord() rotateX(d2r(45)) cube(50,25,10) rotateY.lua version3() dim3() move(100,100) grid() coord() rotateY(d2r(45)) cube(50,25,10) rotateZ.lua version3() dim3() move(100,100) grid() coord() rotateZ(d2r(45)) cube(50,25,10) twirl twirl(theta,x,y,z) rotates Paintbrush along (x,y,z) axis with theta radians. For example, above-mentioned rotateX(theta) equals to twirl(theta,1,0,0). All transforms are done basing on the Paintbrush coordinate. twirl is an matrix implementation of quaternion rotation. twirl.lua version3() dim3() move(100,100) grid() coord() stroke(1,1,0) line(-50,-50,-50,50,50,50) stroke(0,0,0) twirl(d2r(90),1,1,1) cube(50,25,10) beginGroup endGroup beginGroup(),endGroup() creates a children transformation group. Transformations(move,scale,rotate,twirl) between beginGroup() and endGroup() will be canceled after calling endGroup(). beginGroup(mat) pushes mat as a children transformation group (Use getTransformMatrix to get the transform matrix). It equals to pushMatrix() and popMatrix() in Processing. Example: The following two code are equivalent. group.lua version3() for i = 1,6 do beginGroup() move(i*25,i*25) rotate(d2r(15*i)) rect(25) endGroup() end without_group.lua version3() for i = 1,6 do move(i*25,i*25) rotate(d2r(15*i)) rect(25) rotate(d2r(-15*i)) move(-i*25,-i*25) end beginGlobal endGlobal Draw functions between beginGlobal and endGlobal will draw shapes in global coordinates. beginGlobal.lua version3() move(100,100) fill(0,1,0) -- green rect(50) -- Dran on (100,100,0) beginGlobal() fill(1,0,0) -- red rect(50) -- Draw on (0,0,0) endGlobal() move(100,100) fill(0,0,1) -- blue rect(50) -- Draw on (200,200,0) global2local global2local(x,y,z) converts a global point to a local point. Returns 3 doubles. global2local.lua version3() move(100,100) rect(25) move(0,50) rotate(d2r(30)) coord() x,y,z=global2local(100,100,0) println(\"The local coordinate of the rectangle is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") local2global local2global(x,y,z) converts a local point to a global point. Returns 3 doubles. local2global.lua version3() move(100,100) move(0,50) rotate(d2r(30)) coord() move(25,50) rect(25) x,y,z=local2global(0,0,0) println(\"The global coordinate of the rectangle is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") global2screen global2screen(x,y,z) converts a global point to a screen point. Returns 3 doubles. The result is affected by perspective mode. global2screen.lua version3() dim3() move(100,100,0) move(0,50,0) rotateZ(d2r(30)) coord() move(25,50,0) cube(25) x,y,z=global2screen(local2global(0,0,0)) println(\"The screen coordinate of the rectangle is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") screen2global screen2global(x,y,z) converts a screen point to a global point. Returns 3 doubles. The result is affected by perspective mode. screen2global.lua version3() dim3() x,y,z=screen2global(0,0,0) println(\"The global coordinate of the camera is:\\n (\" .. x .. \", \" .. y .. \", \" .. z .. \").\") getTransformMatrix getTransformMatrix() returns a column major 4x4 transform matrix. mat[i][j] returns the entry in ith column jth row. (i,jrange: 1~4) matrix.lua version3() dim3() beginGroup() move(width/3,height/3) twirl(d2r(30),1,1,1) cubetransform = getTransformMatrix() endGroup() beginGroup(cubetransform) cube(50) endGroup() tri tri(radius) draws a regular triangle with radius radius, and the triangle will point to the positive direction of the Y-axis. tri() equals to tri(100) tri(w,h)draws a triangle with base length w and height h. tri(p1x,p1y,p2x,p2y,p3x,p3y) draws a triangle basing on 3 points p1,p2,p3. tri(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z) draws a triangle basing on 3 points p1,p2,p3. Add dim3() after version3(), and add a camera layer to your Ae comp to view the 3D triangle. The first 3 functions set normals to (0,0,-1) basing on the current Paintbrush coordinate. The last 2 functions calculate normals with formula: cross(p1-p2,p3-p2). tri is an abbreviation of triangle tri1.lua version3() move(width/2,height/2) tri(100) tri5.lua version3() dim3() move(width/2,height/2) tri(0,0,100,50,0,0,0,50,0) quad quad(p1x,p1y,p2x,p2y,p3x,p3y,p4x,p4y) quad(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z,p4x,p4y,p4z) Draws 2 triangles with order: p1,p2,p3,then p1,p3,p4. quad.lua version3() move(200,100) quad(0,0,75,0,50,40,0,15) rect rect(size) draws a square with size. rect() equals to rect(100) rect(width,height) draws a rectangle with width width and height height. The intersection point of the rectangle is at the origin of the Paintbrush coordinate. rect is an abbreviation of rectangle. rect.lua version3() move(200,100) rect(100,75) circle circle(radius) draws a circle with radius radius. circle() equals to circle(100) circle(radius, div) draws a circle with radius radius, and subdivision div. Default subdivision: 128 circle.lua version3() move(100,100) fill(1,0,0) circle(25) move(100,0) fill(0,1,0) circle(25,10) move(100,0) fill(0,0,1) circle(25,3) ellipse ellipse(radiusx,radiusy)draws an ellipse with x radiusradiusx, y radius radiusy. ellipse() equals to ellipse(100,100) ellipse(radiusx,radiusy,div) draws an ellipse with x radiusradiusx, y radius radiusy and subdivision div. Default subdivision: 128 ellipse.lua version3() move(100,100) fill(1,0,0) ellipse(25,15) move(100,0) fill(0,1,0) ellipse(25,15,10) move(100,0) fill(0,0,1) ellipse(25,15,4) line line(p1x,p1y,p2x,p2y) draws a line. line(p1x,p1y,p1z,p2x,p2y,p2z) draws a 3d line. line() equals to line(0,0,0,100,100,100) Use stroke(r,g,b) to change the color. UsestrokeWidth(width) to change the width. Use noStroke() to turn off line render, stroke() to turn on line render. line.lua version3() move(200,100,0) stroke(1,0,0) line(0,0,0,50) move(100,0,0) stroke(0,1,0) line(0,0,0,50) move(100,0,0) stroke(0,0,1) line(0,0,0,50) line_circle.lua version3() math.randomseed(1) num = 32 move(width/2,height/2) for i=1,num do beginGroup() rotateZ(d2r(360/num*i)) strokeWidth(math.random()*3) line(0,0,100,0) endGroup() end par par(x) draws a point at(x,0,0). par(x,y) draws a point at(x,y,0). par(x,y,z) draws a point at(x,y,z). par() equals to par(0,0,0) By default, the point rendering is turned off, use dot() to turn it on. You can call noDot() to turn it off again. dotRadius(radius) controls point radius. dot(r,g,b) controls point color. dotGlobal() makes point be avoid to be squeezed by scale. By default, points are rendered with dotLocal(). par.lua version3() dot() dotRadius(3) move(200,100) par() dot(1,0,0) dotRadius(7) move(100,0) par() cube cube(size) draws a cube with size size cube(sizex,sizey,sizez) draws a cuboid with dimension sizex,sizey,sizez. cube() equals to cube(100) cube() Negative inputs or negative scale() would cause wrong normals. cube.lua version3() dim3() move(200,100,0) rotateY(d2r(30)) rotateX(d2r(30)) cube(40,25,10) tet tet(radius) draws a regular tetrahedron with radius radius. tet() equals to tet(50) tet(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z,p4x,p4y,p4z) draws tetrahedron basing on 4 points p1,p2,p3,p4. The 3rd function generates normals basing on tri function and calls it with the following points order: p1,p2,p3; p2,p1,p4; p3,p2,p4; p1,p3,p4.. See also: tri. tet is an abbreviation of tetrahedron. tet.lua version3() dim3() move(200,100,0) tet(0,0,0, 100,0,0, 0,100,0, 30,20,-50 ) cone cone(size) draws a cone with base circle radius size and height 2*size. cone() equals to cone(50). cone(radius,height) draws a cone with base circle radius radius and height height. cone(radius,height,div) draws a cone with base circle radius radius, height height and subdivision div. Default subdivision: 64 If sub is greater than 16, the sidestroke and base point will be hidden. Negative inputs or negative scale() would cause wrong normals. cone.lua version3() dim3() move(100,100,0) beginGroup() rotateY(d2r(60)) cone(25) endGroup() move(100,0,0) beginGroup() rotateY(d2r(60)) noStroke() cone(25) endGroup() move(100,0,0) beginGroup() rotateY(d2r(60)) stroke(1,0,0) dot(1,1,0) dotRadius(3) cone(30,100,12) endGroup() ball ball(radius) draws a sphere with radius radius. ball() equals to ball(50). ball(radius,level) draw a ball with radius radius and subdivision level level. Default subdivision level 4. level must be non-negative. level 0 generates a regular octahedron. If level is greater than 2, the strokes and points will be hidden. Negative inputs or negative scale() would cause wrong normals. ball.lua version3() dim3() move(200,100,0) beginGroup() rotateY(d2r(60)) ball(25) endGroup() move(100,0,0) beginGroup() rotateY(d2r(60)) stroke(0,0.25,0.5) dot(0,0.5,1) dotRadius(3) ball(30,2) endGroup() tube tube(size) draws a tube with base circle radius size and height 2*size. tube() equals to tube(50) tube(radius,height)draws a tube with base circle radius radius and height height. tube(radius1,radius2,height) draws a tube with close base circle radius radius1, far base circle radius radius2 and height height. tube(radius1,radius2,height,div) can change the subdivision. tube(radius1,radius2,height,div,needMesh) can change render 2 base circles or not. tube(radius1,radius2,height,div,needMesh1,needMesh2) can change render 2 base circles or not separately. Default div: 64. needMesh is true by default. If div is greater than 16, the side strokes and the base points will be hidden. Negative inputs or negative scale() would cause wrong normals. tube.lua version3() dim3() move(200,100,0) beginGroup() rotateY(d2r(60)) tube(25) endGroup() move(100,0,0) beginGroup() rotateY(d2r(60)) stroke(1,0.25,0.5) dot(0,0,1) dotRadius(3) tube(30,25,50,8) endGroup() image image(id,width,height) draws an image with width width and height height. id is texture id,PARAM0~PARAM9means texture load from the layer parameters, INPUT means input image, OUTPUT means output image. If id is OUTPUT, it will be slow because we need to take a screenshot of your scene. The difference with in2out(id) is, image(id, width, height) draws a rectangle with a texture, which could interact with the depth buffers, where in2out(id) just copy pixels from one texture to another. This also means the image that is drawn to the screen is inverted by default (The default coordinate system of Ae is Y axis downward), so you may need rotateX(PI) to fix it. (And we don't recommend calling scale(1,-1), which may cause wrong normals problem. Example: render_image.lua version3() dim3() move(width/2,height/2) twirl(d2r(45),-1,1,0) beginGroup() rotateX(d2r(180)) image(INPUT,width,height) endGroup() twirl(d2r(60),1,1,1) cube() imageAlign New in v3.3.0 imageAlign(rule) changes the image orientation rendered by image function. The syntax of rule is as follows rule is a 4-length-string. 1st char should be + or - 2nd char should be one of x,y,z 3rd char should be + or - 4th char should be one of x,y,z rule represents which painter coordinates the texture UV coordinate (the origin is left bottom corner) should align with. By default, the rule is \"+x+y\", it represents u aligns with positive x, v aligns with positive y. imageAlign.lua version3() dim3() move(100,100,0) coord() image(PARAM0,128,128) move(150,0,0) coord() imageAlign(\"+x-y\") image(PARAM0,128,128) move(150,0,0) coord() imageAlign(\"+z-y\") image(PARAM0,128,128) imageAnchor New in v3.5.0. imageAnchor(u,v) specifies the uv position of the anchor point of the image. imageAnchor(a) is a shortcut of imageAnchor(a,a) text New in v3.5.0 text(str) renders text onto the screen. text.lua version3() move(width/2,height/2) textAlign(\"+x-y\") text(\"Hello PixelsWorld!\") textSize New in v3.5.0 textSize(size,resolution) set the text size to be rendered. size controls the size of the text, resolution controls the resolution of the text. textSize(size) equals to textSize(size,size) textSize.lua version3() textAlign(\"+x-y\") textAnchor(0,1) for i=1,13 do local sz = i + 8 textSize(sz) text(\"~MiLai visual performance group~\") move(0,sz + 4) end textFont New in v3.5.0 textFont(fontFileName) set the font of the text to be rendered. fontFileName is the font-file's name located in C:\\Windows\\Fonts. (Right click the file, click Properties, you would see the font-file's name. E.g.: textFont(\"arial.ttf\"))。 You can also use the full path of a font. Yes, you can load font files in everywhere. (textFont([[D:\\MyFolder\\arial.ttf]])) textFont.lua version3() textAlign(\"+x-y\") textAnchor(0,1) textSize(20) font_list={ {\"arial.ttf\",\"The quick brown fox jumps over the lazy dog. \"}, {\"MATURASC.TTF\",\"The quick brown fox jumps over the lazy dog. \"}, {\"KUNSTLER.TTF\",\"The quick brown fox jumps over the lazy dog. \"}, {\"msmincho.ttc\",\"色は匂へど　散りぬるを\"}, {\"UDDigiKyokashoN-R.ttc\",\"我が世誰ぞ　常ならむ\"}, {\"STXINGKA.TTF\",\"人生得意须尽欢 莫使金樽空对月\"}, {\"msjh.ttc\",\"山氣日夕佳 飛鳥相與還\"}, {\"simsun.ttc\",\"吥葽 莣記莪、伱知道 莪 拿起伱 就 倣吥丅。\"}, {\"STZHONGS.TTF\",\"○●対沵倾注ㄋ珴所侑旳温柔︶ㄣ\"}, } for i=1,#font_list do textFont(font_list[i][1]) text(font_list[i][2]) move(0,28) end textAlign New in v3.5.0 textAlign(rule) sets the alignment rule of the text. See also imageAlign>>> textAnchor New in v3.5.0 textAnchor(x,y) sets the anchor point of the text. See also imageAnchor>>> textAlignOuter New in v3.5.0 textAlignOuter(flag) set if we align text with outer boundary of the text. flag is a bool. textInterval New in v3.5.0 textInterval(x,y) set the intervals of the text texture. Default: x:0, y:0 textAdvanceScale New in v3.5.0 textAdvanceScale(rx,ry) set the scale of advances. Default: rx:1, ry:1 coord coord() draws the current Paintbrush coordinate. coord.lua version3() move(100,100) coord() move(150,0) coord() rotate(d2r(30)) move(50,0) scale(2,1) coord() grid grid() draws a grid with many 100x100px squares. grid.lua version3() move(width/2,height/2) rotate(d2r(30)) grid() setPoly setPoly(obj) analyzes obj only, use poly() to draw the previous set obj to scene. It will be efficient in the case you draw the same obj for many times. See also Poly background background(brightness),background(r,g,b),background(r,g,b,a) draws a pure color rectangle to scene. Notes: This function overrides all shapes you drew before. background.lua version3() background(1,1,0) in2out in2out(id) set the id texture to the scene. in2out() equals to in2out(INPUT) id range: PARAM0~PARAM9 or INPUT. dim2 dim2() set the scene to 2D mode. The 2D mode is on by default, you usually no need to call it. In PixelsWorld, a 2D scene means a 3D scene without depth test and perspective. dim3 dim3() set the scene to 3D mode. Call it immediately after version3(). Note: Use viewSpace to change the far plane dimension if your layer size is not equal to the comp size. Otherwise, the shapes in 3D mode will be rendered to an unexpected position. perspective perspective() set the scene to perspective mode, everything looks small in the distance and big on the contrary. Use viewSpace to change the camera information. Use lookAt to set the location of the camera. Perspective mode is on by default after calling dim3(). noPerspective noPerspective() set the scene to orthogonal mode. noPerspective.lua version3() dim3() n = 20 move(100,100,0) beginGroup() rotateX(d2r(85)) for i=1,n do move(0,300,0) fill(i/n,1-i/n,1) cube(50) end endGroup() move(300,0,0) noPerspective() beginGroup() rotateX(d2r(85)) for i=1,n do move(0,300,0) fill(i/n,1-i/n,1) cube(50) end endGroup() fill fill() turns on fill mode. fill(brightness),fill(r,g,b),fill(r,g,b,a) turns on fill mode and set fill color. Note: If you set Alpha smaller than 1, render far object first, or you will get wrong render results due to the depth test. (This is a feature of OpenGL render) noFill noFill() turns off the fill mode. fill.lua version3() move(200,100,0) fill(1,0,0) rect(50) move(100,0,0) fill(1,1,0) rect(50) move(100,0,0) noFill() rect(50) stroke stroke() turns on the stroke mode. stroke(brightness),stroke(r,g,b),stroke(r,g,b,a) turns on stroke mode and set the stroke color. noStroke noStroke() turns off stroke mode. stroke.lua version3() fill(0) move(200,100,0) stroke(1,0,0) rect(50) move(100,0,0) stroke(1,1,0) rect(50) move(100,0,0) noStroke() rect(50) dot dot() turns on the dot mode. dot(brightness),dot(r,g,b),dot(r,g,b,a) turns on the dot mode and set the dot color. noDot noDot() turns off the dot mode. dot.lua version3() fill(1) move(200,100,0) stroke(1,0,0) rect(50) move(100,0,0) dot(1,1,0) rect(50) move(100,0,0) noDot() rect(50) wireframe wireframe() turns on the wireframe mode. noWireframe noWireframe() turns off the wireframe mode. wireframe.lua version3() n=8 dim3() move(width/2, height/2) for i=1,n do if i>n//2 then wireframe() else noWireframe() end beginGroup() rotateZ(d2r(i*360/n)) move(100,0,0) fill(i/n,1-i/n,1) ball(30,1) endGroup() end blendAlpha blendAlpha() turns on the alpha blending. noBlendAlpha noBlendAlpha turns off the alpha blending. blendAlpha.lua version3() castTex(OUTPUT,INPUT) move(200,100,0) fill(1,0,0,0.2) rect(80) move(100,0,0) noBlendAlpha() fill(1,0,0,0.2) rect(80) back back() If the fill alpha is smaller than 1, back mode shows the backside of an obj. Off by default. noBack noBack() turn off back mode. back.lua version3() dim3() fill(1,0,0,0.2) rotateX(d2r(30)) rotateY(d2r(-15)) move(200,180,0) cube(80) move(150,0,0) back() cube(80) pure pure() use pure color to render. On by default. anime, phong, pure are 3 dependent mode, turn on one may turn off the other two. phong phong(ambient,diffuse,specular,specularPower) turns on the phong render mode, and set the ambient strength to ambient, diffuse strength to diffuse, specular strength to specular, specular damping power to specularPower. phong() only turn on the phong render mode, it doesn't change the configs. By default, there is no light in the scene, call getLight(), ambientLight(), parallelLight(), pointLight to add lights. If you are sure there are lights in your scene but the obj is black, call normal to check if the normal is right. Default settings: ambient:1,diffuse:1,specular:1,specularPower:1. anime, phong, pure are 3 dependent mode, turn on one may turn off the other two. Call dim3() before calling this function. phong.lua version3() dim3() move(width/2,height/2,0) grid() coord() n=10 beginGroup() move(0,0,-100) pointLight() endGroup() for i=1,n do beginGroup() rotateZ(d2r(i*360/n)) move(100,0,0) fill(i/n,1-i/n,1) if(i anime anime(ambient,diffuse,specular,specularPower,diffuseThreshold,specularThreshold) anime() turns on the anime render mode. anime render mode is based on phong, hence the first 4 arguments ambient,diffuse,specular,specularPower are same with phong render mode. diffuseThreshold configs the diffusion threshold, if diffuse lightnees in a pixel is bigger than threshold, it will be white. Otherwise it will be dark. specularThreshold is threshold of specular. The anime render mode smooth the light-dark border when you turn on the smooth settings in plugin panel. Default settings: ambient:1,diffuse:1,specular:1,specularPower:1,diffuseThreshold:0.5,specularThreshold:0.8 anime, phong, pure are 3 dependent mode, turn on one may turn off the other two. Call dim3() before calling this function. anime.lua version3() dim3() move(width/2,height/2,0) grid() coord() n=10 beginGroup() move(0,0,-100) pointLight() endGroup() for i=1,n do beginGroup() rotateZ(d2r(i*360/n)) move(100,0,0) fill(i/n,1-i/n,1) if(i rgba rgba()RGBA output mode, on by default. rgba, depth, normal are 3 dependent mode, turn on one may turn off the other two. You can use phong(),anime() in this output mode. rgba.lua version3() dim3() background(1) move(width/2,height/2,0) n=10 beginGroup() move(0,0,-100) pointLight() endGroup() rgba() -- depth() -- normal() noStroke() for x=1,n do for y=1,n do for z=1,n do beginGroup() fill(x/n,y/n,z/n) move(map(x,1,n,-n/2,n/2)*50,map(y,1,n,-n/2,n/2)*50,map(z,1,n,-n/2,n/2)*200) ball(10,2) endGroup() end end end depth depth(blackDistance, whiteDistance) depth output mode. Set pixels at distance blackDistance to black, pixels at distance whiteDistance to white. If they are the same, PixelsWorld sets the pixels nearer than the value you set to black, otherwise white. rgba, depth, normal are 3 dependent modes, turn on one may turn off the other two. phong(),anime() will be ignored in this output mode. Call dim3() before calling this function. depth.lua version3() dim3() background(1) move(width/2,height/2,0) n=10 beginGroup() move(0,0,-100) pointLight() endGroup() -- rgba() depth() -- normal() noStroke() for x=1,n do for y=1,n do for z=1,n do beginGroup() fill(x/n,y/n,z/n) move(map(x,1,n,-n/2,n/2)*50,map(y,1,n,-n/2,n/2)*50,map(z,1,n,-n/2,n/2)*200) ball(10,2) endGroup() end end end normal normal(faceToCamera, normalize) turns the normal output mode on, and configs faceToCamera and normalize. normal(faceToCamera) turns the normal output mode on, and configs faceToCamera. normal() only turns the normal output mode on. faceToCamera is a boolean, true means the normals are calculated based on camera location. false means the normals are calculated based on the global coordinate. normalize is a boolean. Default settings: faceToCamera:true, normalize:true. rgba, depth, normal are 3 dependent modes, turn on one may turn off the other two. phong(),anime() will be ignored in this output mode. Call dim3() before calling this function. normal.lua version3() dim3() background(.5,.5,1) move(width/2,height/2,0) n=10 beginGroup() move(0,0,-100) pointLight() endGroup() -- rgba() -- depth() normal() noStroke() for x=1,n do for y=1,n do for z=1,n do beginGroup() fill(x/n,y/n,z/n) move(map(x,1,n,-n/2,n/2)*50,map(y,1,n,-n/2,n/2)*50,map(z,1,n,-n/2,n/2)*200) ball(10,2) endGroup() end end end setDepth setDepth(id,blackDistance,whiteDistance) reads the red channel of texture id, maps color basing on blackDistance,whiteDistance to the depth test buffer in the scene. The depth sequence from other 3DCG software can be loaded into PixelsWorld through this function. Namely, the shapes can interact with the color sequence rendered from other 3DCG software. Call dim3() before calling this function. Valid texture id: INPUT,PARAM0~PARAM9 ambientLight ambientLight(r,b,g,intensity) ambientLight() equals to ambientLight(1,1,1,1) ambientLight(brightness) equals to ambientLight(brightness,brightness,brightness,1) ambientLight(brightness,intensity) equals to ambientLight(brightness,brightness,brightness,intensity) ambientLight(r,g,b) equals to ambientLight(r,b,g,1) Adds ambient light to the scene. Valid to all objs. Objs are lit up by this kind of light even if they have wrong normals. al.lua version3() dim3() move(width/2,height/2,0) n=4 phong() ambientLight(1,0.5,0.2,10) noStroke() for r=1,n do local ra = r*50 local cn = math.floor(ra*TPI/40) for i=1,cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn,0.5,0.5)) move(ra,0,0) ball(15,3) endGroup() end end pointLight pointLight(r,g,b,intensity,radius,smoothWidth) pointLight() equals to pointLight(1,1,1,1,1000,1000) pointLight(brightness,intensity) equals to pointLight(brightness,brightness,brightness,intensity,1000,1000) pointLight(r,g,b) equals to pointLight(r,g,b,1,1000,1000) pointLight(r,g,b,intensity) equals to pointLight(r,g,b,intensity,1000,1000) pointLight(r,g,b,intensity,radiusAndSmoothWidth) equals to pointLight(r,g,b,intensity,radiusAndSmoothWidth,radiusAndSmoothWidth) Adds a point light in the current Paintbrush coordinate. This light is affected by objs' normals. The specular and diffuse will be failed if the normals are inward, but the ambient brightness of point light still lights up the objs. radius is range radius of point light. Range from radius to radius+smoothWidth, the brightness damps. pl.lua version3() dim3() move(width/2,height/2,0) n=4 phong() ambientLight(0.2,0.5,1,2) beginGroup() move(0,0,-100) pointLight(1,0.5,0.2,2,500,100) endGroup() noStroke() for r=1,n do local ra = r*50 local cn = math.floor(ra*TPI/40) for i=1,cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn,0.5,0.5)) move(ra,0,0) ball(15,3) endGroup() end end parallelLight parallelLight(r,g,b,intensity,tx,ty,tz) Adds a parallel light with direction vector (tx,ty,tz). pll.lua version3() dim3() move(width/2,height/2,0) n=4 phong() ambientLight(0.2,0.5,1,2) parallelLight(1,0.5,0.2,2,1,-1,1) noStroke() for r=1,n do local ra = r*50 local cn = math.floor(ra*TPI/40) for i=1,cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn,0.5,0.5)) move(ra,0,0) ball(15,3) endGroup() end end light_effects.lua version3() dim3() background(0.1,0.2,0.3) move(width/2,height/2,0) math.randomseed(1) n=5 ambientLight(0.2,0.5,1,1) parallelLight(1,0.5,0.2,0.1,1,-1,1) beginGroup() move(200,0,-100) pointLight(1,0.5,0.2,1,200,100) endGroup() beginGroup() move(-30,200,-100) pointLight(0,1,1,1,200,100) endGroup() beginGroup() move(-30,-200,-100) pointLight(0,1,1,1,200,100) endGroup() noStroke() for r=1,n do local ra = r*50 local cn = math.floor(ra*TPI/40) for i=1,cn do beginGroup() rotateZ(d2r(i/cn*360)) fill(hsl2rgb(i/cn,r/n,0.6)) move(ra,0,0) if math.random() clearLight clearLight() removes all lights in the scene. getLight getLight(matchName) getLight() equals to getLight(\"*\") Gets lights that match the name matchName. matchName rules：If matchName doesn't end up with character \"*\", it searches one Ae lights that its name is matchName, otherwise, it includes all Ae lights that begin with matchName. Supported Ae lights: ambient,point,parallel aeCamera aeCamera() sets the Ae activated camera to the scene camera of PixelsWorld. lookAt lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ,upVecX,upVecY,upVecZ) sets the location and orientation of the current scene camera. lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ) equals to lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ,0,-1,0) eyePos is the location of your eyes, objPos is the location of the object you are looking at,upVec the direction the top of your head pointing to. Note: The Y-axis in Ae is downward by default, usually set the upVec to (0,-1,0) is enough. eyePos and objPos cannot be too close. (should be bigger than 1e-7). upVec cannot be parallel to your sight. The length of upVec cannot be too small. viewSpace viewSpace(width,height,distanceToPlane,farLevel) viewSpace(width,height,distanceToPlane) equals to viewSpace(width,height,distanceToPlane,4) width and height is the dimension of the far plane. The perpendicular distance from the camera to the camera's far plane is distanceToPlane farLevel * distanceToPlane is the clip plane distance. Objs that farther than this distance will be clipped out. Normally it is enough to leave the farLevel 4, set it to a higher number if your scene is pretty vast. Note that if the farLevel is too high, the depth test precision of near objs may decline. strokeWidth strokeWidth(width) Default: 2 strokeDivision strokeDivision(level) Default: 3 strokeGlobal strokeGlobal() draw lines globally. Lines will no longer be squeezed by scale function. Default: local strokeLocal strokeLocal() draw lines locally. Lines will be squeezed by scale function. Default: local dotRadius dotRadius(radius) Default: 2 dotRadius.lua version3() background(1) fill(0,1,1) dot(1,0,0) move(100,100) for i=1,7 do dotRadius(i/2) rect(40) move(50,0) end dotDivision dotDivision(level) Default: 3 Maximum: 7 dotDivision.lua version3() background(1) fill(0,1,1) dot(1,0,0) dotRadius(10) move(100,100) for i=0,4 do dotDivision(i) rect(40) move(70,0) end dotGlobal dotGlobal() Draw points globally. Points will no longer be squeezed by scale function. Default: local dotGlobal.lua version3() dot(1,0,0) dotGlobal() move(50,100) beginGroup() for i=1,13 do beginGroup() scale(1/i) rect(50) endGroup() move(50/i+20,0) end endGroup() dotLocal dotLocal() Draw points locally. Points will be squeezed by scale function. Default: local dotLocal.lua version3() dot(1,0,0) dotLocal() move(50,100) beginGroup() for i=1,13 do beginGroup() scale(1/i) rect(50) endGroup() move(50/i+20,0) end endGroup() smooth smooth() Smooth render mode. Default: on The smooth strength can be changed in the plugin panel. noSmooth noSmooth() Pixel art render mode. The priority of this function is higher than the settings in the plugin panel. r2d r2d(degrees) radians to degrees, return degrees. d2r d2r(radians) degrees to radians, return radians map map(value,in1,in2,out1,out2) maps value value from range in1~in2 to range out1~out2. If in1 equals to in2, if value this function returns out1, otherwise out2. clamp clamp(value,lower,upper)clamps value into range [lower,upper], returns clamped value. New in v3.2.0 Namely, if value is between lower and upper, this function returns value; If value is less than lower, it returns lower; If value is greater than upper, it returns upper. step step(value,threshold) returns 0 if value, otherwise, returns 1. New in v3.2.0 smoothStep smoothStep(value,lower,upper) returns 0 if value, returns 1 if value>higher1, otherwise, returns the smooth interpolation between lower and higher basing on value. Formula of interpolation: t:=x−lowerupper−lower\r t := \\frac{x - lower}{upper - lower}\r t:=​upper−lower​​x−lower​​ Result:=t2(3−2t)\r Result:=t^2(3 - 2t)\r Result:=t​2​​(3−2t) New in v3.2.0 bezier bezier(t,p0,p1,...,pn) returns the n times bezier interpolation basing on p0,p1,...,pn. The formula of interpolation: Result:=∑k=0nCnk⋅(1−t)n−k⋅tk⋅pk\r Result := \\sum_{k=0}^n{C_n^k\\cdot (1-t)^{n-k}\\cdot t^k\\cdot p_k}\r Result:=∑​k=0​n​​C​n​k​​⋅(1−t)​n−k​​⋅t​k​​⋅p​k​​ Cnk:=n!(n−k)!k!\r C_n^k:=\\frac{n!}{(n-k)!k!}\r C​n​k​​:=​(n−k)!k!​​n!​​ New in v3.2.0 The maximum of n is 66. Color conversion xxx2xxx allows the following color conversion: For example, if you want to convert a hsl color to rgb format, then you need to call the function hsl2rgb, both the number of input and output parameters are 3. All conversions are done in the range 0~1. New in v3.2.0 color_convert.lua version3() dim3() strokeWidth(0.5) stroke(0) move(width/2,height/2,0) for x = -5,5 do for y =-5,5 do for z=-5,5 do beginGroup() move(x*15,y*15,z*15) fill(cmy2rgb(x/10+.5,y/10+.5,z/10+.5)) cube(12) endGroup() end end end utf8ToLocal utf8ToLocal(str) unicode string to local string. Call this function to translate paths while you are handling Lua's io module. localToUtf8 localToUtf8(str)local string to unicode string getGLInfo getGLInfo() gets the information of the current graphics card. getDrawRecord getDrawRecord(needStringFormat) gets current draw records. needStringFormat is a boolean, when true, returns a string, otherwise, returns a Lua table. getDrawRecord() equals to getDrawRecord(true) printDrawRecord.lua version3() move(width/2,height/2) dim3() cube() println(getDrawRecord()); getStatus getStatus(needStringFormat)gets the current Paintbrush status. needStringFormat is a boolean, when true, returns a string, otherwise, returns a Lua table. getStatus() equals to getStatus(true) printDrawRecord.lua version3() dot(1,0,0) move(width/2,height/2) dim3() cube() println(getDrawRecord()) getAudio Make sure you have PixelsWorld v3.4.0+ getAudio([startTime,duration[,id[,sampleRate,startFrequency,endFrequency[,resolution]]]]) fetches the audio data. Returns 6 tables. The first 2 are wave sample tables(Left and Right), the next 2 are fft result tables(Left and Right), the last 2 are spectrum tables(Left and Right). Left wave sample range: (-1~1) Right wave sample range: (-1~1) Left FFT range: (0~infinity) Right FFT range: (0~infinity) Left spectrum sample range: (0~infinity) Right spectrum sample range: (0~infinity) waveInfo.lua version3() castTex(OUTPUT,INPUT) local wl,wr,ftl,ftr,specl,specr = getAudio() local nm = math.floor(height/8); for i=1,nm do local wid =math.max(math.floor(i/nm*#wl),1) local fid = math.max(math.floor(i/nm*#specl),1) print(string.format(\"%8.5f\",wl[wid]),wl[wid]*4,0,-wl[wid]*4) print(\" \",1,0,0,0) print(string.format(\"%8.5f\",wr[wid]),wr[wid]*4,0,-wr[wid]*4) print(\" \",0.5,0.5,0.5) print(string.format(\"%8.5f\",specl[fid]),specl[fid],0,0) print(\" \",1,0,0,0) print(string.format(\"%8.5f\",specr[fid]),0,0,specr[fid]) println(\"\"); end saveString saveString(utf8_path,string) saves string to local path. loadString loadString(utf8_path) reads local txt file then returns string. getColor getColor(id,x,y) get pixel color at location (x,y) of texture id. Returns r,g,b,a 4 doubles. getColor(x,y) equals to getColor(INPUT,x,y) It is highly efficient to call getColor before any draw function(Such as immediately after version3()). Otherwise, it is very low efficient since it queries pixels from the graphic card. Valid id: INPUT,OUTPUT,PARAM0~PARAM9 setColor setColor(x,y,r,g,b,a) set the pixel at location (x,y) of texture OUTPUT. It is highly efficient to call setColor before any draw function getSize getSize(id) returns the size of texture id. (Two doubles, width, and height) Due to the Ae's downsample (1/2,1/4) mechanism, the size you get would variating 0~4px. But this kind of variating doesn't change with time. The size is promised to be accurate in full resolution(without downsample). shadertoy shadertoy(code) runs code from shadertoy.com. Not all code on shadertoy.com is supported. glsl glsl(code) runs fragment stage shader code. cmd cmd(code) runs cmd code. This function is equivalent to the ISO C function system. It passes a command to be executed by an operating system shell. Its first result is true if the command terminated successfully, or nil otherwise. After this first result the function returns a string plus a number, as follows: \"exit\": the command terminated normally; the following number is the exit status of the command. \"signal\": the command was terminated by a signal; the following number is the signal that terminated the command. lua lua(code) runs lua code. runFile runFile(utf8_path) loads local lua code and run. No need to call utf8ToLocal since it supports utf8. txt txt(utf8_path) loads local text file. Returns string. No need to call utf8ToLocal since it supports utf8. "},"contents/Lua/Texture.html":{"url":"contents/Lua/Texture.html","title":"テクスチャシステム","keywords":"","body":"Texture system Make sure your PixelsWorld version is v3.3.0+ This section gives a detailed introduction of Texture system in PixelsWorld. newTex delTex getSize swapTex drawTo castTex blendTex copyTex fetchTex savePNG,loadPNG,saveEXR,loadEXR,saveRAW,loadRAW rotateTex,flipTex,resizeTex,trimTex Texture id In PixelsWorld, every texture is represented as an integer. It is called texId. The basic texIds provided by PixelsWorld are as followed. texId Globals in Lua Globals in GLSL Globals Shadertoy Description -3 OUTPUT Inaccessible Inaccessible Output texture -2 TEMP PW_TEMP_LAYER _PixelsWorld_PW_TEMP_LAYER Cache texture -1 INPUT AE_INPUT_LAYER _PixelsWorld_AE_INPUT_LAYER Input texture 0 PARAM0 0 0 Layer parameter 0 texture 1 PARAM1 1 1 Layer parameter 1 texture ... PARAM... ... ... ... 9 PARAM9 9 9 Layer parameter 9 texture You can also create your texId. The method will be covered below. How they work Normally, Ae sends a picture to PixelsWorld to process. PixelsWorld loads it to the INPUT texId, writes the result to OUTPUT texId. Finally blits all pixels to Ae. What is TEMP texId Because OpenGL doesn't support read and write to the same texture at the same time. PixelsWorld provides TEMP texId to hold the last shading results (Means the TEMP texId only makes sense in Lua mode and you called glsl function twice or more). You can use getColor(PW_TEMP_LAYER,uv); in glsl code to sample colors in TEMP texId. Create texture Use newTex(width,height) to create a texture. Returns a texId. (a random integer) Delete texture Use delTex(id) to delete a texture. In most cases, you don't have to delete texture by yourself. PixelsWorld will release all texture memory at the end of each frame. Size of texture Use getSize(id) to get the size of a texture. getSize.lua version3() mytex = newTex(512,256) w,h = getSize(mytex) println(\"Width of mytex is: \" .. w) println(\"Height of mytex is: \" .. h) Swap textures Use swapTex(id1,id2) to swap the pixels data of id1 and id2. swapTex.lua version3() tex1 = newTex(128,128) tex2 = newTex(256,256) w,h = getSize(tex1) println(\"tex1 size: \" .. w .. \", \".. h) swapTex(tex1,tex2) w,h = getSize(tex1) println(\"tex1 size after swapped: \" .. w .. \", \".. h) Set drawTo Use drawTo(id) to set the texture the objs would be drawn. The default drawTo texId is OUTPUT. Note that PixelsWorld only blits pixels in OUTPUT to Ae, no matter what the drawTo texId is. Here are 3 approaches you can send pixels in other texId to OUTPUT: drawTo(OUTPUT)+image castTex swapTex Cast texture Use castTex(toTexId,fromTexId) to cast pixels data from fromTexId to toTexId. E.g. You can cast pixels in PARAM0 to OUTPUT. castTex.lua version3() castTex(OUTPUT,PARAM0) You can also specify the cast range. (The origin is left top corner) castTex(toTexId,fromTexId,to1x,to1y,to2x,to2y) castTex(toTexId,fromTexId,to1x,to1y,to2x,to2y,from1x,from1y,from2x,from2y) Cast all pixels by default. Blend textures Use blendTex(toTexId,fromTexId,blendRule) to blend fromTex to toTex by rule blendRule blendRule can be one of NORMAL,ADD,SUBTRACT,MULTIPLY,DIVIDE,MAX,MIN. blendRule can be blend rule(string). A menas input pixels of toTexId B means input pixels of fromTexId C means output pixels of toTexId E.g. you can specify your rule to blend PARAM0 and INPUT. blendRule.lua version3() castTex(OUTPUT,INPUT) -- Cast INPUT texture to OUTPUT firstly. blendTex(OUTPUT,PARAM0,\"C=A+B\") -- Blend PARAM0 to OUTPUT. Indeed, the \"C=A+B\" will be processed to the following code inside PixelsWorld. blendRuleGLSL.frag #version 330 core out vec4 outColor; in vec2 uv; in vec2 uv2; uniform sampler2D inLayerA; uniform sampler2D inLayerB; void main(){ vec4 A = texture(inLayerA,uv); vec4 B = texture(inLayerB,uv2); vec4 C = A; C=A+B // Your blend rule is combined here. ; } Same with castTex, blendTex also supports range specifying: blendTex(toTexId,fromTexId,blendRule,to1x,to1y,to2x,to2y) blendTex(toTexId,fromTexId,blendRule,to1x,to1y,to2x,to2y,from1x,from1y,from2x,from2y) Copy texture Use copyTex(refTexId) to copy texture. Returns new texId. Fetch texture at any time Use fetchTex(layerId, time) to obtain the specified layer pixels at the specified time. It returns a random texture ID. layerId: Only PARAM0~PARAM9 are accepted. time: The double layer time in seconds. Note: Use of this function would cause wrong caching. Please purge the chache while you are using this function. New in v3.4.3+. Texture IO Use savePNG(utf8Path,texId),loadPNG(utf8Path) to save or load PNG image. Use saveEXR(utf8Path,texId),loadEXR(utf8Path) to save or load EXR image. Use saveRAW(utf8Path,texId),loadRAW(utf8Path) to save or load MiLai original raw memory image. Supported image specifications are listed below. Format Library Supported compression algorithms Color format PNG cute_headers DEFLATE compliant decompressor zlib(RFC 1950) RGBA,clamped 8bit unsigned integer per channel. EXR tinyexr NONE,RLE,ZIP,ZIPS,PIZ,ZFP RGBA,HDR 32bit floating point per channel. RAW (None) MiLai original format. (See figure below) RGBA, HDR 32bit floating-point per channel. Load PNG image to scene: loadPNG.lua version3() local mypng = loadPNG([[d:\\test.png]]) -- Replace to your path. castTex(OUTPUT,mypng) -- Cast pixels from mypng to OUTPUT. Save OUTPUT texId to local: savePNG.lua version3() --Draw something to OUTPUT move(width/2,height/2) rotate(time) triangle() --End drawing. savePNG([[d:\\test.png]],OUTPUT) -- Save OUTPUT as PNG to local disc. Replace to your path here. Change PNG to EXR to read/write EXR file. Some local paths might need running Ae under the Administrator mode. Edit texture Use rotateTex(texId,times) to rotate texture 90*timesdegrees, rotateTex(texId) equals to rotateTex(texId,1) Use flipTex(texId,flipV) to mirror flip a image. flipV is a boolean. When flipV is true, flip the image vertically, and horizontally otherwise. Use resizeTex(texId,width,height) to resize texture. Use trimTex(texId,p1x,p1y,p2x,p2y) to trim texture. The origin of p1x,p1y,p2x,p2y is left top corner. "},"contents/Lua/Simulation.html":{"url":"contents/Lua/Simulation.html","title":"物理シミュレーション","keywords":"","body":"物理シミュレーション 次の動画はnimitzさんが作った作品Chimera's BreathのPixelsWorldにおいて実装した結果です。フルサイズ動画 この章では、PixelsWorldを用いてキャッシュの扱い方を紹介します。 注意：正しいシミュレーション結果を得るために、本マニュアルにきちんと読んだ上でコードを実装してください。 v3.3.3+以上のPixelsWorldが必要です。 この章は、読者が既にAe及びPixelsWorldを深く理解したと仮定して書いたものです。 キャッシュデータ キャッシュテクスチャ キャッシュデータ使用例：三体問題 キャッシュテクスチャ使用例：ライフゲーム キャッシュテクスチャ使用例：流体シミュレーション キャッシュデータ データをキャッシュするために、次の手順に従ってください。 コード： キャッシュの保存する場所とキャッシュファイルの名前を決める frameId=time*fpsを計算する lastFrameId=frameId-1を計算する lastFrameId データを初期化する。7へ 前のフレームで保存したデータファイルを読み取る。ファイルがない場合エラーを出力する。他の場合、7へ 今のフレームのデータを計算する。 データをローカルに保存する。 操作： 上の手順に満たすコードを実装する。 Aeの時間カーソルを最初のフレームに移動させる。 Aeのキャッシュを削除する(Edit->Purge->All Memory & Disk Cache... 下の図に示すように) Ctrl+Altを押しながら、LOGO画像をクリックする。（このステップはオプショナル） スペースキーを押してレンダリングする。(フレームをスキップしないこと) 注意：何か不具合があったら (エラー、画像キャッシュの不具合など)、2～5をやり直してください。 キャッシュテクスチャ コード： 画像の質が下がったら(例えば：1/2, 1/4 プレビューモード), エラーを出す。 frameId=time*fpsを計算する lastFrameId=frameId-1を計算する lastFrameId データを初期化する。7へ 前のフレームで保存したデータファイルを読み取る。ファイルがない場合エラーを出力する。他の場合、7へ 今のフレームのデータを計算する。 データをローカルに保存する。 テクスチャの操作方法に関しては、こちらをご覧ください。 操作： 上の手順に満たすコードを実装する。 PixelsWorldパネルの設定のAdvanced->Internal texture formatをFloating point 32bit x RGBA (HDR)にする。 Aeの時間カーソルを最初のフレームに移動させる。 Aeのキャッシュを削除する(Edit->Purge->All Memory & Disk Cache... 上の図に示すように) Ctrl+Altを押しながら、LOGO画像をクリックする。（このステップはオプショナル） スペースキーを押してレンダリングする。(フレームをスキップしないこと) キャッシュデータ使用例：三体問題 the_three_body_problem.lua version3() -- Include vector library require(\"veclib\") -- Set cache file name local cacheFileName = \"A\" -- Add checking if file exists function(Refer: https://stackoverflow.com/questions/4990990/check-if-a-file-exists-with-lua) function file_exists(name) local f=io.open(name,\"r\") if f~=nil then io.close(f) return true else return false end end -- Calculate current frame index then round it to integer. local frameId = math.floor(time * fps + .5) -- Calculate last frame index local lastFrameId = frameId -1 -- Frame id should not be negative. assert(frameId >= 0, \"FrameId not support\") -- Print it out. (This line can be removed) println(\"Frame ID: \" .. frameId) -- Set cache folder. (Here I used the aep project folder, don't forget to save your project before use projectFolder) local cachePath = projectFolder .. \"cache\\\\\" -- Print it out. (This line can be removed) println(\"Cache path: \" .. cachePath) -- If frameId == 0 (Namely lastFrameId キャッシュテクスチャ使用例：ライフゲーム game_of_life.lua version3() -- Check downsample settings. assert(width == ds_width and height == ds_height , \"Downsample not support\" ) -- Add checking if file exists function(Refer: https://stackoverflow.com/questions/4990990/check-if-a-file-exists-with-lua) function file_exists(name) local f=io.open(name,\"r\") if f~=nil then io.close(f) return true else return false end end -- Calculate current frame index then round it to integer. local frameId = math.floor(time * fps + .5) -- Calculate last frame index local lastFrameId = frameId -1 -- Frame id should not be negative. assert(frameId >= 0, \"FrameId not support\") -- Print it out. (This line can be removed) println(\"Frame ID: \" .. frameId) -- Set cache folder. local cachePath = projectFolder .. \"cache\\\\\" -- Print it out. (This line can be removed) println(\"Cache path: \" .. cachePath) -- Check if it is frame 0 if(lastFrameId = res.x || iuv.x =res.y || iuv.y.5; } // From https://thebookofshaders.com/10/ float random (vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123); } void main(){ if(time == 0.) { outColor = vec4(random(uv)>.5); }else{ bool curstatus = fetchStatus(0,0); int roundCount = 0; for(int i = 0;i 3) outColor = vec4(0); else outColor = vec4(curstatus); } else { if(roundCount == 3) outColor = vec4(1); else outColor = vec4(0); } } } ]==] -- Put the last frame texture to PARAM0, so that you can read last frame texture via layer[0] swapTex(PARAM0,lastTexA) -- Render texture glsl(fragCode) -- Put the last frame texture back to its original position. swapTex(PARAM0,lastTexA) -- Save texture to local saveRAW(cachePath .. \"A_\" .. tostring(frameId) .. \".raw\",OUTPUT) キャッシュテクスチャ使用例：流体シミュレーション 注意：元作者のコードライセンスより、次のコードを学習目的のみに使用してください。商業目的はお控えください。 プラグインパネルの設定Internal texture formatをFloating point 32 bit x RGBA (HDR)にするのを忘れないで下さい。 シミュレーションの実行に着手する前に、マニュアルを読んだことを確認してください マニュアル>>> Mipmap filterをNONEにすることでスピードアップ fluid_simulation.lua version3() assert(width == ds_width and height == ds_height , \"Downsample not support\" ) function file_exists(name) local f=io.open(name,\"r\") if f~=nil then io.close(f) return true else return false end end local frameId = math.floor(time * fps + .5) local lastFrameId = frameId -1 assert(frameId >= 0, \"FrameId not support\") println(\"Frame ID: \" .. frameId) local cachepath = projectFolder .. \"cache\\\\\" println(\"Cache path: \" .. cachepath) if(lastFrameId "},"contents/Lua/Poly.html":{"url":"contents/Lua/Poly.html","title":"Poly関数","keywords":"","body":"Creation origin: Poly function poly(obj) analyzes the inputted obj, then draws it to the scene. Usage If you are familiar with Houdini, constructing an obj is basically to fill a SpreadSheet. Here is an example of constructing an obj of an unusual colorful triangle. PolyTest1.lua version3() background(0.95) move(width/2,height/2) dim3() dotRadius(5) obj={ point={ {p={0,0,0},color={0,1,1}}, {p={100,0,0},color={1,1,0}}, {p={0,100,0},color={1,0,1}}, {p={100,100,0},color={1,0,0}}, }, prim={ {type=\"triangle\",pref={1,2,3}}, {type=\"line\",pref={2,3,3,4,4,2}}, {type=\"point\",pref={2,4}}, } } poly(obj) Supporting primitives Assumepref={1,2,3,4,5,6}. pref means point reference. The semicolon (;) is the end mark of one primitive drawing. type name Corresponding primitive Drawing order full type name points Points 1;2;3;4;5;6; points pointd 2d point 1;2;3;4;5;6; point disc pointb 3d point 1;2;3;4;5;6; point ball line Single line 123456; single line linef Single 2d line 123456; line flat linec Single 3d line 123456; line capsule linel Loop line 1234561; line loop linelf Loop 2d line 1234561; line loop flat linelc Loop 3d line 1234561; line loop capsule lines Lines 12;34;56; lines linesf 2d lines 12;34;56; lines flat linesc 3d lines 12;34;56; lines capsule triangles Triangle meshes 123;456; triangles triangleb Bridge structure triangle meshes 123;324;345;546; triangle bridge triangler Radial structure triangle meshes 123;134;145;156; triangle radial The structure of obj The obj structure is defined by the following steps: obj is a table. obj contains 4 keys: point,vertex,prim,detail. The 4 keys in obj have their value called pointArray, vertexArray, primArray, detailList. pointArray is required. vertexArray is optional. primArray is required. detailList is optional. The above-mentioned value names that are Array suffixed holds N sub-tables, where N can be defined by users. The kth sub-table of pointArray is called point[k] or \"The kth point\". The kth sub-table of vertexArray is called vertex[k] or \"The kth child-point\". The kth sub-table of primArray is called prim[k] or \"The kth primitive\". The detailList and Points, child-points, primitives, have some non-subdividable units：the Key-value pairs. We call these keys K, and values V. K should only contain alphabets, numbers, and underlines. And K shouldn't be all numbers. V has 7 types: 1D, 2D, 3D, 4D, string, texture id and index serial. For all double floating numbers x,y,z,w x or {x} is 1D V. {x,y} is 2D V. {x,y,z} is 3D V. {x,y,z,w} is 4D V. \"Hello! PixelsWorld!\" is string V. When (K ends up with \"_tex\") and (V is an integer and the corresponding texture exists), it is texture id V. For integer serial a1,...,an,{a1,a2,a3,...,an} is index serial V. For all point[k], there must be a K named \"p\" to represents the location, or it is an invalid point. For all vertex[k], there must be a K named \"pref\" and its V is an integer to represent the reference point id, or it is an invalid child-point. For all prim[k], there must be a K named \"type\" and its V is string to represents the type of the primitive. And there also must be a K named \"vref\"or \"pref\" and its V is index serial to represent the order of points drawing. Override priority For same K, the following override priority is defined: Same with Houdini. vertex point prim detail Example: The following obj's prim contains a color attribute (Red), So we will get a red triangle. PrimColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0}}, {p={100,0,0}}, {p={0,100,0}}, }, prim={ {type=\"triangle\",pref={1,2,3},color={1,0,0}}, }, } poly(obj) This time, both prim and point contain color, and because the priority of point is higher, so the color attribute in point will be used, then we will get a colorful triangle. PointColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},color={0,1,1}}, {p={100,0,0},color={1,1,0}}, {p={0,100,0},color={1,0,1}}, }, prim={ {type=\"triangle\",pref={1,2,3},color={1,0,0}}, }, } poly(obj) Usage of vertex Vertex (child-point) inherits all attributes from point. VertexColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0}}, {p={100,0,0}}, {p={0,100,0}}, {p={100,100,0}}, }, vertex={ {pref=1,color={1,0,0}}, {pref=2,color={1,0,0}}, {pref=3,color={1,0,0}}, {pref=2,color={0,1,0}}, {pref=3,color={0,1,0}}, {pref=4,color={0,1,0}}, }, prim={ {type=\"triangle\",vref={1,2,3,4,5,6}}, }, } poly(obj) pref is used to define which point to be referenced, the full name of pref is Point reference. So the vref means Vertex reference. Note: The index in Lua starts from 1, not 0. Without vertex, the triangle looks like this: NoVertex.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},color={1,0,0}}, {p={100,0,0},color={1,0,0}}, {p={0,100,0},color={1,0,0}}, {p={100,100,0},color={0,1,0}}, }, prim={ {type=\"triangle\",pref={1,2,3,2,3,4}}, }, } poly(obj) Extra shader Yes! You can even write a shader to an obj. FragColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},myattribute={1,0}}, {p={100,0,0},myattribute={0,1}}, {p={0,100,0},myattribute={0,0}}, {p={100,100,0},myattribute={1,1}}, }, prim={ { type=\"triangle\", pref={1,2,3,2,3,4}, frag=[==[ #define t ]==] .. tostring(time) .. [==[ void main(){ outColor = vec4(mod(myattribute*10+vec2(t),1),0,1); } ]==], }, }, } poly(obj) Use texture Here is an example of how to use texture. The integer that its key name ends up with _tex is treated as a texture id. Using an extra shader in a prim can handle more than one texture. More information about texture... UVTex.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},uv={0,0}}, {p={100,0,0},uv={1,0}}, {p={0,100,0},uv={0,1}}, {p={100,100,0},uv={1,1}}, }, prim={ { type=\"triangler\", pref={1,2,4,3}, my_tex=INPUT, }, }, } poly(obj) "},"contents/Lua/TransparencyRender.html":{"url":"contents/Lua/TransparencyRender.html","title":"透明オブジェレンダー法","keywords":"","body":"透明オブジェレンダー法 普通、透明なキューブ列をレンダーしようとしたら次の結果を得ます。 normalCubes.lua version3() in2out() dim3() fill(1,.5) move(width/2, height/2) for i = 1,10 do move(20,0,200) cube() end 実際この結果は正しくありません。なぜなら、透明なオブジェなのに、我々の望むようにスケスケのキューブに見えないからです。 正しい結果を得るために、透明な物体をカメラから遠い順でレンダーしなければならない。（すべての物体が透明でない場合はこれを拘りません）。よって、レンダーする前に物体の並び替えが必要です。 sortCubes.lua version3() in2out() dim3() fill(1,.5) sortarr = {} beginGroup() move(width/2, height/2) for i = 1,10 do move(20,0,200) local x,y,z = global2screen(local2global(0,0,0)) -- カメラから見る物体の位置を入手する sortarr[i] = {z,getTransformMatrix()} -- {distance, transform status} pairs end endGroup() table.sort( sortarr, function(a,b) return a[1] > b[1] end -- ｚの値を用いて並び替えする ) for i = 1,10 do beginGroup(sortarr[i][2]) -- Apply transform status cube() endGroup() end "},"contents/Lua/RunGLSL.html":{"url":"contents/Lua/RunGLSL.html","title":"LuaでGLSLを実行する","keywords":"","body":"LuaでGLSLを実行する 使用例 glsl.lua version3() glsl(Your_code_string_here) 注意：[==[Your_code_string_here]==]を用いてコードを囲むことがお勧めです。なぜなら、この囲み方は\\nのような変換を阻止できるからです。 glsl2.lua version3() glsl([==[ void main(){ outColor = vec4(uv,sin(time*10)/2+.5,1); } ]==]) shadertoy.comからのコードもレンダーできます。 shadertoy.lua version3() shadertoy(Your_shadertoy_code_here) "},"contents/GLSL/GLSLCode.html":{"url":"contents/GLSL/GLSLCode.html","title":"グラフィックスバーサーカーGLSL","keywords":"","body":"GPUバーサーカーGLSL この章では、GLSLの使い方を紹介します。 GLSLとは？ GLSLは「OpenGL Shader Language」の略称です。GPUで実行される言語の一種です。 どうやって学びますか The book of shaders（オンライン無料）の閲覧をお勧めです。 GPUレンダーのメリットは？ ここで、比喩でCPUをスーパーカー、GPUをバスとしましょう。 もし、少人数（二人ぐらい）の人を運輸しようとすれば、スーパーカーの方は早くていいでしょう。（高速で複雑な演算をします） さて、多人数の場合はどうでしょうか。バスのほうはスピードが遅いが、一気に多数の人を運搬できるというメリットが大きくなって、このケースではバスのほうがかなり有能だと考えてもいいでしょう。（同じ演算を一斉にします） 普通我々の耳にした多くの言語（C/C++、Java、Python）はCPUで実行されています。 GLSLは、GPUで実行できるようにデザインされています。 画像を一枚レンダーしようとするときに、GPUは大勢の「ワーカー」を雇って計算方法と入力値を与えて働かせるというイメージを持ってもいいでしょう。 GLSLを徹底的に勉強したい方に対して、こちらのサイト：shadertoy.comをお勧めします。面白そうなコードを見つけてそれをいじることよりわりと速く上達するので、ぜひご活用ください。 詳細（これ以降の内容はベテラン向けです） GLSLコードがOpenGLに発信される前に、PixelsWorldは、いくつかの前置きコードと後置きコードを連結する処理を行います。 PixelsWorld V3.0.0 は #version 330 core　を使います。 ここで 前置きコードと後置きコードが記載されています。 "},"contents/GLSL/RunGLSL.html":{"url":"contents/GLSL/RunGLSL.html","title":"GLSLの実装","keywords":"","body":"GLSLの実装 GLSL(GPU) モードになっていることをまず確認しましょう。 次のコードを入力してください。 default.shader void main(){ outColor = getColor(uv); } このコードはただ入力された画像をそのまま出力するコードです。 getColor(uv) を vec4(uv,0.0,1.0)　に変えてきれいなUVパターンをレンダーすることができます。 uvcolor.shader void main(){ outColor = vec4(uv,0.0,1.0); } "},"contents/GLSL/GetStart.html":{"url":"contents/GLSL/GetStart.html","title":"クイックスタート","keywords":"","body":"What it feels like to develop effects with PixelsWorld? PixelsWorld is just like Microsoft Excel. You write function, it will handle the data in the form for you. If we treat the data in form as input pixels, the calculated form as output pixels, Codes in PixelsWorld is the function in Microsoft Excel E.g. Make picture brighter To make a picture brighter, the simplest approach is just add the R,G,B by a number. If in Excel, we need to do something like this: Then we have made all pixels data \"brighter\" ! Here is what we need to write in PixelsWorld: bright_describe.shader outColor=getColor(uv)+vec4(0.2); It means: Get the input pixels (getColor) in current location (uv), and add the 4D vector RGBA by (0.2,0.2,0.2,0.2) (+vec4(0.2)). Finally, send (=) the result to the output pixel(outColor). But if we only write this single line, PixelsWorld cannot work fine. We need to add this line inside a \"shell\" to make it work. The complete version is this: bright.shader void main(){ outColor=getColor(uv)+vec4(0.2); } How to input codes Input picture (Right click to save) (Source artist) Result Add more controls! Mostly we don't just add 0.2 to the picture. We want it to be more controllable. So we can replace the 0.2 to slider[0]. In this way, we can change the value in Parameters panel to change the brightness of your picture. bright_control.shader void main(){ outColor=getColor(uv)+vec4(slider[0]); } But you can find that, if the value is negative, the picture will be transparent, we don't want this happened. Namely we need to avoid modifying the Alpha channel of the picture. bright_control.shader void main(){ vec4 inColor = getColor(uv); inColor.rgb = inColor.rgb + vec3(slider[0]); outColor = inColor; } It means: Save the input pixel into a temporary variable inColor, Add the value of slider[0] to the RGB of inColor, then send the inColor to the outColor. Add label to the parameter Save to preset Finally, we can save the code as a preset for next using. Go to the Preset management to learn more details. Congratulations! You have already mastered the most part of PixelsWorld! In addition to writing codes by yourself, you can go to the shadertoy, find some interesting code and run it in PixelsWorld. See this to learn how to use code from shadertoy. "},"contents/GLSL/Functions.html":{"url":"contents/GLSL/Functions.html","title":"内装関数","keywords":"","body":"Functions This section will give a brief introduction of the functions created by us. The functions mentioned in this section could be immediately used without any declaration. "},"contents/GLSL/getColor.html":{"url":"contents/GLSL/getColor.html","title":"getColor","keywords":"","body":"getColor This function has two versions: getColor(vec2) and getColor(int ,vec2). getColor(vec2) Description : Get the color of inLayer in specified position. Parameters : vec2 : uv position. Return : vec4 : a RGBA color. getColor(int,vec2) Description : Get the color of specified layer in specified position. Parameters : int : layer id, -1 (or AE_INPUT_LAYER) means inLayer, number between 0 and 9 means the corresponding Layer Parameter in your plugin panel. (PW_TEMP_LAYER (which is -2) is provided in Lua render mode) vec2 : uv coordinates. Return : vec4 : a RGBA color. NOTE : So in other words, getColor(AE_INPUT_LAYER,uv); totally equals to getColor(uv); getColor(n,uv); can return the pixels of layer[n]. "},"contents/GLSL/uvxy.html":{"url":"contents/GLSL/uvxy.html","title":"uv2xy,xy2uv","keywords":"","body":"uv2xy,xy2uv This two functions can translate a vec2 between UV Coordinate and XY Coordinate. It just do some multiplication and division for you. uv2xy(vec2) Description : Calculate the xy position for a given uv position. Parameters : vec2 : uv position. Return : vec2 : xy position. NOTE : If your layer size is 1280 x 720. The uv2xy(vec2(0.1,0.5)); will return vec2(128.0,360.0); xy2uv(vec2) Description : Calculate the uv position for a given xy position. Parameters : vec2 : xy position. Return : vec2 : uv position. NOTE : If your layer size is 1920 x 1080. The xy2uv(vec2(192,108)); will return vec2(0.1,0.1); "},"contents/GLSL/LinkParameters.html":{"url":"contents/GLSL/LinkParameters.html","title":"パラメータリンク","keywords":"","body":"パラメーター　リンク Parametersの中のパラメーターを生かしてアニメを作ることができます。 上の図に示すように、七種のパラメーターがあります。 Sliders Angles Points 3D Points Checkboxes Colors Layers 各種にまた10個のパラメーターが入っています。 使用例 : link_slider.shader void main(){ outColor = vec4(uv,slider[0],1.0); } 詳細 パラメーター変数は次のように定義されています。 parameters.shader uniform float slider[10]; uniform float angle[10]; uniform bool checkbox[10]; uniform vec2 point[10]; uniform vec3 point3d[10]; uniform vec4 color[10]; uniform sampler2D layer[10]; uniform sampler2D inLayer; 注意: \"inLayer\" は入力テクスチャです。 sampler2D　の使い方について、 \"getColor\"セクションをご覧ください。 \"uniform\" はグローバル変数であることを宣言する修飾子です。 "},"contents/GLSL/debug.html":{"url":"contents/GLSL/debug.html","title":"デバッグ","keywords":"","body":"Debug Check the debug checkbox in the plugin panel. If your program contains errors, it will be printed into left top corner of your screen when this is checked. "},"contents/GLSL/Advanced_settings.html":{"url":"contents/GLSL/Advanced_settings.html","title":"高級設定","keywords":"","body":"　高級設定 　Wrap U/V sampler テクスチャの縁での色の取り方を指定する設定です。 次のコードを実装してこの設定をいじってみてください。 wrap_uv_sampler.shader void main(){ outColor = getColor(uv*10); } 　Magnify/Minify sampler テクスチャを拡大・縮小するときの色の取り方を指定する設定です。 次のコードを実装してこの設定をいじってみてください。 wrap_uv_sampler.shader void main(){ outColor = getColor(uv*0.1); } Mipmap テクスチャを縮小するときの色の取り方を指定する設定です。 次のコードを実装してこの設定をいじってみてください。 wrap_uv_sampler.shader void main(){ outColor = getColor(uv*10); } "},"contents/GLSL/predefined.html":{"url":"contents/GLSL/predefined.html","title":"プリコード","keywords":"","body":"Predifined code Before run shader code, PixelsWorld conbine your input with some predifined code to support some features. GLSL mode only has pre-define code. shadertoy mode has both pre-define and post-define code. GLSL mode Pre-define code pre_frag_shader_glsl.frag #define gl_Position uv2xy(uv) #define gl_FragCoord uv2xy(uv) #define gl_FragColor outColor #define INPUT_LAYER_INDEX -1 #define OUTPUT_LAYER_INDEX -2 #define AE_INPUT_LAYER -1 #define PW_TEMP_LAYER -2 out vec4 outColor; in vec2 uv; uniform float slider[10]; uniform float angle[10]; uniform bool checkbox[10]; uniform vec2 point[10]; uniform vec3 point3d[10]; uniform vec4 color[10]; uniform sampler2D layer[10]; uniform vec2 layerResolution[10]; uniform sampler2D inLayer; uniform sampler2D outLayer; uniform float time; uniform float inpoint; uniform float duration; uniform float comp_time; uniform vec4 date; // vec4(year,month,day,hour*3600 + minute*60 + second + millisecond/1000.) uniform float fps; uniform float width; uniform float height; uniform vec2 origin; uniform vec2 resolution; uniform vec2 downsample; uniform mat4 camera_matrix; uniform vec4 camera_info; // x,y: resolution, z: distance to plane, w: distance to focus. uniform bool camera_perspective; uniform sampler1D inWaveL; // Left wave samples uniform sampler1D inWaveR; // Right wave samples uniform float inWaveN; // Wave sample number uniform float inWaveS; // Sample rate, settings in plugin panel. Default: 44100. uniform vec2 inWaveT; // vec2(sampleStartTime, sampleEndTime), unit: second. New in v3.4.0 uniform sampler1D inSpecL; // Left spectrum samples uniform sampler1D inSpecR; // Right spectrum samples uniform float inSpecN; // Spectrum sample number uniform vec2 inSpecF; // vec2(spectrumStartFrequency, spectrumEndFrequency), unit: hz. New in v3.4.0 vec4 getColor(int layerId,vec2 coord) { if(layerId==AE_INPUT_LAYER) return texture(inLayer,coord); if(layerId==PW_TEMP_LAYER) return texture(outLayer,coord); else if(layerId>=0 && layerId shadertoy mode Pre-define code pre_frag_shader_shadertoy.frag #define gl_Position (_PixelsWorld_uv * iResolution.xy) #define gl_FragCoord (_PixelsWorld_uv * iResolution.xy) #define gl_FragColor _PixelsWorld_outColor #define _PixelsWorld_INPUT_LAYER_INDEX -1 #define _PixelsWorld_OUTPUT_LAYER_INDEX -2 #define _PixelsWorld_AE_INPUT_LAYER -1 #define _PixelsWorld_PW_TEMP_LAYER -2 uniform vec3 iResolution; uniform float iTime; uniform float iTimeDelta; uniform int iFrame; // uniform float iChannelTime[4]; uniform vec4 iMouse; uniform vec4 iDate; uniform sampler2D iChannel0; uniform sampler2D iChannel1; uniform sampler2D iChannel2; uniform sampler2D iChannel3; uniform vec3 iChannelResolution[4]; uniform float _PixelsWorld_slider[10]; uniform float _PixelsWorld_angle[10]; uniform bool _PixelsWorld_checkbox[10]; uniform vec2 _PixelsWorld_point[10]; uniform vec3 _PixelsWorld_point3d[10]; uniform vec4 _PixelsWorld_color[10]; uniform sampler2D _PixelsWorld_layer[10]; uniform vec2 _PixelsWorld_layerResolution[10]; uniform sampler2D _PixelsWorld_inLayer; uniform sampler2D _PixelsWorld_outLayer; uniform float _PixelsWorld_time; uniform float _PixelsWorld_inpoint; uniform float _PixelsWorld_duration; uniform float _PixelsWorld_comp_time; uniform vec4 _PixelsWorld_date; uniform float _PixelsWorld_fps; uniform float _PixelsWorld_width; uniform float _PixelsWorld_height; uniform vec2 _PixelsWorld_origin; uniform vec2 _PixelsWorld_resolution; uniform vec2 _PixelsWorld_downsample; uniform mat4 _PixelsWorld_camera_matrix; uniform vec4 _PixelsWorld_camera_info; uniform bool _PixelsWorld_camera_perspective; uniform sampler1D _PixelsWorld_inWaveL; uniform sampler1D _PixelsWorld_inWaveR; uniform float _PixelsWorld_inWaveN; uniform float _PixelsWorld_inWaveS; uniform vec2 _PixelsWorld_inWaveT; uniform sampler1D _PixelsWorld_inSpecL; uniform sampler1D _PixelsWorld_inSpecR; uniform float _PixelsWorld_inSpecN; uniform vec2 _PixelsWorld_inSpecF; in vec2 _PixelsWorld_uv; out vec4 _PixelsWorld_outColor; vec4 _PixelsWorld_getColor(int layerId,vec2 coord) { if(layerId==_PixelsWorld_AE_INPUT_LAYER) return texture(_PixelsWorld_inLayer,coord); if(layerId==_PixelsWorld_PW_TEMP_LAYER) return texture(_PixelsWorld_outLayer,coord); else if(layerId>=0 && layerId Post-define code post_frag_shader_shadertoy.frag void main(){ mainImage(_PixelsWorld_outColor, _PixelsWorld_uv * iResolution.xy); } "},"contents/GLSL/shadertoy.html":{"url":"contents/GLSL/shadertoy.html","title":"テンプレート聖域shadertoy","keywords":"","body":"テンプレート聖域shadertoy 使い方 shadertoyモードでは、shadertoy.comでのコードを直接PixelsWorldに実装することができます。 注意： すべてのshadertoyのコードがサポートされているというわけではないです。VRの使ったコードやループの入ったBufferを使ったコードはサポートされていません。 詳細 PixelsWorldの変数をこのモードで使いたいならば、_PixelsWorld_を変数名の前につけてください。 例えば、GLSLモードのslider[0]　は　_PixelsWorld_slider[0]　になります。 すべてのグローバル変数の定義はこのページに書かれているので、参考にしてください。 _PixelsWorld_の付いた変数名の宣言はお勧めしません。 Buffersの使い方 Shadertoyには四つのBuffersを生かして複雑なエフェクトを生成する機能が実装されています。BuffersはPixelsWorldにおいても実装可能です。 ループ参照なしBuffers 実装するエフェクトにはBuffers同士の間ループ参照がなければ、ループ参照なしエフェクトと我々は呼びます。次のコードテンプレートを用いてループ参照なしエフェクトを実装することが可能です。 例：エフェクト元： https://www.shadertoy.com/view/4dVGRW このエフェクトはBufferAを使ったので、四行目のAをtrueにセットします。 BufferAはMainのiChannel0にバインドされているので、AtoMainを0にセットします。 次に、BufferA・Mainのコードを丸ごとコピペします。 最後にAdvanced->Internal texture formatをFloating point 32 bit x RGBA (HDR)にセットします。 PixelsWorldがLuaレンダリングモードにあるかどうかも忘れずにチェックすること。 rotatingCubes.lua version3() enable = { A=true, B=false, C=false, D=false, -- '-1': disable -- '0~3': which iChannel to set AtoB = -1, AtoC = -1, AtoD = -1, AtoMain = 0, BtoC = -1, BtoD = -1, BtoMain = -1, CtoD = -1, CtoMain = -1, DtoMain = -1, } mainCode = [==[ // Paste the main code here. mat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) { vec3 rr = vec3(sin(roll), cos(roll), 0.0); vec3 ww = normalize(target - origin); vec3 uu = normalize(cross(ww, rr)); vec3 vv = normalize(cross(uu, ww)); return mat3(uu, vv, ww); } vec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) { mat3 camMat = calcLookAtMatrix(origin, target, 0.0); return normalize(camMat * vec3(screenPos, lensLength)); } vec2 squareFrame(vec2 screenSize, vec2 coord) { vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0; position.x *= screenSize.x / screenSize.y; return position; } vec2 getDeltas(sampler2D buffer, vec2 uv) { vec2 pixel = vec2(1. / iResolution.xy); vec3 pole = vec3(-1, 0, +1); float dpos = 0.0; float dnor = 0.0; vec4 s0 = texture(iChannel0, uv + pixel.xy * pole.xx); // x1, y1 vec4 s1 = texture(iChannel0, uv + pixel.xy * pole.yx); // x2, y1 vec4 s2 = texture(iChannel0, uv + pixel.xy * pole.zx); // x3, y1 vec4 s3 = texture(iChannel0, uv + pixel.xy * pole.xy); // x1, y2 vec4 s4 = texture(iChannel0, uv + pixel.xy * pole.yy); // x2, y2 vec4 s5 = texture(iChannel0, uv + pixel.xy * pole.zy); // x3, y2 vec4 s6 = texture(iChannel0, uv + pixel.xy * pole.xz); // x1, y3 vec4 s7 = texture(iChannel0, uv + pixel.xy * pole.yz); // x2, y3 vec4 s8 = texture(iChannel0, uv + pixel.xy * pole.zz); // x3, y3 dpos = ( abs(s1.a - s7.a) + abs(s5.a - s3.a) + abs(s0.a - s8.a) + abs(s2.a - s6.a) ) * 0.5; dpos += ( max(0.0, 1.0 - dot(s1.rgb, s7.rgb)) + max(0.0, 1.0 - dot(s5.rgb, s3.rgb)) + max(0.0, 1.0 - dot(s0.rgb, s8.rgb)) + max(0.0, 1.0 - dot(s2.rgb, s6.rgb)) ); dpos = pow(max(dpos - 0.5, 0.0), 5.0); return vec2(dpos, dnor); } void mainImage(out vec4 fragColor, in vec2 fragCoord) { vec3 ro = vec3(sin(iTime * 0.2), 1.5, cos(iTime * 0.2)) * 5.; vec3 ta = vec3(0, 0, 0); vec3 rd = getRay(ro, ta, squareFrame(iResolution.xy, fragCoord.xy), 2.0); vec2 uv = fragCoord.xy / iResolution.xy; vec4 buf = texture(iChannel0, fragCoord.xy / iResolution.xy); float t = buf.a; vec3 nor = buf.rgb; vec3 pos = ro + rd * t; vec3 col = vec3(0.5, 0.8, 1); vec2 deltas = getDeltas(iChannel0, uv); if (t > -0.5) { col = vec3(1.0); col *= max(0.3, 0.3 + dot(nor, normalize(vec3(0, 1, 0.5)))); col *= vec3(1, 0.8, 0.35); } col.r = smoothstep(0.1, 1.0, col.r); col.g = smoothstep(0.1, 1.1, col.g); col.b = smoothstep(-0.1, 1.0, col.b); col = pow(col, vec3(1.1)); col -= deltas.x - deltas.y; fragColor = vec4(col, 1); } ]==]; commonCode = [==[ // Paste the common code here. ]==] bufferACode = [==[ // Paste the Buffer A code here. float sdBox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); } vec2 mirror(vec2 p, float v) { float hv = v * 0.5; vec2 fl = mod(floor(p / v + 0.5), 2.0) * 2.0 - 1.0; vec2 mp = mod(p + hv, v) - hv; return fl * mp; } vec2 rotate2D(vec2 p, float a) { return p * mat2(cos(a), -sin(a), sin(a), cos(a)); } float map(vec3 p) { float r = iMouse.z > 0.0 ? iMouse.x / 100.0 : iTime * 0.9; p.xz = mirror(p.xz, 4.); p.xz = rotate2D(p.xz, r); float d = sdBox(p, vec3(1)); d = min(d, sdBox(p, vec3(0.1, 0.1, 3))); d = min(d, sdBox(p, vec3(3, 0.1, 0.1))); return d; } mat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) { vec3 rr = vec3(sin(roll), cos(roll), 0.0); vec3 ww = normalize(target - origin); vec3 uu = normalize(cross(ww, rr)); vec3 vv = normalize(cross(uu, ww)); return mat3(uu, vv, ww); } vec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) { mat3 camMat = calcLookAtMatrix(origin, target, 0.0); return normalize(camMat * vec3(screenPos, lensLength)); } float calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) { float latest = precis * 2.0; float dist = +0.0; float type = -1.0; float res = -1.0; for (int i = 0; i maxd) break; float result = map(rayOrigin + rayDir * dist); latest = result; dist += latest; } if (dist = 0 and sch ループ参照ありBuffers 実際、ループ参照ありエフェクトの実装はお勧めしません。（にもかかわらず、やるとすればできます。AeとPixelsWorldと一夜漬けで戦う準備を整えてからやりましょう。準備万端です>>>） "},"contents/Lua/JavaScript.html":{"url":"contents/Lua/JavaScript.html","title":"世界の郊外JavaScript","keywords":"","body":"　世界の郊外、JavaScript Lua (CPU & GPU)モードでjs(\"Your code\")関数を用いて、JavaScriptを実行します。 executeJS.lua version3() js(\"alert('Hello PixelsWorld!')\"); 注意：PixelsWorldでJavaScriptの実行をAeのストラクチャよりお勧めしません。 "},"contents/Lua/CMDCode.html":{"url":"contents/Lua/CMDCode.html","title":"世界の基盤CMD","keywords":"","body":"世界の基盤CMD Lua (CPU & GPU)モードでcmd(\"Your code\")関数を用いて、cmdコマンドを実行します。 executeCMD.lua version3() cmd(\"echo Hello PixelsWorld! & pause\"); "},"contents/Serial/SerialAttention.html":{"url":"contents/Serial/SerialAttention.html","title":"規約","keywords":"","body":"シリアルナンバー規約 注意：aescripts.comでご購入になった及びご検討中のお客様に、当「シリアルナンバー規約」は適用しませんので、ご注意ください。 シリアルナンバー一個にはN個の認証ＰＣ数が入っています。 (N >= 1) 認証ＰＣ数一個で、一つのPCをアクティベート（認証）します。 認証ＰＣ数一個は、同じPCならば、異なるバージョンのAeにシェアされます。 アクティベートには一個の認証ＰＣ数を消耗し、反アクティベート（認証を外す）には一個の認証ＰＣ数を復元します。 アクティベート 及び 反アクティベート操作のみ、インターネットが必須で、それ以外の場合、ネット環境無しでご利用できます。 PCのマザーボードやCPUを変換する前に反アクティベートを実行し、変換完了後再びアクティベートしてください。反アクティベートを忘れ、再認証失敗の場合メールにてお問い合わせください。 シリアルナンバーには個人情報が入っていないので、シリアルナンバーの再販売を許容しますが、お勧めしません。シリアルナンバーの再販売で生じたトラブルには、未来視覚演繹グループはその責任を一切負えないのでご了承ください。 認証ＰＣ数は特にリクエストがない場合は１で販売しています。同時にたくさんのPC でPixelsWorldをご利用になりたいお客様は、PC数に応じる認証ＰＣ数をご購入ください。Flashback Japanにおいては、1~3の認証ＰＣ数の入ったシリアルナンバーを販売しています（4以上のリクエストも承ります）。たくさん購入したいお客様はこちらで購入する方がお得です。 "},"contents/QA/EntryPointErr.html":{"url":"contents/QA/EntryPointErr.html","title":"エラー： Couldn't find main entry point for PixelsWorld.aex (48::72)","keywords":"","body":"エラー: Couldn't find main entry point for PixelsWorld.aex (48::72) 次のエラーが出た時、以下の各事項をチェックしてください。 Creative Cloudを通じてAeを最新版に更新すること（CC2019の場合16.1.3+、2020の場合17.5.1+がお勧めです） Windows10 は最新版であること(Windows 10 20H2 以降のバージョンがお勧めです) グラフィックカードドライバーは最新版であること グラフィックカードはOpenGL 3.3以降のプロトコルをサポートしていること(OpenGL Extensions Viewerツールを用いて確認可能です) OpenCL.dllはC:\\Windows\\System32というパスに入っていること。 "}}