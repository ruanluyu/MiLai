{"./":{"url":"./","title":"今日、創造神になってきます！","keywords":"","body":"創造神になりましょう！ PixelsWorld マニュアルバージョン : v3.0.0 著者：中梓星音 English version 中文 注意：本マニュアルはまだ翻訳途中で一部の文章は英語となっています。 翻訳ミス報告はこちらでお願いします。 ピクセルスワールドへようこそ！ PixelsWorldのコツやエッセンスはこのページに記載されています。このページのコンテンツさえマスターすれば、PixelsWorldの全てを把握できるようになります 簡単に言えば PixelsWorldはコードでグラフィックスを描くものです ほかのアーティストが創作したコードを直接使えます。 簡単なグラフ描画言語を学んで自らグラフを作ることができます。 高度なGLSLコードを使い、VFXをゼロから構築することもできます。 PixelsWorldでコードを描くというのはどんな感じ？ PixelsWorldは描画ロボットのことと思ってもいいです。ユーザーはグラフの種類と描く地点を順番に伝えると、そのロボットは命令に応じてグラフを描いてくれます。 例えば、いまあなたは画面の中央に家を描こうとするシチュエーションを考えましょう。しかし、ペンを持っているのはあなたの親友高橋さんです。さて、あなたのいまから下す命令を考えましょう。 通常我々はこう伝えるのでしょう： DrawHouse.myBro 画面の中央に家を描け。 もちろん、人間の場合はその主旨は伝わります。もし、機械をシミュレート為に高橋さんの語彙量に制限をかけて、「グラフの種類と描く地点」のみが許されるとすればどうでしょう。我々はこう伝えるのでしょう： DrawHouse2.myBro 画筆を画面の中央に移動させろ 画筆に黄色をつけろ 画筆のある位置を中心に１０cmの正方形を描け 画筆を上へ５cm移動させろ 画筆に赤をつけろ 画筆のある位置を基準に、底が１５cm、高が１０cmの二等辺三角形を描け。 これで高橋さんは家の描く手順にしたがってあなたの思いどおりに家を仕上げられます。 実際、上の命令は、まさにPixelsWorldで描くべき命令です。具体的に、それに対応するコードは次のようになります。 DrawHouse3.lua version3() -- バージョン３を使え（必須コード） move(width/2, height/2) -- 画筆を画面の中央に移動させろ rotateX(PI) -- 上へ向け fill(1,1,0) -- 画筆に黄色をつけろ（Red=1,Green=1,Blue=0） rect(100) -- 画筆のある位置を中心に１００px大きさの正方形を描け fill(1,0,0) -- 画筆に赤をつけろ（Red=1,Green=0,Blue=0） move(0,50) -- 画筆を上へ５０px移動させろ tri(150,100) -- 画筆のある位置を基準に、底が１５０px、高が１００pxの二等辺三角形を描け。 ここで、多分予想外の命令が一つ出ました：rotateX(PI)。Aeでは、Y軸は普通は下向きなので、このY軸をX軸に沿って180度回転させる必要があります。この命令を除くと、次のmove(0,50)は画筆を下へ５０px移動させてしまいます。 天地開闢、世界を作る第一歩を踏みましょう！ まず、PixelsWorldを平面レーヤーに適用しましょう。 言語オプション（Language）はLuaモードであるかどうかを確認し、Editボタンをクリックしてください。それでは、次の図の指示に従って家の描画を完成しましょう。 この家の配色をパラメーターで制御できるようにしてみましょう： DrawHouse4.lua version3() -- バージョン３を使え（必須コード） move(width/2, height/2) -- 画筆を画面の中央に移動させろ rotateX(PI) -- 上へ向け fill(color(0)) -- 画筆に０号色をつけろ rect(100) -- 画筆のある位置を中心に１００px大きさの正方形を描け fill(color(1)) -- 画筆に１号色をつけろ move(0,50) -- 画筆を上へ５０px移動させろ tri(150,100) -- 画筆のある位置を基準に、底が１５０px、高が１００pxの二等辺三角形を描け。 これでOKボタンを押すと、なんと、家が消えてしまいました！ 実際家は消えたのではなく、ただ色のパラメーターの初期値が黒だったからです。 Colors欄を開いて、ここであなたの好きな色を選べばいいです。 「村長は俺だ！」家をたくさん建てましょう。 コードを使う一つのメリットは、重複度の高いことをしてれることです。 Lua言語では、一段落のコードをループしてくれる機能があります。 RepeatHouse.lua version3() -- バージョン３を使え（必須コード） move(width/2, height/2) -- 画筆を画面の中央に移動させろ rotateX(PI) -- 上へ向け for i=1,3 do -- ループ開始（計３回） fill(color(0)) -- 画筆に０号色をつけろ rect(100) -- 画筆のある位置を中心に１００px大きさの正方形を描け fill(color(1)) -- 画筆に１号色をつけろ move(0,50) -- 画筆を上へ５０px移動させろ tri(150,100) -- 画筆のある位置を基準に、底が１５０px、高が１００pxの二等辺三角形を描け。 move(0,-50) -- 画筆を下へ５０px移動させろ move(175,0) -- 画筆を右へ１７５px移動させろ end -- ループ終了 最後に、後日便利の為、色パラメーターに名前をつけましょう。 コマンドのセーブ、再利用 注意：ここで、ローカルディスクにファイルを書き込む為の管理者権限が必要です。管理者権限を持っていない場合、Aeを管理者モードで再開してください。 まず、プリセットコラムを新規作成しましょう。 作ったコラムで、コードをプリセットとして保存しましょう。 プリセットコードの適用 プリセットを選択し、右のReplaceボタンをクリックしてください。 おめでとうございます！ これであなたは、PixelsWorldのほぼ全部の利用方法をマスターしました。 >>>次のステップ：第三章より描画言語（Lua）の詳細を学びましょう。 "},"contents/HowTo.html":{"url":"contents/HowTo.html","title":"入手とダウンロード","keywords":"","body":"入手とダウンロード 入手方法 購入ページ/ダウンロードページ 「MiLai」フォルダーを次のパスにおいてください： AEルートフォルダー/Support Files/Plug-ins/ プラグインは次のパスにあるかどうかを確認してください： AEルートフォルダー/Support Files/Plug-ins/MiLai/PixelsWorld.aex 適用方法 Adobe After Effectsを開きます. \"Ctrl + N\"　でコンポジションを新規します。 平面レイヤーを新規します。 新規したレイヤーを選択肢ます。 右クリック => エフェクト => MiLai => PixelsWrold \"Edit\" をクリックし \"世界ルール\" を変えます。 ここでパネルが出てきます。 \"Preset list\"　でお気に入りのコラムを選択肢て下のリストから一つのプリセットを選択してください。 \"Replace\"をクリックしてください。 \"Ok\"　をクリックしてください。 "},"contents/Editor/ScriptWindow.html":{"url":"contents/Editor/ScriptWindow.html","title":"世界ルール　エディター","keywords":"","body":"世界ルール　エディター エディター プラグインパネルのWorld formulaとなりのEditボタンを押すと、世界ルール　エディターが開かれます。 ここで、記述便宜上、異なるエリアを次のようにハイライトしておきます。 ◆コードエリア コードエリアで、コード入力はできます。 このエリアのLanguage設定は、プラグインパネルにあるLanguage設定より優先度が高いです。(default)とは「パネルのほうの設定を変えずに維持する」という意味です。 ◆参照リスト ここで、よく使われているコードが挙げられています。現在、このリストは読み取り専用です。 ◆パラメーター設定 ここで、パラメーター名とパラメーター初期値を一覧することができます。Parameter managerボタンからパラメーター管理パネルが開けます。Parameter managerも参照してください。 パラメーター設定はコードと一緒にプリセットに保存できます。 ◆プリセットリスト すべてのローカルプリセットファイルはここのポップアップメニューにあります。 プリセットに関するの定義をここでここで述べておきます。 ファイル名の拡張子が .pwp で、 PixelsWorld.aexの隣にあるJSON 様式のファイルを「プリセットコラム」と我々は呼びます。 一つのプリセットコラムの中に若干の「プリセット」が入っています。 「プリセット」はポップアップメニューの下のリストに列挙されています。 ◆コードプレビュー 選択されているプリセットの内容をここでチェックすることができます。Replaceボタンを押すと、選択されたプリセットのコードを左のコードエリアに既存のコードを置き換えられます。 コードのみを置換し、設定を置き換えたくない場合は、パラメーター設定プレビューのApply when replaceのチェックを外してからReplaceボタンを押してください。 プリセットコードを今のコードを上書きせず、先頭につなげたい場合はボタンを、後ろにつなげたい場合はBottom>>ボタンを押してください。 ◆パラメーター設定プレビュー 選択されているプリセットのパラメーター設定をここでチェックできます。プリセットの設定を適用するにはApplyボタンを押してください。 Apply when replaceは「コードエリアのReplaceボタンを押すと自動的にこのエリアのApplyボタンを押してくれる」という意味です。 "},"contents/Editor/ParameterWindow.html":{"url":"contents/Editor/ParameterWindow.html","title":"パラメータ　エディター","keywords":"","body":"パラメータ　エディター 世界ルール　エディターのParameter managerボタンを押すと、次のパラメータ　エディターを開くことができます。 ルール パラメーター名を左に、パラメーター初期値を右に入力してください。（初期値範囲：十進数 0~1、範囲越え可能） Clear names パラメーター名を消します。 Clear all names すべてのパラメーター名を消します。 Reset names パラメーター名を初期値に戻します。 Reset all names すべてのパラメーター名を初期値に戻します。 Reset values パラメーター初期値を初期値を戻します。 Reset all value すべてのパラメーター初期値を初期値を戻します。 文字コード PixelsWorldはutf-8のパラメーター名をサポートしています。 識別されない文字コードは?マークになります。 異国環境や合同作業の場合、ASCII文字コードのパラメーター名の使用を推奨します。 "},"contents/Editor/SavePresets.html":{"url":"contents/Editor/SavePresets.html","title":"プリセット管理","keywords":"","body":"プリセット管理 プリセットの保存 World formula editorにおいて、Save as presetボタンを押し、名前を入力するコードとパラメーター設定がプリセットとして保存されます。 注意：既存の名前で保存すると上書きが発生します。 プリセットの上書き保存 World formula editorにおいて、Save as presetボタンを押し、既存の名前を入力するコードとパラメーター設定がプリセットとして保存されます。 注意：World formula editorではすべての操作を取り消すことができません。 プリセットの名前変更 変更したいプリセットをダブルクリックし、入力欄にREMOVEとSORT以外の名前を入力してください。 プリセットのアルファベット順ソート 変更したいプリセットをダブルクリックし、入力欄に大文字SORTを入力してください。 プリセットの削除 変更したいプリセットをダブルクリックし、入力欄に大文字REMOVEを入力してください。 プリセットコラムの新規作成 Preset listのAddボタンを押し、名前を入力すると新しいコラムが新規作成されます。 注意： 既存の名前は使用不可となります。 新規作成が失敗の場合、管理者権限でAeを再開してください。 プリセット仕様 フォーマット： utf-8・JSON 暗号化無し プリセットのアップロード及び公式整合リクエスト アップロードしたいプリセットをZzStarSound@gmail.com宛てに作者名前と説明文付きで送ってください。 "},"contents/Lua/LuaCode.html":{"url":"contents/Lua/LuaCode.html","title":"世界の中心Lua","keywords":"","body":"Lua コード 最初の第一章で紹介した言語の名前はLuaでした。 Luaは手続き型・プロトタイプベースのオブジェクト指向・関数型・データ駆動型のスクリプト言語である。 --Wiki Luaバージョン：Lua5.3 簡単に言えば、Luaは、Aeとユーザーの間の架け橋であり、コミュニケーション通路の役を果たしています。LuaはAeスクリプト言語に似ているため、プログラミング経験ゼロの人でもPixelsWorldを楽しめます。また、小行数のスクリプトでもバラエティー満ちたシーンを構築可能です。例えば、Aeカメラでキューブをレンダーするには、次のコードを書けば十分です： DrawCube.lua version3() move(width/2,height/2) dim3() cube(300) dim3()は三次元モードでレンダーするという意味です。 GLSLコードをレンダーするには、次のように書きます： RunGlsl.lua version3() glsl([==[ void main(){ vec3 col = 0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4)); outColor = vec4(col,1.0); } ]==]) shadertoyのコードをレンダーするには、次のように書きます： RunShadertoy.lua version3() pw.shadertoy([==[ void mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec2 uv = fragCoord/iResolution.xy; vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)); fragColor = vec4(col,1.0); } ]==]) Luaでは、次のことができます： ピクセルデータの読み取り ピクセルデータの書き込み JavaScriptの実行 GLSLの実行 パラメーターの読み取り 外部Cライブラリの実行 (COOL!) 外部Luaモデルの読み取り "},"contents/Lua/RunLua.html":{"url":"contents/Lua/RunLua.html","title":"Luaの実装","keywords":"","body":"Luaの実装 まず、Lua ( CPU & GPU )　モードに切り替えてください。 次のコードをエディターに入力してください。 hello.lua version3() a = 5+6 b = \"PixelsWorld\" c = \"is cool!\" d = time e = slider(0) f = \"5 + 6 = \" .. a .. \"\\nMessage : \" .. b .. \" \" .. c .. \"\\nCurrent time is : \" .. d .. \" (s)\\nValue of slider0 is : \" .. e print(f) a..b は文字列aとbを連結する操作です。 print()：文字列を出力する関数 slider()：スライダーの値を読み取る関数 Lua言語では;を行の最後につけることが可能ですが、必須ではありません。 結果として、画面の左上に文字が出力されます。 "},"contents/Lua/WriteLocalCode.html":{"url":"contents/Lua/WriteLocalCode.html","title":"ローカルコード","keywords":"","body":"ローカルコードの読み取り PixelsWorldは、txt形式のファイルを読み取れる為、ローカルでユーザーが好きなエディターでコードを書くことが可能です。 システムディスク（通常C:\\）でないほかのディスクでtxtファイルを作成してください。 loadTxt.lua version3() runFile([[d:\\mycode.txt]]) -- Replace to your path ここで、\"d:\\mycode.txt\"ではなく、[[d:\\mycode.txt]]を使う理由は\\が制御文字として扱われることを避けるからです。 実際、仕様がテキストファイルでさえあれば、拡張子は任意です(*.lua, *.code, *.magic)。 次のコードを使ってAeプロジェクトファイル周辺に置かれているコードファイルを読み取れます。 loadTxt.lua version3() runFile( projectFolder .. [[mycode.txt]]) -- Replace to your file name 注意：projectFolderを使うには、Aeプロジェクトの保存が必須です。さもなければ、projectFolderは空文字列になってしまいます。 まだおわってない！ ローカルでファイルの書き込みが終わって保存しても、PixelsWorldは直ぐにコードをシーンに反映できません。PixelsWorldにコードをロードさせるために、Ctrl + Altを押しながら、プラグインパネルにあるロゴ画像をクリックしてください。これでPixelsWorldはローカルファイルを読み取ってくれます。 コレクション好きなお客様のために、高確率でよく出てくるロゴ画像もありながら、ウルトラ激レアの画像も用意してあります。 "},"contents/Lua/importantFuncs.html":{"url":"contents/Lua/importantFuncs.html","title":"一番重要な関数たち","keywords":"","body":"一番重要な関数たち ここで、いくつか一番使われている関数を列挙し、それらを紹介します。 初期値コード default_code.lua version3() in2out() move(width/2,height/2) version3() は、一番最初に呼ぶべき関数です。これはpw3.テーブルにあるすべての関数をグローバル関数にする役割を果たしています（C++のusing namespace pw3の如く）。 function must be called in the first line. It put all functions that in the table pw3 to the global field. If you don't call it, you need to add a pw3. prefix to all the function provided by PixelsWorld. For instance, the following demonstrated function print() should be pw3.print(). On the contrary, If you call the function version3() in the first line, the pw3. prefix could be omitted. This function is designed for backward compatibility. We recommend calling version3() in the first line any time you use Lua render mode. in2out() copys the input image to the output. If you don't need input image but a pure color backgroud instead, call background(r,g,b,a)(RGBA range: 0~1). If you want your background to be empty, remove the in2out() function. move(x,y) moves the Paintbrush along vector (x,y). The default location of Paintbrush is (0,0), hence move(width/2,height/2) means move the Paintbrush to the middle of your scene. Remove this function if you don't need this moving. "},"contents/Lua/LinkParameters.html":{"url":"contents/Lua/LinkParameters.html","title":"パラメータリンク","keywords":"","body":"Link parameters parameters.lua slider(id) -- return 1 double angle(id) -- return 1 double point(id) -- return 2 double point3d(id) -- return 3 double checkbox(id) -- return 1 boolean color(id) -- return 3 double layer(id,x,y) -- return 4 double If there are more than one values returned, the corresponding number of variables need be declared to catch the values. For instance, the point() function: point.lua version3() x,y = point(0) -- Declear two variables x and y println('x is ' .. x) println('y is ' .. y) "},"contents/Lua/globals.html":{"url":"contents/Lua/globals.html","title":"グローバル変数","keywords":"","body":"Globals Global constants Here are some global constants in PixelsWorld: const.lua PI -- the Circular constant pi TPI -- two pi HPI -- half pi QPI -- quarter pi E -- the Natural number e PHI -- the Golden ratio phi R2 -- square root 2 R3 -- square root 3 R5 -- square root 5 R7 -- square root 7 INPUT -- Index of input image -1 TEMP -- Index of temp image -2 OUTPUT -- Index of output image -3 PARAM0 -- Index of the #0 layer parameter 0 PARAM1 -- Index of the #1 layer parameter 1 PARAM2 -- Index of the #2 layer parameter 2 PARAM3 -- Index of the #3 layer parameter 3 PARAM4 -- Index of the #4 layer parameter 4 PARAM5 -- Index of the #5 layer parameter 5 PARAM6 -- Index of the #6 layer parameter 6 PARAM7 -- Index of the #7 layer parameter 7 PARAM8 -- Index of the #8 layer parameter 8 PARAM9 -- Index of the #9 layer parameter 9 platform -- Windows == 0, no other platforms. host -- Ae == 0, no other hosts. Global variables Here are some global variables in PixelsWorld: globalvars.lua depth -- Dpc: 8,16,32 width -- Width input image height -- Height input image time -- Current time(s) duration -- Duration of current layer(s) inpoint -- Inpoint of current layer(s) compTime -- Comp current time(s) pluginFolder -- The plugin folder(utf8) projectName -- Project name(utf8) projectPath -- Project path(utf8) projectFolder -- Project folder(utf8) ds_width -- Width of downsampled input image ds_height -- Height of downsampled input image origin_x -- The X coordinate of left top corner of input image in the layer coordinate. origin_y -- The Y coordinate of left top corner of input image in the layer coordinate. Print the globals Globals can be printed by using following code: printGlobals.lua version3() in2out() for k, v in pairs(_G) do print(k) print(\" \" .. type(v) , .5,.5,.5) print(\" \".. tostring(_G[k]),0,1,1) println(\"\") end "},"contents/Lua/FuncList.html":{"url":"contents/Lua/FuncList.html","title":"関数一覧表","keywords":"","body":"Function List This page covers all functions provided in Lua render mode. Required functions version3 Parameter link functions slider, angle, point, point3d, checkbox, color, layer Print message functions print, println, alert Transform functions move, scale, rotate, rotateX, rotateY, rotateZ, twirl beginGroup, endGroup, beginGlobal, endGlobal global2local, local2global, global2screen, screen2global getTransformMatrix Draw functions Primitives tri, quad, rect, circle, ellipse, par, line cube, tet, cone, ball, tube image, coord, grid poly, setPoly background, in2out Attribute controls dim2, dim3 perspective, noPerspective fill, noFill, stroke, noStroke, dot, noDot wireframe, noWireframe blendAlpha, noBlendAlpha back, noBack pure, phong, anime rgba, depth, normal setDepth Lights ambientLight, pointLight, parallelLight clearLight, getLight Camera function aeCamera, lookAt, viewSpace Stroke details strokeWidth, strokeDivision, strokeGlobal, strokeLocal Dot details dotRadius, dotDivision, dotGlobal, dotLocal Output details smooth, noSmooth Utility tools r2d, d2r map utf8ToLocal, localToUtf8 getGLInfo, getDrawRecord, getStatus getAudio Read/Write pixels functions getColor, setColor, getSize, Run code functions shadertoy, glsl, cmd, lua, runFile, txt Detailed descriptions version3 version3() function must be called in the first line. It put all functions that in the table pw3 to the global field. If you don't call it, you need to add a pw3. prefix to all the function provided by PixelsWorld. For instance, the following demonstrated function print() should be pw3.print(). On the contrary, If you call the function version3() in the first line, the pw3. prefix could be omitted. This function is designed for backward compatibility. We recommend calling version3() in the first line any time you use Lua render mode. version3.lua version3() println(\"Hello PixelsWorld! \") without_version3.lua pw3.println(\"Hello PixelsWorld! \") print print(str),print(str,brightness),print(str,r,g,b),print(str,r,g,b,a) prints message to the left top corner of your scene. print.lua version3() print(\"Hello PixelsWorld! \") str = \"Hello, I am colorful PixelsWorld! \" for i=1,#str do local c = str:sub(i,i) local phase = math.sin(i/#str*TPI + time*10) / 2 + .5 print(c,phase,1-phase,1,1) end println println(str),println(str,brightness),println(str,r,g,b),println(str,r,g,b,a) prints message to the left top corner of your scene, this function adds \\n in the end of input string. println.lua version3() println(\"Hello PixelsWorld! \") str = \"Hello, I am colorful PixelsWorld! \" for i=1,#str do local c = str:sub(i,i) local phase = math.sin(i/#str*TPI + time*10) / 2 + .5 -- println(c,phase,1-phase,1,1) print(c,phase,1-phase,1,1) end alert alert(str) prints caution message, equals to println(str,1,1,0,1) alert.lua version3() alert(\"Warning: Write your message here! \") move move(x,y),move(x,y,z)moves Paintbrush. All transforms are done basing on the Paintbrush coordinate. Example: move.md version3() coord() -- show Paintbrush coordinate move(100,0) coord() -- show Paintbrush coordinate move(0,100) coord() -- show Paintbrush coordinate Finally, the Paintbrush is located at (100,100,0). scale scale(ratio),scale(x,y),scale(x,y,z)scales the Paintbrush coordinate. All transforms are done basing on the Paintbrush coordinate. rotate rotateX rotateY rotateZ rotate(theta)rotates Paintbrush with theta radians. rotateX(theta) rotates Paintbrush along X axis. rotate(theta) equals to rotateZ(theta). All transforms are done basing on the Paintbrush coordinate. If you are not familiar with radians, use d2r(degree) to convert a degree to a radian. For example：rotate(d2r(90)) means rotate 90 degrees. twirl twirl(theta,x,y,z) rotates Paintbrush along (x,y,z) axis with theta radians. For example, above-mentioned rotateX(theta) equals to twirl(theta,1,0,0). All transforms are done basing on the Paintbrush coordinate. twirl is an matrix implementation of quaternion rotation. beginGroup endGroup beginGroup(),endGroup() creates a children transformation group. Transformations(move,scale,rotate,twirl) between beginGroup() and endGroup() will be canceled after calling endGroup(). beginGroup(mat) pushes mat as a children transformation group (Use getTransformMatrix to get the transform matrix). It equals to pushMatrix() and popMatrix() in Processing. Example: The following two code are equivalent. group.lua version3() for i = 1,10 do beginGroup() move(i*100,i*100) rotate(d2r(45*i)) rect(50) endGroup() end without_group.lua version3() for i = 1,10 do move(i*100,i*100) rotate(d2r(45*i)) rect(50) rotate(d2r(-45*i)) move(-i*100,-i*100) end beginGlobal endGlobal Draw functions between beginGlobal and endGlobal will draw shapes in global coordinates. beginGlobal.lua version3() move(100,100) fill(0,1,0) -- green rect(50) -- Dran on (100,100,0) beginGlobal() fill(1,0,0) -- red rect(50) -- Draw on (0,0,0) endGlobal() move(100,100) fill(0,0,1) -- blue rect(50) -- Draw on (200,200,0) global2local global2local(x,y,z) converts a global point to a local point. Returns 3 doubles. local2global local2global(x,y,z) converts a local point to a global point. Returns 3 doubles. global2screen global2screen(x,y,z) converts a global point to a screen point. Returns 3 doubles. The result is affected by perspective mode. screen2global screen2global(x,y,z) converts a screen point to a global point. Returns 3 doubles. The result is affected by perspective mode. getTransformMatrix getTransformMatrix() returns a column major 4x4 transform matrix. mat[i][j] returns the entry in ith column jth row. (i,jrange: 1~4) matrix.lua version3() dim3() beginGroup() move(width/3,height/3) twirl(QPI*time,1,1,1) cubetransform = getTransformMatrix() endGroup() beginGroup(cubetransform) cube() endGroup() tri tri(radius) draws a regular triangle with radius radius, and the triangle will point to the positive direction of Y axis. tri() equals to tri(100) tri(w,h)draws a triangle with base length w and height h. tri(p1x,p1y,p2x,p2y,p3x,p3y) draws a triangle basing on 3 points p1,p2,p3. tri(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z) draws a triangle basing on 3 points p1,p2,p3. Add dim3() after version3(), and add a camera layer to your Ae comp to view the 3D triangle. The first 3 functions set normals to (0,0,-1) basing on the current Paintbrush coordinate. The last 2 functions calculate normals with formula: cross(p1-p2,p3-p2). tri is an abbreviation of triangle tri1.lua version3() move(width/2,height/2) tri(100) tri5.lua version3() dim3() move(width/2,height/2) tri(0,0,100,50,0,0,0,50,0) quad quad(p1x,p1y,p2x,p2y,p3x,p3y,p4x,p4y) quad(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z,p4x,p4y,p4z) Draws 2 triangles with order: p1,p2,p3,then p1,p3,p4. rect rect(size) draws a square with size. rect() equals to rect(100) rect(width,height) draws a rectangle with width width and height height. The intersection point of rectangle is at the origin of Paintbrush coordinate. rect is an abbreviation of rectangle. circle circle(radius) draws a circle with radius radius. circle() equals to circle(100) circle(radius, div) draws a circle with radius radius, and subdivision div. Default subdivision: 128 ellipse ellipse(radiusx,radiusy)draws an ellipse with x radiusradiusx, y radius radiusy. ellipse() equals to ellipse(100,100) ellipse(radiusx,radiusy,div) draws an ellipse with x radiusradiusx, y radius radiusy and subdivision div. Default subdivision: 128 line line(p1x,p1y,p2x,p2y) draws a line. line(p1x,p1y,p1z,p2x,p2y,p2z) draws a 3d line. line() equals to line(0,0,0,100,100,100) Use stroke(r,g,b) to change the color. UsestrokeWidth(width) to change the width. Use noStroke() to turn off line render, stroke() to turn on line render. par par(x) draws a point at(x,0,0). par(x,y) draws a point at(x,y,0). par(x,y,z) draws a point at(x,y,z). par() equals to par(0,0,0) By default, the point render is turned off, use dot() to turn it on. You can call noDot() to turn it off again. dotRadius(radius) controls point radius. dot(r,g,b) controls point color. dotGlobal() makes point be avoid to be squeezed by scale. By default, points are rendered with dotLocal(). cube cube(size) draws a cube with size size cube(sizex,sizey,sizez) draws a cuboid with dimension sizex,sizey,sizez. cube() equals to cube(100) cube() Negative inputs or negative scale() would cause wrong normals. tet tet(radius) draws a regular tetrahedron with radius radius. tet() equals to tet(50) tet(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z,p4x,p4y,p4z) draws tetrahedron basing on 4 points p1,p2,p3,p4. The 3rd function generates normals basing on tri function and calls it with the following points order: p1,p2,p3; p2,p1,p4; p3,p2,p4; p1,p3,p4.. See also: tri. tet is an abbreviation of tetrahedron. cone cone(size) draws a cone with base circle radius size and height 2*size. cone() equals to cone(50). cone(radius,height) draws a cone with base circle radius radius and height height. cone(radius,height,div) draws a cone with base circle radius radius, height height and subdivision div. Default subdivision: 64 If sub is greater than 16, the side stroke and base point will be hidden. Negative inputs or negative scale() would cause wrong normals. ball ball(radius) draws a sphere with radius radius. ball() equals to ball(50). ball(radius,level) draw a ball with radius radius and subdivision level level. Default subdivision level 4. level must be non-negative. level 0 generates a regular octahedron. If level is greater than 2, the strokes and points will be hidden. Negative inputs or negative scale() would cause wrong normals. tube tube(size) draws a tube with base circle radius size and height 2*size. tube() equals to tube(50) tube(radius,height)draws a tube with base circle radius radius and height height. tube(radius1,radius2,height) draws a tube with close base circle radius radius1, far base circle radius radius2 and height height. tube(radius1,radius2,height,div) can change the subdivision. tube(radius1,radius2,height,div,needMesh) can change render 2 base circles or not. tube(radius1,radius2,height,div,needMesh1,needMesh2) can change render 2 base circles or not separately. Default div: 64. needMesh is true by default. If div is greater than 16, the side strokes and the base points will be hidden. Negative inputs or negative scale() would cause wrong normals. image image(id,width,height) draws an image with width width and height height. id is texture id,PARAM0~PARAM9means texture load from the layer parameters, INPUT means input image, OUTPUT means output image. If id is OUTPUT, it will be slow because we need to take a screenshot of your scene. The difference with in2out(id) is, image(id,width,height) draws a rectangle with a texture, which could interact with the depth buffers, where in2out(id) just copy pixels from one texture to another. This is also means the image that is drawn to the screen is inversed by default (The default coordinate system of Ae is Y axis downward), so you may need rotateX(PI) to fix it. (And we don't recommend calling scale(1,-1), which may cause wrong normals problem. Example: render_image.lua version3() dim3() move(width/2,height/2) beginGroup() rotateX(PI) image(INPUT,width,height) endGroup() rotateX(QPI * time) rotateY(QPI * time) cube() coord coord() draws the current Paintbrush coordinate. grid grid() draws a grid with many 100x100px squares. setPoly setPoly(obj) analyzes obj only, use poly() to draw the previous set obj to scene. It will be efficient in the case you draw a same obj for many times. See also Poly background background(brightness),background(r,g,b),background(r,g,b,a) draws a pure color rectangle to scene. Notes: This function overrides all shapes you drew before. in2out in2out(id) set the id texture to the scene. in2out() equals to in2out(INPUT) id range: PARAM0~PARAM9 or INPUT. dim2 dim2() set the scene to 2D mode. 2D mode is on by default, you usually no need to call it. In PixelsWorld, 2D scene means a 3D scene without depth test and perspective. dim3 dim3() set the scene to 3D mode. Call it immediately after version3(). Note: Use viewSpace to change the far plane dimension if your layer size is not equal to the comp size. Otherwise, the shapes in 3D mode will be rendered to an unexprected position. perspective perspective() set the scene to perspective mode, everything looks small in the distance and big on the contrary. Use viewSpace to change the camera information. Use lookAt to set the location of the camera. Perspective mode is on by default after calling dim3(). noPerspective noPerspective() set the scene to orthogonal mode. fill fill() turns on fill mode. fill(brightness),fill(r,g,b),fill(r,g,b,a) turns on fill mode and set fill color. Note: If you set Alpha smaller than 1, render far object first, or you will get wrong render results due to the depth test. (This is a feature of OpenGL render) noFill noFill() turns off the fill mode. stroke stroke() turns on the stroke mode. stroke(brightness),stroke(r,g,b),stroke(r,g,b,a) turns on stroke mode and set the stroke color. noStroke noStroke() turns off stroke mode. dot dot() turns on the dot mode. dot(brightness),dot(r,g,b),dot(r,g,b,a) turns on the dot mode and set the dot color. noDot noDot() turns off the dot mode. wireframe wireframe() turns on the wireframe mode. noWireframe noWireframe() turns off the wireframe mode. blendAlpha blendAlpha() turns on the alpha blending. noBlendAlpha noBlendAlpha turns off the alpha blending. back back() If the fill alpha is smaller than 1, back mode shows the back side of an obj. Off by default. noBack noBack() turn off back mode. pure pure() use pure color to render. On by default. anime, phong, pure are 3 dependent mode, turn on one may turn off the other two. phong phong(ambient,diffuse,specular,specularPower) turns on the phong render mode, and set the ambient strength to ambient, diffuse strength to diffuse, specular strength to specular, specular damping power to specularPower. phong() only turn on the phong render mode, it doesn't change the configs. By default, there is no light in the scene, call getLight(), ambientLight(), parallelLight(), pointLight to add lights. If you are sure there are lights in your scene but the obj is black, call normal to check if the normal is right. Default settings: ambient:1,diffuse:1,specular:1,specularPower:1. anime, phong, pure are 3 dependent mode, turn on one may turn off the other two. Call dim3() before calling this function. anime anime(ambient,diffuse,specular,specularPower,diffuseThreshold,specularThreshold) anime() turns on the anime render mode. anime render mode is based on phong, hence the first 4 arguments ambient,diffuse,specular,specularPower are same with phong render mode. diffuseThreshold configs the diffusion threshold, if diffuse lightnees in a pixel is bigger than threshold, it will be white. Otherwise it will be dark. specularThreshold is threshold of specular. The anime render mode smooth the light-dark border when you turn on the smooth settings in plugin panel. Default settings: ambient:1,diffuse:1,specular:1,specularPower:1,diffuseThreshold:0.5,specularThreshold:0.8 anime, phong, pure are 3 dependent mode, turn on one may turn off the other two. Call dim3() before calling this function. rgba rgba()RGBA output mode, on by default. rgba, depth, normal are 3 dependent mode, turn on one may turn off the other two. You can use phong(),anime() in this output mode. depth depth(blackDistance, whiteDistance) depth output mode. Set pixels at distance blackDistance to black, pixels at distance whiteDistance to white. If they are same, PixelsWorld set the pixels that nearer than the value you set to black, otherwise white. rgba, depth, normal are 3 dependent mode, turn on one may turn off the other two. phong(),anime() will be ignored in this output mode. Call dim3() before calling this function. normal normal(faceToCamera, normalize) turns the normal output mode on, and configs faceToCamera and normalize. normal(faceToCamera) turns the normal output mode on, and configs faceToCamera. normal() only turns the normal output mode on. faceToCamera is a boolean, true means the normals are calculated basing on camera location. false means the normals are calculated basing on the global coordinate. normalize is a boolean. Default settings: faceToCamera:true, normalize:true. rgba, depth, normal are 3 dependent mode, turn on one may turn off the other two. phong(),anime() will be ignored in this output mode. Call dim3() before calling this function. setDepth setDepth(id,blackDistance,whiteDistance) reads the red channel of texture id, maps color basing on blackDistance,whiteDistance to the depth test buffer in the scene. The depth sequence from other 3DCG softwares can be loaded into PixelsWorld through this function. Namely the shapes can interact with the color sequence rendered from other 3DCG softwares. Call dim3() before calling this function. Valid texture id: INPUT,PARAM0~PARAM9 ambientLight ambientLight(r,b,g,intensity) ambientLight() equals to ambientLight(1,1,1,1) ambientLight(brightness) equals to ambientLight(brightness,brightness,brightness,1) ambientLight(brightness,intensity) equals to ambientLight(brightness,brightness,brightness,intensity) ambientLight(r,g,b) equals to ambientLight(r,b,g,1) Adds a ambient light to the scene. Valid to all objs. Objs are lit up by this kind of lights even if they has wrong normals. pointLight pointLight(r,g,b,intensity,radius,smoothWidth) pointLight() equals to pointLight(1,1,1,1,1000,1000) pointLight(brightness,intensity) equals to pointLight(brightness,brightness,brightness,intensity,1000,1000) pointLight(r,g,b) equals to pointLight(r,g,b,1,1000,1000) pointLight(r,g,b,intensity) equals to pointLight(r,g,b,intensity,1000,1000) pointLight(r,g,b,intensity,radiusAndSmoothWidth) equals to pointLight(r,g,b,intensity,radiusAndSmoothWidth,radiusAndSmoothWidth) Adds a point light in the current Paintbrush coordinate. This light is affected by objs' normals. The specular and diffuse will be failed if the normals are inward, but the ambient brightness of point light still lights up the objs. radius is range radius of point light. Range from radius to radius+smoothWidth, the brightness damps. parallelLight parallelLight(r,g,b,intensity,tx,ty,tz) Adds a parallel light with direction vector (tx,ty,tz). clearLight clearLight() removes all lights in the scene. getLight getLight(matchName) getLight() equals to getLight(\"*\") Gets lights that match the name matchName. matchName rules：If matchName doesn't end up with character \"*\", it searches one Ae lights that its name is matchName, otherwise, it includes all Ae lights that begin with matchName. Supported Ae lights: ambient,point,parallel aeCamera aeCamera() sets the Ae activated camera to the scene camera of PixelsWorld. lookAt lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ,upVecX,upVecY,upVecZ) sets the location and orientation of the current scene camera. lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ) equals to lookAt(eyePosX,eyePosY,eyePosZ,objPosX,objPosY,objPosZ,0,-1,0) eyePos is the location of your eyes, objPos is the location of the object you are looking at,upVec the direction your top of head pointing to. Note: Y axis in Ae is downward by default, usually set the upVec to (0,-1,0) is enough. eyePos and objPos cannot be too close. (should be bigger than 1e-7). upVec cannot be parallel to your sight. The length of upVec cannot be too small. viewSpace viewSpace(width,height,distanceToPlane,farLevel) viewSpace(width,height,distanceToPlane) equals to viewSpace(width,height,distanceToPlane,4) width and height is the dimension of the far plane. The perpendicular distance from camera to camera far plane is distanceToPlane farLevel * distanceToPlane is the clip plane distance. Objs that farther than this distance will be clipped out. Normally it is enough to left the farLevel 4, set it to higher number if your scene is pretty vast. Note that if the farLevel is too high, the depth test precision of near objs may decline. strokeWidth strokeWidth(width) Default: 2 strokeDivision strokeDivision(level) Default: 3 strokeGlobal strokeGlobal() draw lines globally. Lines will no longer be squeezed by scale function. Default: local strokeLocal strokeLocal() draw lines locally. Lines will be squeezed by scale function. Default: local dotRadius dotRadius(radius) Default: 2 dotDivision dotDivision(level) Default: 3 Maximum: 7 dotGlobal dotGlobal() Draw points globally. Points will no longer be squeezed by scale function. Default: local dotLocal dotLocal() Draw points locally. Points will be squeezed by scale function. Default: local smooth smooth() Smooth render mode. Default: on The smooth strength can be changed in plugin panel. noSmooth noSmooth() Pixel art render mode. The priority of this function is higher than settings in plugin panel. r2d r2d(degrees) radians to degrees, return degrees. d2r d2r(radians) degrees to radians, return radians map map(value,in1,in2,out1,out2) maps value value from range in1~in2 to range out1~out2. If in1 equals to in2, if value this function returns out1, otherwise out2. utf8ToLocal utf8ToLocal(str) unicode string to local string. Call this function to translate paths while you are handling Lua's io module. localToUtf8 localToUtf8(str)local string to unicode string getGLInfo getGLInfo() gets the information of the current graphic card. getDrawRecord getDrawRecord(needStringFormat) gets current draw records. needStringFormat is a boolean, when true, returns a string, otherwise, returns a Lua table. getDrawRecord() equals to getDrawRecord(true) printDrawRecord.lua version3() move(width/2,height/2) dim3() cube() println(getDrawRecord()); getStatus getStatus(needStringFormat)gets the current Paintbrush status. needStringFormat is a boolean, when true, returns a string, otherwise, returns a Lua table. getStatus() equals to getStatus(true) getStatus.lua version3() move(width/2,height/2) dim3() cube() println(getStatus()); getAudio getAudio(startTime,duration,id,sampleRate) gets the audio samples. Returns 4 tables. The first 2 are wave sample tables(Left and Right), the last 2 are spectrum sample tables(Left and Right). getAudio(startTime,duration) equals to getAudio(startTime,duration,INPUT,44100) getAudio(startTime,duration,id) equals to getAudio(startTime,duration,id,44100) Left wave sample range: (-1~1) Right wave sample range: (-1~1) Left spectrum sample range: (0~infinity) Right spectrum sample range: (0~infinity) waveInfo.lua version3() background(0.2) local wl,wr,fl,fr = getAudio(time-0.1,0.2) local nm = math.floor(height/8); for i=1,nm do local wid =math.max(math.floor(i/nm*#wl),1) local fid = math.max(math.floor(i/nm*#fl/16),1) print(string.format(\"%8.5f\",wl[wid]),wl[wid]*4,0,-wl[wid]*4) print(\" \",0,0,0) print(string.format(\"%8.5f\",wr[wid]),wr[wid]*4,0,-wr[wid]*4) print(\" \",0.5,0.5,0.5) print(string.format(\"%8.5f\",fl[fid]),fl[fid]/math.sqrt(#fl),0,0) print(\" \",0,0,0) print(string.format(\"%8.5f\",fr[fid]),0,0,fr[fid]/math.sqrt(#fr)) println(\"\"); end getColor getColor(id,x,y) get pixel color at location (x,y) of texture id. Returns r,g,b,a 4 doubles. getColor(x,y) equals to getColor(INPUT,x,y) It is high efficient to call getColor before any draw function(Such as immediately after version3()). Otherwise, it is very low efficient since it queries pixels from the graphic card. Valid id: INPUT,OUTPUT,PARAM0~PARAM9 setColor setColor(x,y,r,g,b,a) set the pixel at location (x,y) of texture OUTPUT. It is high efficient to call setColor before any draw function getSize getSize(id) returns the size of texture id. (Two doubles, width and height) Due to the Ae's downsample (1/2,1/4) mechanism, the size you get would variating 0~4px. But this kind of variating doesn't change with time. The size is promised to be accurate in full resolution(without downsample). shadertoy shadertoy(code) runs code from shadertoy.com. Not all code on shadertoy.com is supported. glsl glsl(code) runs fragment stage shader code. cmd cmd(code) runs cmd code. This function is equivalent to the ISO C function system. It passes command to be executed by an operating system shell. Its first result is true if the command terminated successfully, or nil otherwise. After this first result the function returns a string plus a number, as follows: \"exit\": the command terminated normally; the following number is the exit status of the command. \"signal\": the command was terminated by a signal; the following number is the signal that terminated the command.lua lua(code) runs lua code. runFile runFile(utf8_path) loads local lua code and run. No need to call utf8ToLocal since it supports utf8. txt txt(utf8_path) loads local text file. Returns string. No need to call utf8ToLocal since it supports utf8. "},"contents/Lua/Poly.html":{"url":"contents/Lua/Poly.html","title":"Poly関数","keywords":"","body":"Creation origin: Poly function poly(obj) analyzes the input Obj, then draws it to scene. Usage If you are familiar with Houdini, the idea of construct an obj is basically to fill a SpreadSheet. Here is an example of constructing an obj of an unusual colorful triangle. PolyTest1.lua version3() background(0.95) move(width/2,height/2) dim3() dotRadius(5) obj={ point={ {p={0,0,0},color={0,1,1}}, {p={100,0,0},color={1,1,0}}, {p={0,100,0},color={1,0,1}}, {p={100,100,0},color={1,0,0}}, }, prim={ {type=\"triangle\",pref={1,2,3}}, {type=\"line\",pref={2,3,3,4,4,2}}, {type=\"point\",pref={2,4}}, } } poly(obj) Supporting primitives Assumepref={1,2,3,4,5,6}. pref means point reference. The semicolon (;) is the end mark of one primitive drawing. type name Corresponding primitive Drawing order full type name points Points 1;2;3;4;5;6; points pointd 2d point 1;2;3;4;5;6; point disc pointb 3d point 1;2;3;4;5;6; point ball line Single line 123456; single line linef Single 2d line 123456; line flat linec Single 3d line 123456; line capsule linel Loop line 1234561; line loop linelf Loop 2d line 1234561; line loop flat linelc Loop 3d line 1234561; line loop capsule lines Lines 12;34;56; lines linesf 2d lines 12;34;56; lines flat linesc 3d lines 12;34;56; lines capsule triangles Triangle meshes 123;456; triangles triangleb Bridge structure triangle meshes 123;324;345;546; triangle bridge triangler Radial structure triangle meshes 123;134;145;156; triangle radial The structure of obj The obj struction is defined by following steps: obj is a table. obj contains 4 keys: point,vertex,prim,detail. The 4 keys in obj have their own value called pointArray,vertexArray,primArray,detailList. pointArray is required. vertexArray is optional. primArray is required. detailList is optional. The above-mentioned value names that are Array suffixed holds N sub-tables, where N can be defined by users. The kth sub-table of pointArray is called point[k] or \"The kth point\". The kth sub-table of vertexArray is called vertex[k] or \"The kth child-point\". The kth sub-table of primArray is called prim[k] or \"The kth primitive\". The detailList and Points, child-points, primitives, has some unsubdividable units：the Key-value pairs. We call these keys K, and values V. K should only contains alphabets, numbers and underlines. And K shouldn't be all numbers. V has 7 types: 1D, 2D, 3D, 4D, string, texture id and index serial. For all double floating numbers x,y,z,w x or {x} is 1D V. {x,y} is 2D V. {x,y,z} is 3D V. {x,y,z,w} is 4D V. \"Hello! PixelsWorld!\" is string V. When (K ends up with \"_tex\") and (V is integer and the corresponding texture exists), it is texture id V. For integer serial a1,...,an,{a1,a2,a3,...,an} is index serial V. For all point[k], there must be a K named \"p\" to represents the location, or it is a invalid point. For all vertex[k], there must be a K named \"pref\" and its V is integer to represent the reference point id, or it is an invalid child-point. For all prim[k], there must be a K named \"type\" and its V is string to represents the type of the primitive. And there also must be a K named \"vref\"or \"pref\" and its V is index serial to represent the order of points drawing. Override priority For same K, the following override priority is defined: Same with Houdini. vertex point prim detail Example: The following obj's prim contains color attribute (Red), So we will get a red triangle. PrimColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0}}, {p={100,0,0}}, {p={0,100,0}}, }, prim={ {type=\"triangle\",pref={1,2,3},color={1,0,0}}, }, } poly(obj) This time, both prim and point contains color, and because the priority of point is higher, so the color attribute in pointwill be used, then we will get a colorful triangle. PointColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},color={0,1,1}}, {p={100,0,0},color={1,1,0}}, {p={0,100,0},color={1,0,1}}, }, prim={ {type=\"triangle\",pref={1,2,3},color={1,0,0}}, }, } poly(obj) Usage of vertex Vertex (child-point) inherits all attributes in point. VertexColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0}}, {p={100,0,0}}, {p={0,100,0}}, {p={100,100,0}}, }, vertex={ {pref=1,color={1,0,0}}, {pref=2,color={1,0,0}}, {pref=3,color={1,0,0}}, {pref=2,color={0,1,0}}, {pref=3,color={0,1,0}}, {pref=4,color={0,1,0}}, }, prim={ {type=\"triangle\",vref={1,2,3,4,5,6}}, }, } poly(obj) pref is used to defined which point to be referenced, the full name of pref is Point reference. So the vref means Vertex reference. Note: The index in Lua starts from 1 not 0. Without vertex, the triangle looks like this: NoVertex.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},color={1,0,0}}, {p={100,0,0},color={1,0,0}}, {p={0,100,0},color={1,0,0}}, {p={100,100,0},color={0,1,0}}, }, prim={ {type=\"triangle\",pref={1,2,3,2,3,4}}, }, } poly(obj) Extra shader Yes! You can even write shader in an obj. FragColor.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},myattribute={1,0}}, {p={100,0,0},myattribute={0,1}}, {p={0,100,0},myattribute={0,0}}, {p={100,100,0},myattribute={1,1}}, }, prim={ { type=\"triangle\", pref={1,2,3,2,3,4}, frag=[==[ #define t ]==] .. tostring(time) .. [==[ void main(){ outColor = vec4(mod(myattribute*10+vec2(t),1),0,1); } ]==], }, }, } poly(obj) Use UV texture Here is an example of how to use uv texture. The integer that its key name ends up with _tex is treated as a texture id. Using an extra shader in a prim can handle more than one textures. UVTex.lua version3() background(0.95) move(width/2,height/2) dim3() obj={ point={ {p={0,0,0},uv={0,0}}, {p={100,0,0},uv={1,0}}, {p={0,100,0},uv={0,1}}, {p={100,100,0},uv={1,1}}, }, prim={ { type=\"triangler\", pref={1,2,4,3}, my_tex=INPUT, }, }, } poly(obj) "},"contents/Lua/TransparencyRender.html":{"url":"contents/Lua/TransparencyRender.html","title":"透明オブジェレンダー法","keywords":"","body":"Render transparent objects Normally, we get the following result when we are about to render a stack of transparent cubes. normalCubes.lua version3() in2out() dim3() fill(1,.5) move(width/2, height/2) for i = 1,10 do move(20,0,200) cube() end The result was wrong, because we cannot see the behind cubes. We should adjust the render order (farthest to nearest) basing on the camera distance to obtain the right blending color. sortCubes.lua version3() in2out() dim3() fill(1,.5) sortarr = {} beginGroup() move(width/2, height/2) for i = 1,10 do move(20,0,200) local x,y,z = global2screen(local2global(0,0,0)) -- Get camera distance sortarr[i] = {z,getTransformMatrix()} -- {distance, transform status} pairs end endGroup() table.sort(sortarr,function(a,b) -- Sort by z distance return a[1] > b[1] end) for i = 1,10 do beginGroup(sortarr[i][2]) -- Apply transform status cube() endGroup() end "},"contents/Lua/RunGLSL.html":{"url":"contents/Lua/RunGLSL.html","title":"LuaでGLSLを実行する","keywords":"","body":"Run GLSL in Lua Usage glsl.lua version3() glsl(Your_code_string_here) Note: We recommend using [==[Your_code_string_here]==] to quote your string on account of avoiding escape characters. Namely, your code should be like: glsl2.lua version3() glsl([==[ void main(){ outColor = vec4(uv,sin(time*10)/2+.5,1); } ]==]) The following function can run the code from shadertoy.com. shadertoy.lua version3() shadertoy(Your_shadertoy_code_here) "},"contents/GLSL/GLSLCode.html":{"url":"contents/GLSL/GLSLCode.html","title":"グラフィックスバーサーカーGLSL","keywords":"","body":"GPUバーサーカーGLSL この章では、GLSLの使い方を紹介します。 GLSLとは？ GLSLは「OpenGL Shader Language」の略称です。GPUで実行される言語の一種です。 GPUレンダーのメリットは？ ここで、比喩でCPUをスーパーカー、GPUをバスとしましょう。 もし、少人数（二人ぐらい）の人を運輸しようとすれば、スーパーカーの方は早くていいでしょう。（高速で複雑な演算をします） さて、多人数の場合はどうでしょうか。バスのほうはスピードが遅いが、一気に多数の人を運搬できるというメリットが大きくなって、このケースではバスのほうがかなり有能だと考えてもいいでしょう。（同じ演算を一斉にします） 普通我々の耳にした多くの言語（C/C++、Java、Python）はCPUで実行されています。 GLSLは、GPUで実行できるようにデザインされています。 画像を一枚レンダーしようとするときに、GPUは大勢の「ワーカー」を雇って計算方法と入力値を与えて働かせるというイメージを持ってもいいでしょう。 GLSLを徹底的に勉強したい方に対して、こちらのサイト：shadertoy.comをお勧めします。面白そうなコードを見つけてそれをいじることよりわりと速く上達するので、ぜひご活用ください。 詳細（これ以降の内容はベテラン向けです） GLSLコードがOpenGLに発信される前に、PixelsWorldは、いくつかの前置きコードと後置きコードを連結する処理を行います。 PixelsWorld V3.0.0 は #version 330 core　を使います。 ここで 前置きコードと後置きコードが記載されています。 "},"contents/GLSL/RunGLSL.html":{"url":"contents/GLSL/RunGLSL.html","title":"GLSLの実装","keywords":"","body":"Run GLSL Code Make sure you are in GLSL(GPU) mode; Then edit the World rule; You will see there is already some code in the showed up panel; default.shader void main(){ outColor = getColor(uv); } This code is just send the input pixels to the output. You can change the getColor(uv) to vec4(uv,0.0,1.0) for geting a beautiful uv color pattern; uvcolor.shader void main(){ outColor = vec4(uv,0.0,1.0); } Then, press the \"Ok\" button. If everything is right, you will get something in the scene like this: "},"contents/GLSL/GetStart.html":{"url":"contents/GLSL/GetStart.html","title":"クイックスタート","keywords":"","body":"What it feels like to develop effects with PixelsWorld? PixelsWorld is just like Microsoft Excel. You write function, it will handle the data in the form for you. If we treat the data in form as input pixels, the calculated form as output pixels, Codes in PixelsWorld is the function in Microsoft Excel E.g. Make picture brighter To make a picture brighter, the simplest approach is just add the R,G,B by a number. If in Excel, we need to do something like this: Then we have made all pixels data \"brighter\" ! Here is what we need to write in PixelsWorld: bright_describe.shader outColor=getColor(uv)+vec4(0.2); It means: Get the input pixels (getColor) in current location (uv), and add the 4D vector RGBA by (0.2,0.2,0.2,0.2) (+vec4(0.2)). Finally, send (=) the result to the output pixel(outColor). But if we only write this single line, PixelsWorld cannot work fine. We need to add this line inside a \"shell\" to make it work. The complete version is this: bright.shader void main(){ outColor=getColor(uv)+vec4(0.2); } How to input codes Input picture (Right click to save) (Source artist) Result Add more controls! Mostly we don't just add 0.2 to the picture. We want it to be more controllable. So we can replace the 0.2 to slider[0]. In this way, we can change the value in Parameters panel to change the brightness of your picture. bright_control.shader void main(){ outColor=getColor(uv)+vec4(slider[0]); } But you can find that, if the value is negative, the picture will be transparent, we don't want this happened. Namely we need to avoid modifying the Alpha channel of the picture. bright_control.shader void main(){ vec4 inColor = getColor(uv); inColor.rgb = inColor.rgb + vec3(slider[0]); outColor = inColor; } It means: Save the input pixel into a temporary variable inColor, Add the value of slider[0] to the RGB of inColor, then send the inColor to the outColor. Add label to the parameter Save to preset Finally, we can save the code as a preset for next using. Go to the Preset management to learn more details. Congratulations! You have already mastered the most part of PixelsWorld! In addition to writing codes by yourself, you can go to the shadertoy, find some interesting code and run it in PixelsWorld. See this to learn how to use code from shadertoy. "},"contents/GLSL/Functions.html":{"url":"contents/GLSL/Functions.html","title":"内装関数","keywords":"","body":"Functions This section will give a brief introduction of the functions created by us. The functions mentioned in this section could be immediately used without any declaration. "},"contents/GLSL/getColor.html":{"url":"contents/GLSL/getColor.html","title":"getColor","keywords":"","body":"getColor This function has two versions: getColor(vec2) and getColor(int ,vec2). getColor(vec2) Description : Get the color of inLayer in specified position. Parameters : vec2 : uv position. Return : vec4 : a RGBA color. getColor(int,vec2) Description : Get the color of specified layer in specified position. Parameters : int : layer id, -1 (or AE_INPUT_LAYER) means inLayer, number between 0 and 9 means the corresponding Layer Parameter in your plugin panel. (PW_TEMP_LAYER (which is -2) is provided in Lua render mode) vec2 : uv coordinates. Return : vec4 : a RGBA color. NOTE : So in other words, getColor(AE_INPUT_LAYER,uv); totally equals to getColor(uv); getColor(n,uv); can return the pixels of layer[n]. "},"contents/GLSL/uvxy.html":{"url":"contents/GLSL/uvxy.html","title":"uv2xy,xy2uv","keywords":"","body":"uv2xy,xy2uv This two functions can translate a vec2 between UV Coordinate and XY Coordinate. It just do some multiplication and division for you. uv2xy(vec2) Description : Calculate the xy position for a given uv position. Parameters : vec2 : uv position. Return : vec2 : xy position. NOTE : If your layer size is 1280 x 720. The uv2xy(vec2(0.1,0.5)); will return vec2(128.0,360.0); xy2uv(vec2) Description : Calculate the uv position for a given xy position. Parameters : vec2 : xy position. Return : vec2 : uv position. NOTE : If your layer size is 1920 x 1080. The xy2uv(vec2(192,108)); will return vec2(0.1,0.1); "},"contents/GLSL/LinkParameters.html":{"url":"contents/GLSL/LinkParameters.html","title":"パラメータリンク","keywords":"","body":"Link parameters The outside parameters are provided for you to do some animation. As you can see, there are 7 types of parameters are provided. Sliders Angles Points 3D Points Checkboxes Colors Layers Each of them have 10 controler for using. Example : link_slider.shader void main(){ outColor = vec4(uv,slider[0],1.0); } If you change the slider 0, the color in your scene would change. Details The parameters decleared in PixelsWorld are as below : parameters.shader uniform float slider[10]; uniform float angle[10]; uniform bool checkbox[10]; uniform vec2 point[10]; uniform vec3 point3d[10]; uniform vec4 color[10]; uniform sampler2D layer[10]; uniform sampler2D inLayer; NOTE : The \"inLayer\" means Input layer. The sampler2D is a value type provided by GLSL, you don't need to understand this value type. If you want to use the layer parameter. Please see the \"getColor\" section \"uniform\" means global value. "},"contents/GLSL/debug.html":{"url":"contents/GLSL/debug.html","title":"デバッグ","keywords":"","body":"Debug Check the debug checkbox in the plugin panel. If your program contains errors, it will be printed into left top corner of your screen when this is checked. "},"contents/GLSL/Advanced_settings.html":{"url":"contents/GLSL/Advanced_settings.html","title":"高級設定","keywords":"","body":"Advanced settings There are several advanced settings in the effect panel. Language It controls which compiler to be used. Wrap U/V sampler This will affect the result of getColor() when sampler the pixels which is outside the boundary of image. Test code (Apply PixelsWorld to a footage.): wrap_uv_sampler.shader void main(){ outColor = getColor(uv*10); } Magnify/Minify sampler This will affect the behavior of getColor() when sampler want to do the interpolation of surrounding pixels. Test code (Apply PixelsWorld to a footage.): wrap_uv_sampler.shader void main(){ outColor = getColor(uv*0.1); } If you want to build the same pixel style effect. Swith this option to Nearest pixel "},"contents/GLSL/predefined.html":{"url":"contents/GLSL/predefined.html","title":"プリコード","keywords":"","body":"Predifined code Before run shader code, PixelsWorld conbine your input with some predifined code to support some features. GLSL mode only has pre-define code. shadertoy mode has both pre-define and post-define code. GLSL mode Pre-define code pre_frag_shader_glsl.frag #define gl_Position uv2xy(uv) #define gl_FragCoord uv2xy(uv) #define gl_FragColor outColor #define INPUT_LAYER_INDEX -1 #define OUTPUT_LAYER_INDEX -2 #define AE_INPUT_LAYER -1 #define PW_TEMP_LAYER -2 out vec4 outColor; in vec2 uv; uniform float slider[10]; uniform float angle[10]; uniform bool checkbox[10]; uniform vec2 point[10]; uniform vec3 point3d[10]; uniform vec4 color[10]; uniform sampler2D layer[10]; uniform vec2 layerResolution[10]; uniform sampler2D inLayer; uniform sampler2D outLayer; uniform float time; uniform float inpoint; uniform float duration; uniform float comp_time; uniform vec4 date; uniform float fps; uniform float width; uniform float height; uniform vec2 origin; uniform vec2 resolution; uniform vec2 downsample; uniform mat4 camera_matrix; uniform vec4 camera_info; // x,y: resolution, z: distance to plane, w: distance to focus. uniform bool camera_perspective; uniform sampler1D inWaveL; uniform sampler1D inWaveR; uniform float inWaveN; uniform float inWaveS; uniform sampler1D inSpecL; uniform sampler1D inSpecR; uniform float inSpecN; vec4 getColor(int layerId,vec2 coord) { if(layerId==AE_INPUT_LAYER) return texture(inLayer,coord); if(layerId==PW_TEMP_LAYER) return texture(outLayer,coord); else if(layerId>=0 && layerId shadertoy mode Pre-define code pre_frag_shader_shadertoy.frag #define gl_Position (_PixelsWorld_uv * iResolution.xy) #define gl_FragCoord (_PixelsWorld_uv * iResolution.xy) #define gl_FragColor _PixelsWorld_outColor uniform vec3 iResolution; uniform float iTime; uniform float iTimeDelta; uniform int iFrame; // uniform float iChannelTime[4]; uniform vec4 iMouse; uniform vec4 iDate; uniform sampler2D iChannel0; uniform sampler2D iChannel1; uniform sampler2D iChannel2; uniform sampler2D iChannel3; uniform vec3 iChannelResolution[4]; #define INPUT_LAYER_INDEX -1 #define OUTPUT_LAYER_INDEX -2 uniform float _PixelsWorld_slider[10]; uniform float _PixelsWorld_angle[10]; uniform bool _PixelsWorld_checkbox[10]; uniform vec2 _PixelsWorld_point[10]; uniform vec3 _PixelsWorld_point3d[10]; uniform vec4 _PixelsWorld_color[10]; uniform sampler2D _PixelsWorld_layer[10]; uniform vec2 _PixelsWorld_layerResolution[10]; uniform sampler2D _PixelsWorld_inLayer; uniform sampler2D _PixelsWorld_outLayer; uniform float _PixelsWorld_time; uniform float _PixelsWorld_inpoint; uniform float _PixelsWorld_duration; uniform float _PixelsWorld_comp_time; uniform vec4 _PixelsWorld_date; uniform float _PixelsWorld_fps; uniform float _PixelsWorld_width; uniform float _PixelsWorld_height; uniform vec2 _PixelsWorld_origin; uniform vec2 _PixelsWorld_resolution; uniform vec2 _PixelsWorld_downsample; uniform mat4 _PixelsWorld_camera_matrix; uniform vec4 _PixelsWorld_camera_info; uniform bool _PixelsWorld_camera_perspective; uniform sampler1D _PixelsWorld_inWaveL; uniform sampler1D _PixelsWorld_inWaveR; uniform float _PixelsWorld_inWaveN; uniform float _PixelsWorld_inWaveS; uniform sampler1D _PixelsWorld_inSpecL; uniform sampler1D _PixelsWorld_inSpecR; uniform float _PixelsWorld_inSpecN; in vec2 _PixelsWorld_uv; out vec4 _PixelsWorld_outColor; Post-define code post_frag_shader_shadertoy.frag void main(){ mainImage(_PixelsWorld_outColor, _PixelsWorld_uv * iResolution.xy); } "},"contents/GLSL/shadertoy.html":{"url":"contents/GLSL/shadertoy.html","title":"テンプレート聖域shadertoy","keywords":"","body":"テンプレート聖域shadertoy 使い方 shadertoyモードでは、shadertoy.comでのコードを直接PixelsWorldに実装することができます。 注意： すべてのshadertoyのコードがサポートされているというわけではないです。VRの使ったコードやループの入ったBufferを使ったコードはサポートされていません。 詳細 PixelsWorldの変数をこのモードで使いたいならば、_PixelsWorld_を変数名の前につけてください。 例えば、GLSLモードのslider[0]　は　_PixelsWorld_slider[0]　になります。 _PixelsWorld_の付いた変数名の宣言はお勧めしません。 "},"contents/Lua/JavaScript.html":{"url":"contents/Lua/JavaScript.html","title":"世界の郊外JavaScript","keywords":"","body":"　世界の郊外、JavaScript Lua (CPU & GPU)モードでjs(\"Your code\")関数を用いて、JavaScriptを実行します。 executeJS.lua version3() js(\"alert('Hello PixelsWorld!')\"); 注意：PixelsWorldでJavaScriptの実行をAeのストラクチャよりお勧めしません。 "},"contents/Lua/CMDCode.html":{"url":"contents/Lua/CMDCode.html","title":"世界の基盤CMD","keywords":"","body":"世界の基盤CMD Lua (CPU & GPU)モードでcmd(\"Your code\")関数を用いて、cmdコマンドを実行します。 executeCMD.lua version3() cmd(\"echo Hello PixelsWorld! & pause\"); "},"contents/Serial/SerialAttention.html":{"url":"contents/Serial/SerialAttention.html","title":"規約","keywords":"","body":"シリアルナンバー規約 注意：aescripts.comでご購入になった及びご検討中のお客様に、当「シリアルナンバー規約」は適用しませんので、ご注意ください。 シリアルナンバー一個にはN個の認証ＰＣ数が入っています。 (N >= 1) 認証ＰＣ数一個で、一つのPCをアクティベート（認証）します。 認証ＰＣ数一個は、同じPCならば、異なるバージョンのAeにシェアされます。 アクティベートには一個の認証ＰＣ数を消耗し、反アクティベート（認証を外す）には一個の認証ＰＣ数を復元します。 アクティベート 及び 反アクティベート操作のみ、インターネットが必須で、それ以外の場合、ネット環境無しでご利用できます。 PCのマザーボードやCPUを変換する前に反アクティベートを実行し、変換完了後再びアクティベートしてください。反アクティベートを忘れ、再認証失敗の場合メールにてお問い合わせください。 シリアルナンバーには個人情報が入っていないので、シリアルナンバーの再販売を許容しますが、お勧めしません。シリアルナンバーの再販売で生じたトラブルには、未来視覚演繹グループはその責任を一切負えないのでご了承ください。 認証ＰＣ数は特にリクエストがない場合は１で販売しています。同時にたくさんのPC でPixelsWorldをご利用になりたいお客様は、PC数に応じる認証ＰＣ数をご購入ください。Flashback Japanにおいては、1~3の認証ＰＣ数の入ったシリアルナンバーを販売しています（4以上のリクエストも承ります）。たくさん購入したいお客様はこちらで購入する方がお得です。 "},"contents/QA/EntryPointErr.html":{"url":"contents/QA/EntryPointErr.html","title":"エラー： Couldn't find main entry point for PixelsWorld.aex (48::72)","keywords":"","body":"エラー: Couldn't find main entry point for PixelsWorld.aex (48::72) 次のエラーが出た時、以下の各事項をチェックしてください。 Creative Cloudを通じてAeを最新版に更新すること（CC2019の場合16.1.3+、2020の場合17.5.1+がお勧めです） Windows10 は最新版であること(Windows 10 20H2 以降のバージョンがお勧めです) グラフィックカードドライバーは最新版であること グラフィックカードはOpenGL 3.3以降のプロトコルをサポートしていること(OpenGL Extensions Viewerツールを用いて確認可能です) OpenCL.dllはC:\\Windows\\System32というパスに入っていること。 "}}